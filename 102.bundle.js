(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[102],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/xquery.js":
/*!**************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/xquery.js ***!
  \**************************************************************/
/*! exports provided: xQuery */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"xQuery\", function() { return xQuery; });\n// The keywords object is set to the result of this self executing\n// function. Each keyword is a property of the keywords object whose\n// value is {type: atype, style: astyle}\nvar keywords = function(){\n  // convenience functions used to build keywords object\n  function kw(type) {return {type: type, style: \"keyword\"};}\n  var operator = kw(\"operator\")\n  , atom = {type: \"atom\", style: \"atom\"}\n  , punctuation = {type: \"punctuation\", style: null}\n  , qualifier = {type: \"axis_specifier\", style: \"qualifier\"};\n\n  // kwObj is what is return from this function at the end\n  var kwObj = {\n    ',': punctuation\n  };\n\n  // a list of 'basic' keywords. For each add a property to kwObj with the value of\n  // {type: basic[i], style: \"keyword\"} e.g. 'after' --> {type: \"after\", style: \"keyword\"}\n  var basic = ['after', 'all', 'allowing', 'ancestor', 'ancestor-or-self', 'any', 'array', 'as',\n               'ascending', 'at', 'attribute', 'base-uri', 'before', 'boundary-space', 'by', 'case', 'cast',\n               'castable', 'catch', 'child', 'collation', 'comment', 'construction', 'contains', 'content',\n               'context', 'copy', 'copy-namespaces', 'count', 'decimal-format', 'declare', 'default', 'delete',\n               'descendant', 'descendant-or-self', 'descending', 'diacritics', 'different', 'distance',\n               'document', 'document-node', 'element', 'else', 'empty', 'empty-sequence', 'encoding', 'end',\n               'entire', 'every', 'exactly', 'except', 'external', 'first', 'following', 'following-sibling',\n               'for', 'from', 'ftand', 'ftnot', 'ft-option', 'ftor', 'function', 'fuzzy', 'greatest', 'group',\n               'if', 'import', 'in', 'inherit', 'insensitive', 'insert', 'instance', 'intersect', 'into',\n               'invoke', 'is', 'item', 'language', 'last', 'lax', 'least', 'let', 'levels', 'lowercase', 'map',\n               'modify', 'module', 'most', 'namespace', 'next', 'no', 'node', 'nodes', 'no-inherit',\n               'no-preserve', 'not', 'occurs', 'of', 'only', 'option', 'order', 'ordered', 'ordering',\n               'paragraph', 'paragraphs', 'parent', 'phrase', 'preceding', 'preceding-sibling', 'preserve',\n               'previous', 'processing-instruction', 'relationship', 'rename', 'replace', 'return',\n               'revalidation', 'same', 'satisfies', 'schema', 'schema-attribute', 'schema-element', 'score',\n               'self', 'sensitive', 'sentence', 'sentences', 'sequence', 'skip', 'sliding', 'some', 'stable',\n               'start', 'stemming', 'stop', 'strict', 'strip', 'switch', 'text', 'then', 'thesaurus', 'times',\n               'to', 'transform', 'treat', 'try', 'tumbling', 'type', 'typeswitch', 'union', 'unordered',\n               'update', 'updating', 'uppercase', 'using', 'validate', 'value', 'variable', 'version',\n               'weight', 'when', 'where', 'wildcards', 'window', 'with', 'without', 'word', 'words', 'xquery'];\n  for(var i=0, l=basic.length; i < l; i++) { kwObj[basic[i]] = kw(basic[i]);};\n\n  // a list of types. For each add a property to kwObj with the value of\n  // {type: \"atom\", style: \"atom\"}\n  var types = ['xs:anyAtomicType', 'xs:anySimpleType', 'xs:anyType', 'xs:anyURI',\n               'xs:base64Binary', 'xs:boolean', 'xs:byte', 'xs:date', 'xs:dateTime', 'xs:dateTimeStamp',\n               'xs:dayTimeDuration', 'xs:decimal', 'xs:double', 'xs:duration', 'xs:ENTITIES', 'xs:ENTITY',\n               'xs:float', 'xs:gDay', 'xs:gMonth', 'xs:gMonthDay', 'xs:gYear', 'xs:gYearMonth', 'xs:hexBinary',\n               'xs:ID', 'xs:IDREF', 'xs:IDREFS', 'xs:int', 'xs:integer', 'xs:item', 'xs:java', 'xs:language',\n               'xs:long', 'xs:Name', 'xs:NCName', 'xs:negativeInteger', 'xs:NMTOKEN', 'xs:NMTOKENS',\n               'xs:nonNegativeInteger', 'xs:nonPositiveInteger', 'xs:normalizedString', 'xs:NOTATION',\n               'xs:numeric', 'xs:positiveInteger', 'xs:precisionDecimal', 'xs:QName', 'xs:short', 'xs:string',\n               'xs:time', 'xs:token', 'xs:unsignedByte', 'xs:unsignedInt', 'xs:unsignedLong',\n               'xs:unsignedShort', 'xs:untyped', 'xs:untypedAtomic', 'xs:yearMonthDuration'];\n  for(var i=0, l=types.length; i < l; i++) { kwObj[types[i]] = atom;};\n\n  // each operator will add a property to kwObj with value of {type: \"operator\", style: \"keyword\"}\n  var operators = ['eq', 'ne', 'lt', 'le', 'gt', 'ge', ':=', '=', '>', '>=', '<', '<=', '.', '|', '?', 'and', 'or', 'div', 'idiv', 'mod', '*', '/', '+', '-'];\n  for(var i=0, l=operators.length; i < l; i++) { kwObj[operators[i]] = operator;};\n\n  // each axis_specifiers will add a property to kwObj with value of {type: \"axis_specifier\", style: \"qualifier\"}\n  var axis_specifiers = [\"self::\", \"attribute::\", \"child::\", \"descendant::\", \"descendant-or-self::\", \"parent::\",\n                         \"ancestor::\", \"ancestor-or-self::\", \"following::\", \"preceding::\", \"following-sibling::\", \"preceding-sibling::\"];\n  for(var i=0, l=axis_specifiers.length; i < l; i++) { kwObj[axis_specifiers[i]] = qualifier; };\n\n  return kwObj;\n}();\n\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\n\n// the primary mode tokenizer\nfunction tokenBase(stream, state) {\n  var ch = stream.next(),\n      mightBeFunction = false,\n      isEQName = isEQNameAhead(stream);\n\n  // an XML tag (if not in some sub, chained tokenizer)\n  if (ch == \"<\") {\n    if(stream.match(\"!--\", true))\n      return chain(stream, state, tokenXMLComment);\n\n    if(stream.match(\"![CDATA\", false)) {\n      state.tokenize = tokenCDATA;\n      return \"tag\";\n    }\n\n    if(stream.match(\"?\", false)) {\n      return chain(stream, state, tokenPreProcessing);\n    }\n\n    var isclose = stream.eat(\"/\");\n    stream.eatSpace();\n    var tagName = \"\", c;\n    while ((c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/))) tagName += c;\n\n    return chain(stream, state, tokenTag(tagName, isclose));\n  }\n  // start code block\n  else if(ch == \"{\") {\n    pushStateStack(state, { type: \"codeblock\"});\n    return null;\n  }\n  // end code block\n  else if(ch == \"}\") {\n    popStateStack(state);\n    return null;\n  }\n  // if we're in an XML block\n  else if(isInXmlBlock(state)) {\n    if(ch == \">\")\n      return \"tag\";\n    else if(ch == \"/\" && stream.eat(\">\")) {\n      popStateStack(state);\n      return \"tag\";\n    }\n    else\n      return \"variable\";\n  }\n  // if a number\n  else if (/\\d/.test(ch)) {\n    stream.match(/^\\d*(?:\\.\\d*)?(?:E[+\\-]?\\d+)?/);\n    return \"atom\";\n  }\n  // comment start\n  else if (ch === \"(\" && stream.eat(\":\")) {\n    pushStateStack(state, { type: \"comment\"});\n    return chain(stream, state, tokenComment);\n  }\n  // quoted string\n  else if (!isEQName && (ch === '\"' || ch === \"'\"))\n    return chain(stream, state, tokenString(ch));\n  // variable\n  else if(ch === \"$\") {\n    return chain(stream, state, tokenVariable);\n  }\n  // assignment\n  else if(ch ===\":\" && stream.eat(\"=\")) {\n    return \"keyword\";\n  }\n  // open paren\n  else if(ch === \"(\") {\n    pushStateStack(state, { type: \"paren\"});\n    return null;\n  }\n  // close paren\n  else if(ch === \")\") {\n    popStateStack(state);\n    return null;\n  }\n  // open paren\n  else if(ch === \"[\") {\n    pushStateStack(state, { type: \"bracket\"});\n    return null;\n  }\n  // close paren\n  else if(ch === \"]\") {\n    popStateStack(state);\n    return null;\n  }\n  else {\n    var known = keywords.propertyIsEnumerable(ch) && keywords[ch];\n\n    // if there's a EQName ahead, consume the rest of the string portion, it's likely a function\n    if(isEQName && ch === '\\\"') while(stream.next() !== '\"'){}\n    if(isEQName && ch === '\\'') while(stream.next() !== '\\''){}\n\n    // gobble up a word if the character is not known\n    if(!known) stream.eatWhile(/[\\w\\$_-]/);\n\n    // gobble a colon in the case that is a lib func type call fn:doc\n    var foundColon = stream.eat(\":\");\n\n    // if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier\n    // which should get matched as a keyword\n    if(!stream.eat(\":\") && foundColon) {\n      stream.eatWhile(/[\\w\\$_-]/);\n    }\n    // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)\n    if(stream.match(/^[ \\t]*\\(/, false)) {\n      mightBeFunction = true;\n    }\n    // is the word a keyword?\n    var word = stream.current();\n    known = keywords.propertyIsEnumerable(word) && keywords[word];\n\n    // if we think it's a function call but not yet known,\n    // set style to variable for now for lack of something better\n    if(mightBeFunction && !known) known = {type: \"function_call\", style: \"def\"};\n\n    // if the previous word was element, attribute, axis specifier, this word should be the name of that\n    if(isInXmlConstructor(state)) {\n      popStateStack(state);\n      return \"variable\";\n    }\n    // as previously checked, if the word is element,attribute, axis specifier, call it an \"xmlconstructor\" and\n    // push the stack so we know to look for it on the next word\n    if(word == \"element\" || word == \"attribute\" || known.type == \"axis_specifier\") pushStateStack(state, {type: \"xmlconstructor\"});\n\n    // if the word is known, return the details of that else just call this a generic 'word'\n    return known ? known.style : \"variable\";\n  }\n}\n\n// handle comments, including nested\nfunction tokenComment(stream, state) {\n  var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;\n  while (ch = stream.next()) {\n    if (ch == \")\" && maybeEnd) {\n      if(nestedCount > 0)\n        nestedCount--;\n      else {\n        popStateStack(state);\n        break;\n      }\n    }\n    else if(ch == \":\" && maybeNested) {\n      nestedCount++;\n    }\n    maybeEnd = (ch == \":\");\n    maybeNested = (ch == \"(\");\n  }\n\n  return \"comment\";\n}\n\n// tokenizer for string literals\n// optionally pass a tokenizer function to set state.tokenize back to when finished\nfunction tokenString(quote, f) {\n  return function(stream, state) {\n    var ch;\n\n    if(isInString(state) && stream.current() == quote) {\n      popStateStack(state);\n      if(f) state.tokenize = f;\n      return \"string\";\n    }\n\n    pushStateStack(state, { type: \"string\", name: quote, tokenize: tokenString(quote, f) });\n\n    // if we're in a string and in an XML block, allow an embedded code block\n    if(stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n      state.tokenize = tokenBase;\n      return \"string\";\n    }\n\n\n    while (ch = stream.next()) {\n      if (ch ==  quote) {\n        popStateStack(state);\n        if(f) state.tokenize = f;\n        break;\n      }\n      else {\n        // if we're in a string and in an XML block, allow an embedded code block in an attribute\n        if(stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n          state.tokenize = tokenBase;\n          return \"string\";\n        }\n\n      }\n    }\n\n    return \"string\";\n  };\n}\n\n// tokenizer for variables\nfunction tokenVariable(stream, state) {\n  var isVariableChar = /[\\w\\$_-]/;\n\n  // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote\n  if(stream.eat(\"\\\"\")) {\n    while(stream.next() !== '\\\"'){};\n    stream.eat(\":\");\n  } else {\n    stream.eatWhile(isVariableChar);\n    if(!stream.match(\":=\", false)) stream.eat(\":\");\n  }\n  stream.eatWhile(isVariableChar);\n  state.tokenize = tokenBase;\n  return \"variable\";\n}\n\n// tokenizer for XML tags\nfunction tokenTag(name, isclose) {\n  return function(stream, state) {\n    stream.eatSpace();\n    if(isclose && stream.eat(\">\")) {\n      popStateStack(state);\n      state.tokenize = tokenBase;\n      return \"tag\";\n    }\n    // self closing tag without attributes?\n    if(!stream.eat(\"/\"))\n      pushStateStack(state, { type: \"tag\", name: name, tokenize: tokenBase});\n    if(!stream.eat(\">\")) {\n      state.tokenize = tokenAttribute;\n      return \"tag\";\n    }\n    else {\n      state.tokenize = tokenBase;\n    }\n    return \"tag\";\n  };\n}\n\n// tokenizer for XML attributes\nfunction tokenAttribute(stream, state) {\n  var ch = stream.next();\n\n  if(ch == \"/\" && stream.eat(\">\")) {\n    if(isInXmlAttributeBlock(state)) popStateStack(state);\n    if(isInXmlBlock(state)) popStateStack(state);\n    return \"tag\";\n  }\n  if(ch == \">\") {\n    if(isInXmlAttributeBlock(state)) popStateStack(state);\n    return \"tag\";\n  }\n  if(ch == \"=\")\n    return null;\n  // quoted string\n  if (ch == '\"' || ch == \"'\")\n    return chain(stream, state, tokenString(ch, tokenAttribute));\n\n  if(!isInXmlAttributeBlock(state))\n    pushStateStack(state, { type: \"attribute\", tokenize: tokenAttribute});\n\n  stream.eat(/[a-zA-Z_:]/);\n  stream.eatWhile(/[-a-zA-Z0-9_:.]/);\n  stream.eatSpace();\n\n  // the case where the attribute has not value and the tag was closed\n  if(stream.match(\">\", false) || stream.match(\"/\", false)) {\n    popStateStack(state);\n    state.tokenize = tokenBase;\n  }\n\n  return \"attribute\";\n}\n\n// handle comments, including nested\nfunction tokenXMLComment(stream, state) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"-\" && stream.match(\"->\", true)) {\n      state.tokenize = tokenBase;\n      return \"comment\";\n    }\n  }\n}\n\n\n// handle CDATA\nfunction tokenCDATA(stream, state) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"]\" && stream.match(\"]\", true)) {\n      state.tokenize = tokenBase;\n      return \"comment\";\n    }\n  }\n}\n\n// handle preprocessing instructions\nfunction tokenPreProcessing(stream, state) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"?\" && stream.match(\">\", true)) {\n      state.tokenize = tokenBase;\n      return \"processingInstruction\";\n    }\n  }\n}\n\n\n// functions to test the current context of the state\nfunction isInXmlBlock(state) { return isIn(state, \"tag\"); }\nfunction isInXmlAttributeBlock(state) { return isIn(state, \"attribute\"); }\nfunction isInXmlConstructor(state) { return isIn(state, \"xmlconstructor\"); }\nfunction isInString(state) { return isIn(state, \"string\"); }\n\nfunction isEQNameAhead(stream) {\n  // assume we've already eaten a quote (\")\n  if(stream.current() === '\"')\n    return stream.match(/^[^\\\"]+\\\"\\:/, false);\n  else if(stream.current() === '\\'')\n    return stream.match(/^[^\\\"]+\\'\\:/, false);\n  else\n    return false;\n}\n\nfunction isIn(state, type) {\n  return (state.stack.length && state.stack[state.stack.length - 1].type == type);\n}\n\nfunction pushStateStack(state, newState) {\n  state.stack.push(newState);\n}\n\nfunction popStateStack(state) {\n  state.stack.pop();\n  var reinstateTokenize = state.stack.length && state.stack[state.stack.length-1].tokenize;\n  state.tokenize = reinstateTokenize || tokenBase;\n}\n\n// the interface for the mode API\nconst xQuery = {\n  startState: function() {\n    return {\n      tokenize: tokenBase,\n      cc: [],\n      stack: []\n    };\n  },\n\n  token: function(stream, state) {\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    return style;\n  },\n\n  languageData: {\n    commentTokens: {block: {open: \"(:\", close: \":)\"}}\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUveHF1ZXJ5LmpzPzliZTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0EsWUFBWTtBQUNaLG1CQUFtQjtBQUNuQixpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxpQ0FBaUMsbUJBQW1CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTyxPQUFPOztBQUU1QztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixPQUFPLE9BQU87O0FBRTVDLCtEQUErRDtBQUMvRDtBQUNBLGtDQUFrQyxPQUFPLE9BQU87O0FBRWhELHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU8sT0FBTyx1Q0FBdUM7O0FBRTdGO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZUFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyx1QkFBdUI7O0FBRWpJO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsK0RBQStEOztBQUUxRjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhDQUE4QztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQiw2Q0FBNkM7O0FBRXhFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLDhCQUE4QiwyQkFBMkI7QUFDekQsdUNBQXVDLGlDQUFpQztBQUN4RSxvQ0FBb0Msc0NBQXNDO0FBQzFFLDRCQUE0Qiw4QkFBOEI7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS94cXVlcnkuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGUga2V5d29yZHMgb2JqZWN0IGlzIHNldCB0byB0aGUgcmVzdWx0IG9mIHRoaXMgc2VsZiBleGVjdXRpbmdcbi8vIGZ1bmN0aW9uLiBFYWNoIGtleXdvcmQgaXMgYSBwcm9wZXJ0eSBvZiB0aGUga2V5d29yZHMgb2JqZWN0IHdob3NlXG4vLyB2YWx1ZSBpcyB7dHlwZTogYXR5cGUsIHN0eWxlOiBhc3R5bGV9XG52YXIga2V5d29yZHMgPSBmdW5jdGlvbigpe1xuICAvLyBjb252ZW5pZW5jZSBmdW5jdGlvbnMgdXNlZCB0byBidWlsZCBrZXl3b3JkcyBvYmplY3RcbiAgZnVuY3Rpb24ga3codHlwZSkge3JldHVybiB7dHlwZTogdHlwZSwgc3R5bGU6IFwia2V5d29yZFwifTt9XG4gIHZhciBvcGVyYXRvciA9IGt3KFwib3BlcmF0b3JcIilcbiAgLCBhdG9tID0ge3R5cGU6IFwiYXRvbVwiLCBzdHlsZTogXCJhdG9tXCJ9XG4gICwgcHVuY3R1YXRpb24gPSB7dHlwZTogXCJwdW5jdHVhdGlvblwiLCBzdHlsZTogbnVsbH1cbiAgLCBxdWFsaWZpZXIgPSB7dHlwZTogXCJheGlzX3NwZWNpZmllclwiLCBzdHlsZTogXCJxdWFsaWZpZXJcIn07XG5cbiAgLy8ga3dPYmogaXMgd2hhdCBpcyByZXR1cm4gZnJvbSB0aGlzIGZ1bmN0aW9uIGF0IHRoZSBlbmRcbiAgdmFyIGt3T2JqID0ge1xuICAgICcsJzogcHVuY3R1YXRpb25cbiAgfTtcblxuICAvLyBhIGxpc3Qgb2YgJ2Jhc2ljJyBrZXl3b3Jkcy4gRm9yIGVhY2ggYWRkIGEgcHJvcGVydHkgdG8ga3dPYmogd2l0aCB0aGUgdmFsdWUgb2ZcbiAgLy8ge3R5cGU6IGJhc2ljW2ldLCBzdHlsZTogXCJrZXl3b3JkXCJ9IGUuZy4gJ2FmdGVyJyAtLT4ge3R5cGU6IFwiYWZ0ZXJcIiwgc3R5bGU6IFwia2V5d29yZFwifVxuICB2YXIgYmFzaWMgPSBbJ2FmdGVyJywgJ2FsbCcsICdhbGxvd2luZycsICdhbmNlc3RvcicsICdhbmNlc3Rvci1vci1zZWxmJywgJ2FueScsICdhcnJheScsICdhcycsXG4gICAgICAgICAgICAgICAnYXNjZW5kaW5nJywgJ2F0JywgJ2F0dHJpYnV0ZScsICdiYXNlLXVyaScsICdiZWZvcmUnLCAnYm91bmRhcnktc3BhY2UnLCAnYnknLCAnY2FzZScsICdjYXN0JyxcbiAgICAgICAgICAgICAgICdjYXN0YWJsZScsICdjYXRjaCcsICdjaGlsZCcsICdjb2xsYXRpb24nLCAnY29tbWVudCcsICdjb25zdHJ1Y3Rpb24nLCAnY29udGFpbnMnLCAnY29udGVudCcsXG4gICAgICAgICAgICAgICAnY29udGV4dCcsICdjb3B5JywgJ2NvcHktbmFtZXNwYWNlcycsICdjb3VudCcsICdkZWNpbWFsLWZvcm1hdCcsICdkZWNsYXJlJywgJ2RlZmF1bHQnLCAnZGVsZXRlJyxcbiAgICAgICAgICAgICAgICdkZXNjZW5kYW50JywgJ2Rlc2NlbmRhbnQtb3Itc2VsZicsICdkZXNjZW5kaW5nJywgJ2RpYWNyaXRpY3MnLCAnZGlmZmVyZW50JywgJ2Rpc3RhbmNlJyxcbiAgICAgICAgICAgICAgICdkb2N1bWVudCcsICdkb2N1bWVudC1ub2RlJywgJ2VsZW1lbnQnLCAnZWxzZScsICdlbXB0eScsICdlbXB0eS1zZXF1ZW5jZScsICdlbmNvZGluZycsICdlbmQnLFxuICAgICAgICAgICAgICAgJ2VudGlyZScsICdldmVyeScsICdleGFjdGx5JywgJ2V4Y2VwdCcsICdleHRlcm5hbCcsICdmaXJzdCcsICdmb2xsb3dpbmcnLCAnZm9sbG93aW5nLXNpYmxpbmcnLFxuICAgICAgICAgICAgICAgJ2ZvcicsICdmcm9tJywgJ2Z0YW5kJywgJ2Z0bm90JywgJ2Z0LW9wdGlvbicsICdmdG9yJywgJ2Z1bmN0aW9uJywgJ2Z1enp5JywgJ2dyZWF0ZXN0JywgJ2dyb3VwJyxcbiAgICAgICAgICAgICAgICdpZicsICdpbXBvcnQnLCAnaW4nLCAnaW5oZXJpdCcsICdpbnNlbnNpdGl2ZScsICdpbnNlcnQnLCAnaW5zdGFuY2UnLCAnaW50ZXJzZWN0JywgJ2ludG8nLFxuICAgICAgICAgICAgICAgJ2ludm9rZScsICdpcycsICdpdGVtJywgJ2xhbmd1YWdlJywgJ2xhc3QnLCAnbGF4JywgJ2xlYXN0JywgJ2xldCcsICdsZXZlbHMnLCAnbG93ZXJjYXNlJywgJ21hcCcsXG4gICAgICAgICAgICAgICAnbW9kaWZ5JywgJ21vZHVsZScsICdtb3N0JywgJ25hbWVzcGFjZScsICduZXh0JywgJ25vJywgJ25vZGUnLCAnbm9kZXMnLCAnbm8taW5oZXJpdCcsXG4gICAgICAgICAgICAgICAnbm8tcHJlc2VydmUnLCAnbm90JywgJ29jY3VycycsICdvZicsICdvbmx5JywgJ29wdGlvbicsICdvcmRlcicsICdvcmRlcmVkJywgJ29yZGVyaW5nJyxcbiAgICAgICAgICAgICAgICdwYXJhZ3JhcGgnLCAncGFyYWdyYXBocycsICdwYXJlbnQnLCAncGhyYXNlJywgJ3ByZWNlZGluZycsICdwcmVjZWRpbmctc2libGluZycsICdwcmVzZXJ2ZScsXG4gICAgICAgICAgICAgICAncHJldmlvdXMnLCAncHJvY2Vzc2luZy1pbnN0cnVjdGlvbicsICdyZWxhdGlvbnNoaXAnLCAncmVuYW1lJywgJ3JlcGxhY2UnLCAncmV0dXJuJyxcbiAgICAgICAgICAgICAgICdyZXZhbGlkYXRpb24nLCAnc2FtZScsICdzYXRpc2ZpZXMnLCAnc2NoZW1hJywgJ3NjaGVtYS1hdHRyaWJ1dGUnLCAnc2NoZW1hLWVsZW1lbnQnLCAnc2NvcmUnLFxuICAgICAgICAgICAgICAgJ3NlbGYnLCAnc2Vuc2l0aXZlJywgJ3NlbnRlbmNlJywgJ3NlbnRlbmNlcycsICdzZXF1ZW5jZScsICdza2lwJywgJ3NsaWRpbmcnLCAnc29tZScsICdzdGFibGUnLFxuICAgICAgICAgICAgICAgJ3N0YXJ0JywgJ3N0ZW1taW5nJywgJ3N0b3AnLCAnc3RyaWN0JywgJ3N0cmlwJywgJ3N3aXRjaCcsICd0ZXh0JywgJ3RoZW4nLCAndGhlc2F1cnVzJywgJ3RpbWVzJyxcbiAgICAgICAgICAgICAgICd0bycsICd0cmFuc2Zvcm0nLCAndHJlYXQnLCAndHJ5JywgJ3R1bWJsaW5nJywgJ3R5cGUnLCAndHlwZXN3aXRjaCcsICd1bmlvbicsICd1bm9yZGVyZWQnLFxuICAgICAgICAgICAgICAgJ3VwZGF0ZScsICd1cGRhdGluZycsICd1cHBlcmNhc2UnLCAndXNpbmcnLCAndmFsaWRhdGUnLCAndmFsdWUnLCAndmFyaWFibGUnLCAndmVyc2lvbicsXG4gICAgICAgICAgICAgICAnd2VpZ2h0JywgJ3doZW4nLCAnd2hlcmUnLCAnd2lsZGNhcmRzJywgJ3dpbmRvdycsICd3aXRoJywgJ3dpdGhvdXQnLCAnd29yZCcsICd3b3JkcycsICd4cXVlcnknXTtcbiAgZm9yKHZhciBpPTAsIGw9YmFzaWMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGt3T2JqW2Jhc2ljW2ldXSA9IGt3KGJhc2ljW2ldKTt9O1xuXG4gIC8vIGEgbGlzdCBvZiB0eXBlcy4gRm9yIGVhY2ggYWRkIGEgcHJvcGVydHkgdG8ga3dPYmogd2l0aCB0aGUgdmFsdWUgb2ZcbiAgLy8ge3R5cGU6IFwiYXRvbVwiLCBzdHlsZTogXCJhdG9tXCJ9XG4gIHZhciB0eXBlcyA9IFsneHM6YW55QXRvbWljVHlwZScsICd4czphbnlTaW1wbGVUeXBlJywgJ3hzOmFueVR5cGUnLCAneHM6YW55VVJJJyxcbiAgICAgICAgICAgICAgICd4czpiYXNlNjRCaW5hcnknLCAneHM6Ym9vbGVhbicsICd4czpieXRlJywgJ3hzOmRhdGUnLCAneHM6ZGF0ZVRpbWUnLCAneHM6ZGF0ZVRpbWVTdGFtcCcsXG4gICAgICAgICAgICAgICAneHM6ZGF5VGltZUR1cmF0aW9uJywgJ3hzOmRlY2ltYWwnLCAneHM6ZG91YmxlJywgJ3hzOmR1cmF0aW9uJywgJ3hzOkVOVElUSUVTJywgJ3hzOkVOVElUWScsXG4gICAgICAgICAgICAgICAneHM6ZmxvYXQnLCAneHM6Z0RheScsICd4czpnTW9udGgnLCAneHM6Z01vbnRoRGF5JywgJ3hzOmdZZWFyJywgJ3hzOmdZZWFyTW9udGgnLCAneHM6aGV4QmluYXJ5JyxcbiAgICAgICAgICAgICAgICd4czpJRCcsICd4czpJRFJFRicsICd4czpJRFJFRlMnLCAneHM6aW50JywgJ3hzOmludGVnZXInLCAneHM6aXRlbScsICd4czpqYXZhJywgJ3hzOmxhbmd1YWdlJyxcbiAgICAgICAgICAgICAgICd4czpsb25nJywgJ3hzOk5hbWUnLCAneHM6TkNOYW1lJywgJ3hzOm5lZ2F0aXZlSW50ZWdlcicsICd4czpOTVRPS0VOJywgJ3hzOk5NVE9LRU5TJyxcbiAgICAgICAgICAgICAgICd4czpub25OZWdhdGl2ZUludGVnZXInLCAneHM6bm9uUG9zaXRpdmVJbnRlZ2VyJywgJ3hzOm5vcm1hbGl6ZWRTdHJpbmcnLCAneHM6Tk9UQVRJT04nLFxuICAgICAgICAgICAgICAgJ3hzOm51bWVyaWMnLCAneHM6cG9zaXRpdmVJbnRlZ2VyJywgJ3hzOnByZWNpc2lvbkRlY2ltYWwnLCAneHM6UU5hbWUnLCAneHM6c2hvcnQnLCAneHM6c3RyaW5nJyxcbiAgICAgICAgICAgICAgICd4czp0aW1lJywgJ3hzOnRva2VuJywgJ3hzOnVuc2lnbmVkQnl0ZScsICd4czp1bnNpZ25lZEludCcsICd4czp1bnNpZ25lZExvbmcnLFxuICAgICAgICAgICAgICAgJ3hzOnVuc2lnbmVkU2hvcnQnLCAneHM6dW50eXBlZCcsICd4czp1bnR5cGVkQXRvbWljJywgJ3hzOnllYXJNb250aER1cmF0aW9uJ107XG4gIGZvcih2YXIgaT0wLCBsPXR5cGVzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBrd09ialt0eXBlc1tpXV0gPSBhdG9tO307XG5cbiAgLy8gZWFjaCBvcGVyYXRvciB3aWxsIGFkZCBhIHByb3BlcnR5IHRvIGt3T2JqIHdpdGggdmFsdWUgb2Yge3R5cGU6IFwib3BlcmF0b3JcIiwgc3R5bGU6IFwia2V5d29yZFwifVxuICB2YXIgb3BlcmF0b3JzID0gWydlcScsICduZScsICdsdCcsICdsZScsICdndCcsICdnZScsICc6PScsICc9JywgJz4nLCAnPj0nLCAnPCcsICc8PScsICcuJywgJ3wnLCAnPycsICdhbmQnLCAnb3InLCAnZGl2JywgJ2lkaXYnLCAnbW9kJywgJyonLCAnLycsICcrJywgJy0nXTtcbiAgZm9yKHZhciBpPTAsIGw9b3BlcmF0b3JzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBrd09ialtvcGVyYXRvcnNbaV1dID0gb3BlcmF0b3I7fTtcblxuICAvLyBlYWNoIGF4aXNfc3BlY2lmaWVycyB3aWxsIGFkZCBhIHByb3BlcnR5IHRvIGt3T2JqIHdpdGggdmFsdWUgb2Yge3R5cGU6IFwiYXhpc19zcGVjaWZpZXJcIiwgc3R5bGU6IFwicXVhbGlmaWVyXCJ9XG4gIHZhciBheGlzX3NwZWNpZmllcnMgPSBbXCJzZWxmOjpcIiwgXCJhdHRyaWJ1dGU6OlwiLCBcImNoaWxkOjpcIiwgXCJkZXNjZW5kYW50OjpcIiwgXCJkZXNjZW5kYW50LW9yLXNlbGY6OlwiLCBcInBhcmVudDo6XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCJhbmNlc3Rvcjo6XCIsIFwiYW5jZXN0b3Itb3Itc2VsZjo6XCIsIFwiZm9sbG93aW5nOjpcIiwgXCJwcmVjZWRpbmc6OlwiLCBcImZvbGxvd2luZy1zaWJsaW5nOjpcIiwgXCJwcmVjZWRpbmctc2libGluZzo6XCJdO1xuICBmb3IodmFyIGk9MCwgbD1heGlzX3NwZWNpZmllcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGt3T2JqW2F4aXNfc3BlY2lmaWVyc1tpXV0gPSBxdWFsaWZpZXI7IH07XG5cbiAgcmV0dXJuIGt3T2JqO1xufSgpO1xuXG5mdW5jdGlvbiBjaGFpbihzdHJlYW0sIHN0YXRlLCBmKSB7XG4gIHN0YXRlLnRva2VuaXplID0gZjtcbiAgcmV0dXJuIGYoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIHRoZSBwcmltYXJ5IG1vZGUgdG9rZW5pemVyXG5mdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpLFxuICAgICAgbWlnaHRCZUZ1bmN0aW9uID0gZmFsc2UsXG4gICAgICBpc0VRTmFtZSA9IGlzRVFOYW1lQWhlYWQoc3RyZWFtKTtcblxuICAvLyBhbiBYTUwgdGFnIChpZiBub3QgaW4gc29tZSBzdWIsIGNoYWluZWQgdG9rZW5pemVyKVxuICBpZiAoY2ggPT0gXCI8XCIpIHtcbiAgICBpZihzdHJlYW0ubWF0Y2goXCIhLS1cIiwgdHJ1ZSkpXG4gICAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdG9rZW5YTUxDb21tZW50KTtcblxuICAgIGlmKHN0cmVhbS5tYXRjaChcIiFbQ0RBVEFcIiwgZmFsc2UpKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQ0RBVEE7XG4gICAgICByZXR1cm4gXCJ0YWdcIjtcbiAgICB9XG5cbiAgICBpZihzdHJlYW0ubWF0Y2goXCI/XCIsIGZhbHNlKSkge1xuICAgICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuUHJlUHJvY2Vzc2luZyk7XG4gICAgfVxuXG4gICAgdmFyIGlzY2xvc2UgPSBzdHJlYW0uZWF0KFwiL1wiKTtcbiAgICBzdHJlYW0uZWF0U3BhY2UoKTtcbiAgICB2YXIgdGFnTmFtZSA9IFwiXCIsIGM7XG4gICAgd2hpbGUgKChjID0gc3RyZWFtLmVhdCgvW15cXHNcXHUwMGEwPTw+XFxcIlxcJ1xcLz9dLykpKSB0YWdOYW1lICs9IGM7XG5cbiAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdG9rZW5UYWcodGFnTmFtZSwgaXNjbG9zZSkpO1xuICB9XG4gIC8vIHN0YXJ0IGNvZGUgYmxvY2tcbiAgZWxzZSBpZihjaCA9PSBcIntcIikge1xuICAgIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCB7IHR5cGU6IFwiY29kZWJsb2NrXCJ9KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBlbmQgY29kZSBibG9ja1xuICBlbHNlIGlmKGNoID09IFwifVwiKSB7XG4gICAgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gaWYgd2UncmUgaW4gYW4gWE1MIGJsb2NrXG4gIGVsc2UgaWYoaXNJblhtbEJsb2NrKHN0YXRlKSkge1xuICAgIGlmKGNoID09IFwiPlwiKVxuICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgZWxzZSBpZihjaCA9PSBcIi9cIiAmJiBzdHJlYW0uZWF0KFwiPlwiKSkge1xuICAgICAgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgICByZXR1cm4gXCJ0YWdcIjtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgfVxuICAvLyBpZiBhIG51bWJlclxuICBlbHNlIGlmICgvXFxkLy50ZXN0KGNoKSkge1xuICAgIHN0cmVhbS5tYXRjaCgvXlxcZCooPzpcXC5cXGQqKT8oPzpFWytcXC1dP1xcZCspPy8pO1xuICAgIHJldHVybiBcImF0b21cIjtcbiAgfVxuICAvLyBjb21tZW50IHN0YXJ0XG4gIGVsc2UgaWYgKGNoID09PSBcIihcIiAmJiBzdHJlYW0uZWF0KFwiOlwiKSkge1xuICAgIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCB7IHR5cGU6IFwiY29tbWVudFwifSk7XG4gICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuQ29tbWVudCk7XG4gIH1cbiAgLy8gcXVvdGVkIHN0cmluZ1xuICBlbHNlIGlmICghaXNFUU5hbWUgJiYgKGNoID09PSAnXCInIHx8IGNoID09PSBcIidcIikpXG4gICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuU3RyaW5nKGNoKSk7XG4gIC8vIHZhcmlhYmxlXG4gIGVsc2UgaWYoY2ggPT09IFwiJFwiKSB7XG4gICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuVmFyaWFibGUpO1xuICB9XG4gIC8vIGFzc2lnbm1lbnRcbiAgZWxzZSBpZihjaCA9PT1cIjpcIiAmJiBzdHJlYW0uZWF0KFwiPVwiKSkge1xuICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgfVxuICAvLyBvcGVuIHBhcmVuXG4gIGVsc2UgaWYoY2ggPT09IFwiKFwiKSB7XG4gICAgcHVzaFN0YXRlU3RhY2soc3RhdGUsIHsgdHlwZTogXCJwYXJlblwifSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gY2xvc2UgcGFyZW5cbiAgZWxzZSBpZihjaCA9PT0gXCIpXCIpIHtcbiAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBvcGVuIHBhcmVuXG4gIGVsc2UgaWYoY2ggPT09IFwiW1wiKSB7XG4gICAgcHVzaFN0YXRlU3RhY2soc3RhdGUsIHsgdHlwZTogXCJicmFja2V0XCJ9KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBjbG9zZSBwYXJlblxuICBlbHNlIGlmKGNoID09PSBcIl1cIikge1xuICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBrbm93biA9IGtleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKGNoKSAmJiBrZXl3b3Jkc1tjaF07XG5cbiAgICAvLyBpZiB0aGVyZSdzIGEgRVFOYW1lIGFoZWFkLCBjb25zdW1lIHRoZSByZXN0IG9mIHRoZSBzdHJpbmcgcG9ydGlvbiwgaXQncyBsaWtlbHkgYSBmdW5jdGlvblxuICAgIGlmKGlzRVFOYW1lICYmIGNoID09PSAnXFxcIicpIHdoaWxlKHN0cmVhbS5uZXh0KCkgIT09ICdcIicpe31cbiAgICBpZihpc0VRTmFtZSAmJiBjaCA9PT0gJ1xcJycpIHdoaWxlKHN0cmVhbS5uZXh0KCkgIT09ICdcXCcnKXt9XG5cbiAgICAvLyBnb2JibGUgdXAgYSB3b3JkIGlmIHRoZSBjaGFyYWN0ZXIgaXMgbm90IGtub3duXG4gICAgaWYoIWtub3duKSBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfLV0vKTtcblxuICAgIC8vIGdvYmJsZSBhIGNvbG9uIGluIHRoZSBjYXNlIHRoYXQgaXMgYSBsaWIgZnVuYyB0eXBlIGNhbGwgZm46ZG9jXG4gICAgdmFyIGZvdW5kQ29sb24gPSBzdHJlYW0uZWF0KFwiOlwiKTtcblxuICAgIC8vIGlmIHRoZXJlJ3Mgbm90IGEgc2Vjb25kIGNvbG9uLCBnb2JibGUgYW5vdGhlciB3b3JkLiBPdGhlcndpc2UsIGl0J3MgcHJvYmFibHkgYW4gYXhpcyBzcGVjaWZpZXJcbiAgICAvLyB3aGljaCBzaG91bGQgZ2V0IG1hdGNoZWQgYXMgYSBrZXl3b3JkXG4gICAgaWYoIXN0cmVhbS5lYXQoXCI6XCIpICYmIGZvdW5kQ29sb24pIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF8tXS8pO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgbmV4dCBub24gd2hpdGVzcGFjZSBjaGFyYWN0ZXIgaXMgYW4gb3BlbiBwYXJlbiwgdGhpcyBpcyBwcm9iYWJseSBhIGZ1bmN0aW9uIChpZiBub3QgYSBrZXl3b3JkIG9mIG90aGVyIHNvcnQpXG4gICAgaWYoc3RyZWFtLm1hdGNoKC9eWyBcXHRdKlxcKC8sIGZhbHNlKSkge1xuICAgICAgbWlnaHRCZUZ1bmN0aW9uID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gaXMgdGhlIHdvcmQgYSBrZXl3b3JkP1xuICAgIHZhciB3b3JkID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICBrbm93biA9IGtleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKHdvcmQpICYmIGtleXdvcmRzW3dvcmRdO1xuXG4gICAgLy8gaWYgd2UgdGhpbmsgaXQncyBhIGZ1bmN0aW9uIGNhbGwgYnV0IG5vdCB5ZXQga25vd24sXG4gICAgLy8gc2V0IHN0eWxlIHRvIHZhcmlhYmxlIGZvciBub3cgZm9yIGxhY2sgb2Ygc29tZXRoaW5nIGJldHRlclxuICAgIGlmKG1pZ2h0QmVGdW5jdGlvbiAmJiAha25vd24pIGtub3duID0ge3R5cGU6IFwiZnVuY3Rpb25fY2FsbFwiLCBzdHlsZTogXCJkZWZcIn07XG5cbiAgICAvLyBpZiB0aGUgcHJldmlvdXMgd29yZCB3YXMgZWxlbWVudCwgYXR0cmlidXRlLCBheGlzIHNwZWNpZmllciwgdGhpcyB3b3JkIHNob3VsZCBiZSB0aGUgbmFtZSBvZiB0aGF0XG4gICAgaWYoaXNJblhtbENvbnN0cnVjdG9yKHN0YXRlKSkge1xuICAgICAgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICAgIH1cbiAgICAvLyBhcyBwcmV2aW91c2x5IGNoZWNrZWQsIGlmIHRoZSB3b3JkIGlzIGVsZW1lbnQsYXR0cmlidXRlLCBheGlzIHNwZWNpZmllciwgY2FsbCBpdCBhbiBcInhtbGNvbnN0cnVjdG9yXCIgYW5kXG4gICAgLy8gcHVzaCB0aGUgc3RhY2sgc28gd2Uga25vdyB0byBsb29rIGZvciBpdCBvbiB0aGUgbmV4dCB3b3JkXG4gICAgaWYod29yZCA9PSBcImVsZW1lbnRcIiB8fCB3b3JkID09IFwiYXR0cmlidXRlXCIgfHwga25vd24udHlwZSA9PSBcImF4aXNfc3BlY2lmaWVyXCIpIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCB7dHlwZTogXCJ4bWxjb25zdHJ1Y3RvclwifSk7XG5cbiAgICAvLyBpZiB0aGUgd29yZCBpcyBrbm93biwgcmV0dXJuIHRoZSBkZXRhaWxzIG9mIHRoYXQgZWxzZSBqdXN0IGNhbGwgdGhpcyBhIGdlbmVyaWMgJ3dvcmQnXG4gICAgcmV0dXJuIGtub3duID8ga25vd24uc3R5bGUgOiBcInZhcmlhYmxlXCI7XG4gIH1cbn1cblxuLy8gaGFuZGxlIGNvbW1lbnRzLCBpbmNsdWRpbmcgbmVzdGVkXG5mdW5jdGlvbiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbWF5YmVFbmQgPSBmYWxzZSwgbWF5YmVOZXN0ZWQgPSBmYWxzZSwgbmVzdGVkQ291bnQgPSAwLCBjaDtcbiAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgIGlmIChjaCA9PSBcIilcIiAmJiBtYXliZUVuZCkge1xuICAgICAgaWYobmVzdGVkQ291bnQgPiAwKVxuICAgICAgICBuZXN0ZWRDb3VudC0tO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZihjaCA9PSBcIjpcIiAmJiBtYXliZU5lc3RlZCkge1xuICAgICAgbmVzdGVkQ291bnQrKztcbiAgICB9XG4gICAgbWF5YmVFbmQgPSAoY2ggPT0gXCI6XCIpO1xuICAgIG1heWJlTmVzdGVkID0gKGNoID09IFwiKFwiKTtcbiAgfVxuXG4gIHJldHVybiBcImNvbW1lbnRcIjtcbn1cblxuLy8gdG9rZW5pemVyIGZvciBzdHJpbmcgbGl0ZXJhbHNcbi8vIG9wdGlvbmFsbHkgcGFzcyBhIHRva2VuaXplciBmdW5jdGlvbiB0byBzZXQgc3RhdGUudG9rZW5pemUgYmFjayB0byB3aGVuIGZpbmlzaGVkXG5mdW5jdGlvbiB0b2tlblN0cmluZyhxdW90ZSwgZikge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaDtcblxuICAgIGlmKGlzSW5TdHJpbmcoc3RhdGUpICYmIHN0cmVhbS5jdXJyZW50KCkgPT0gcXVvdGUpIHtcbiAgICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgICAgaWYoZikgc3RhdGUudG9rZW5pemUgPSBmO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfVxuXG4gICAgcHVzaFN0YXRlU3RhY2soc3RhdGUsIHsgdHlwZTogXCJzdHJpbmdcIiwgbmFtZTogcXVvdGUsIHRva2VuaXplOiB0b2tlblN0cmluZyhxdW90ZSwgZikgfSk7XG5cbiAgICAvLyBpZiB3ZSdyZSBpbiBhIHN0cmluZyBhbmQgaW4gYW4gWE1MIGJsb2NrLCBhbGxvdyBhbiBlbWJlZGRlZCBjb2RlIGJsb2NrXG4gICAgaWYoc3RyZWFtLm1hdGNoKFwie1wiLCBmYWxzZSkgJiYgaXNJblhtbEF0dHJpYnV0ZUJsb2NrKHN0YXRlKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9XG5cblxuICAgIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICAgIGlmIChjaCA9PSAgcXVvdGUpIHtcbiAgICAgICAgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgICAgIGlmKGYpIHN0YXRlLnRva2VuaXplID0gZjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gaWYgd2UncmUgaW4gYSBzdHJpbmcgYW5kIGluIGFuIFhNTCBibG9jaywgYWxsb3cgYW4gZW1iZWRkZWQgY29kZSBibG9jayBpbiBhbiBhdHRyaWJ1dGVcbiAgICAgICAgaWYoc3RyZWFtLm1hdGNoKFwie1wiLCBmYWxzZSkgJiYgaXNJblhtbEF0dHJpYnV0ZUJsb2NrKHN0YXRlKSkge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgfTtcbn1cblxuLy8gdG9rZW5pemVyIGZvciB2YXJpYWJsZXNcbmZ1bmN0aW9uIHRva2VuVmFyaWFibGUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgaXNWYXJpYWJsZUNoYXIgPSAvW1xcd1xcJF8tXS87XG5cbiAgLy8gYSB2YXJpYWJsZSBtYXkgc3RhcnQgd2l0aCBhIHF1b3RlZCBFUU5hbWUgc28gaWYgdGhlIG5leHQgY2hhcmFjdGVyIGlzIHF1b3RlLCBjb25zdW1lIHRvIHRoZSBuZXh0IHF1b3RlXG4gIGlmKHN0cmVhbS5lYXQoXCJcXFwiXCIpKSB7XG4gICAgd2hpbGUoc3RyZWFtLm5leHQoKSAhPT0gJ1xcXCInKXt9O1xuICAgIHN0cmVhbS5lYXQoXCI6XCIpO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5lYXRXaGlsZShpc1ZhcmlhYmxlQ2hhcik7XG4gICAgaWYoIXN0cmVhbS5tYXRjaChcIjo9XCIsIGZhbHNlKSkgc3RyZWFtLmVhdChcIjpcIik7XG4gIH1cbiAgc3RyZWFtLmVhdFdoaWxlKGlzVmFyaWFibGVDaGFyKTtcbiAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gIHJldHVybiBcInZhcmlhYmxlXCI7XG59XG5cbi8vIHRva2VuaXplciBmb3IgWE1MIHRhZ3NcbmZ1bmN0aW9uIHRva2VuVGFnKG5hbWUsIGlzY2xvc2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBzdHJlYW0uZWF0U3BhY2UoKTtcbiAgICBpZihpc2Nsb3NlICYmIHN0cmVhbS5lYXQoXCI+XCIpKSB7XG4gICAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgfVxuICAgIC8vIHNlbGYgY2xvc2luZyB0YWcgd2l0aG91dCBhdHRyaWJ1dGVzP1xuICAgIGlmKCFzdHJlYW0uZWF0KFwiL1wiKSlcbiAgICAgIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCB7IHR5cGU6IFwidGFnXCIsIG5hbWU6IG5hbWUsIHRva2VuaXplOiB0b2tlbkJhc2V9KTtcbiAgICBpZighc3RyZWFtLmVhdChcIj5cIikpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5BdHRyaWJ1dGU7XG4gICAgICByZXR1cm4gXCJ0YWdcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICB9XG4gICAgcmV0dXJuIFwidGFnXCI7XG4gIH07XG59XG5cbi8vIHRva2VuaXplciBmb3IgWE1MIGF0dHJpYnV0ZXNcbmZ1bmN0aW9uIHRva2VuQXR0cmlidXRlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcblxuICBpZihjaCA9PSBcIi9cIiAmJiBzdHJlYW0uZWF0KFwiPlwiKSkge1xuICAgIGlmKGlzSW5YbWxBdHRyaWJ1dGVCbG9jayhzdGF0ZSkpIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgIGlmKGlzSW5YbWxCbG9jayhzdGF0ZSkpIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgIHJldHVybiBcInRhZ1wiO1xuICB9XG4gIGlmKGNoID09IFwiPlwiKSB7XG4gICAgaWYoaXNJblhtbEF0dHJpYnV0ZUJsb2NrKHN0YXRlKSkgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgcmV0dXJuIFwidGFnXCI7XG4gIH1cbiAgaWYoY2ggPT0gXCI9XCIpXG4gICAgcmV0dXJuIG51bGw7XG4gIC8vIHF1b3RlZCBzdHJpbmdcbiAgaWYgKGNoID09ICdcIicgfHwgY2ggPT0gXCInXCIpXG4gICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuU3RyaW5nKGNoLCB0b2tlbkF0dHJpYnV0ZSkpO1xuXG4gIGlmKCFpc0luWG1sQXR0cmlidXRlQmxvY2soc3RhdGUpKVxuICAgIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCB7IHR5cGU6IFwiYXR0cmlidXRlXCIsIHRva2VuaXplOiB0b2tlbkF0dHJpYnV0ZX0pO1xuXG4gIHN0cmVhbS5lYXQoL1thLXpBLVpfOl0vKTtcbiAgc3RyZWFtLmVhdFdoaWxlKC9bLWEtekEtWjAtOV86Ll0vKTtcbiAgc3RyZWFtLmVhdFNwYWNlKCk7XG5cbiAgLy8gdGhlIGNhc2Ugd2hlcmUgdGhlIGF0dHJpYnV0ZSBoYXMgbm90IHZhbHVlIGFuZCB0aGUgdGFnIHdhcyBjbG9zZWRcbiAgaWYoc3RyZWFtLm1hdGNoKFwiPlwiLCBmYWxzZSkgfHwgc3RyZWFtLm1hdGNoKFwiL1wiLCBmYWxzZSkpIHtcbiAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgfVxuXG4gIHJldHVybiBcImF0dHJpYnV0ZVwiO1xufVxuXG4vLyBoYW5kbGUgY29tbWVudHMsIGluY2x1ZGluZyBuZXN0ZWRcbmZ1bmN0aW9uIHRva2VuWE1MQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBjaDtcbiAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgIGlmIChjaCA9PSBcIi1cIiAmJiBzdHJlYW0ubWF0Y2goXCItPlwiLCB0cnVlKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgfVxuICB9XG59XG5cblxuLy8gaGFuZGxlIENEQVRBXG5mdW5jdGlvbiB0b2tlbkNEQVRBKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGNoO1xuICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgaWYgKGNoID09IFwiXVwiICYmIHN0cmVhbS5tYXRjaChcIl1cIiwgdHJ1ZSkpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgIH1cbiAgfVxufVxuXG4vLyBoYW5kbGUgcHJlcHJvY2Vzc2luZyBpbnN0cnVjdGlvbnNcbmZ1bmN0aW9uIHRva2VuUHJlUHJvY2Vzc2luZyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBjaDtcbiAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgIGlmIChjaCA9PSBcIj9cIiAmJiBzdHJlYW0ubWF0Y2goXCI+XCIsIHRydWUpKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIHJldHVybiBcInByb2Nlc3NpbmdJbnN0cnVjdGlvblwiO1xuICAgIH1cbiAgfVxufVxuXG5cbi8vIGZ1bmN0aW9ucyB0byB0ZXN0IHRoZSBjdXJyZW50IGNvbnRleHQgb2YgdGhlIHN0YXRlXG5mdW5jdGlvbiBpc0luWG1sQmxvY2soc3RhdGUpIHsgcmV0dXJuIGlzSW4oc3RhdGUsIFwidGFnXCIpOyB9XG5mdW5jdGlvbiBpc0luWG1sQXR0cmlidXRlQmxvY2soc3RhdGUpIHsgcmV0dXJuIGlzSW4oc3RhdGUsIFwiYXR0cmlidXRlXCIpOyB9XG5mdW5jdGlvbiBpc0luWG1sQ29uc3RydWN0b3Ioc3RhdGUpIHsgcmV0dXJuIGlzSW4oc3RhdGUsIFwieG1sY29uc3RydWN0b3JcIik7IH1cbmZ1bmN0aW9uIGlzSW5TdHJpbmcoc3RhdGUpIHsgcmV0dXJuIGlzSW4oc3RhdGUsIFwic3RyaW5nXCIpOyB9XG5cbmZ1bmN0aW9uIGlzRVFOYW1lQWhlYWQoc3RyZWFtKSB7XG4gIC8vIGFzc3VtZSB3ZSd2ZSBhbHJlYWR5IGVhdGVuIGEgcXVvdGUgKFwiKVxuICBpZihzdHJlYW0uY3VycmVudCgpID09PSAnXCInKVxuICAgIHJldHVybiBzdHJlYW0ubWF0Y2goL15bXlxcXCJdK1xcXCJcXDovLCBmYWxzZSk7XG4gIGVsc2UgaWYoc3RyZWFtLmN1cnJlbnQoKSA9PT0gJ1xcJycpXG4gICAgcmV0dXJuIHN0cmVhbS5tYXRjaCgvXlteXFxcIl0rXFwnXFw6LywgZmFsc2UpO1xuICBlbHNlXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0luKHN0YXRlLCB0eXBlKSB7XG4gIHJldHVybiAoc3RhdGUuc3RhY2subGVuZ3RoICYmIHN0YXRlLnN0YWNrW3N0YXRlLnN0YWNrLmxlbmd0aCAtIDFdLnR5cGUgPT0gdHlwZSk7XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCBuZXdTdGF0ZSkge1xuICBzdGF0ZS5zdGFjay5wdXNoKG5ld1N0YXRlKTtcbn1cblxuZnVuY3Rpb24gcG9wU3RhdGVTdGFjayhzdGF0ZSkge1xuICBzdGF0ZS5zdGFjay5wb3AoKTtcbiAgdmFyIHJlaW5zdGF0ZVRva2VuaXplID0gc3RhdGUuc3RhY2subGVuZ3RoICYmIHN0YXRlLnN0YWNrW3N0YXRlLnN0YWNrLmxlbmd0aC0xXS50b2tlbml6ZTtcbiAgc3RhdGUudG9rZW5pemUgPSByZWluc3RhdGVUb2tlbml6ZSB8fCB0b2tlbkJhc2U7XG59XG5cbi8vIHRoZSBpbnRlcmZhY2UgZm9yIHRoZSBtb2RlIEFQSVxuZXhwb3J0IGNvbnN0IHhRdWVyeSA9IHtcbiAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuaXplOiB0b2tlbkJhc2UsXG4gICAgICBjYzogW10sXG4gICAgICBzdGFjazogW11cbiAgICB9O1xuICB9LFxuXG4gIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH0sXG5cbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgY29tbWVudFRva2Vuczoge2Jsb2NrOiB7b3BlbjogXCIoOlwiLCBjbG9zZTogXCI6KVwifX1cbiAgfVxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/legacy-modes/mode/xquery.js\n");

/***/ })

}]);