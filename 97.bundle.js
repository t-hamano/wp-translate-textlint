(window.webpackJsonp=window.webpackJsonp||[]).push([[97],{435:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "turtle", function() { return turtle; });\nvar curPunc;\n\nfunction wordRegexp(words) {\n  return new RegExp("^(?:" + words.join("|") + ")$", "i");\n}\nvar ops = wordRegexp([]);\nvar keywords = wordRegexp(["@prefix", "@base", "a"]);\nvar operatorChars = /[*+\\-<>=&|]/;\n\nfunction tokenBase(stream, state) {\n  var ch = stream.next();\n  curPunc = null;\n  if (ch == "<" && !stream.match(/^[\\s\\u00a0=]/, false)) {\n    stream.match(/^[^\\s\\u00a0>]*>?/);\n    return "atom";\n  }\n  else if (ch == "\\"" || ch == "\'") {\n    state.tokenize = tokenLiteral(ch);\n    return state.tokenize(stream, state);\n  }\n  else if (/[{}\\(\\),\\.;\\[\\]]/.test(ch)) {\n    curPunc = ch;\n    return null;\n  }\n  else if (ch == "#") {\n    stream.skipToEnd();\n    return "comment";\n  }\n  else if (operatorChars.test(ch)) {\n    stream.eatWhile(operatorChars);\n    return null;\n  }\n  else if (ch == ":") {\n    return "operator";\n  } else {\n    stream.eatWhile(/[_\\w\\d]/);\n    if(stream.peek() == ":") {\n      return "variableName.special";\n    } else {\n      var word = stream.current();\n\n      if(keywords.test(word)) {\n        return "meta";\n      }\n\n      if(ch >= "A" && ch <= "Z") {\n        return "comment";\n      } else {\n        return "keyword";\n      }\n    }\n    var word = stream.current();\n    if (ops.test(word))\n      return null;\n    else if (keywords.test(word))\n      return "meta";\n    else\n      return "variable";\n  }\n}\n\nfunction tokenLiteral(quote) {\n  return function(stream, state) {\n    var escaped = false, ch;\n    while ((ch = stream.next()) != null) {\n      if (ch == quote && !escaped) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && ch == "\\\\";\n    }\n    return "string";\n  };\n}\n\nfunction pushContext(state, type, col) {\n  state.context = {prev: state.context, indent: state.indent, col: col, type: type};\n}\nfunction popContext(state) {\n  state.indent = state.context.indent;\n  state.context = state.context.prev;\n}\n\nconst turtle = {\n  startState: function() {\n    return {tokenize: tokenBase,\n            context: null,\n            indent: 0,\n            col: 0};\n  },\n\n  token: function(stream, state) {\n    if (stream.sol()) {\n      if (state.context && state.context.align == null) state.context.align = false;\n      state.indent = stream.indentation();\n    }\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n\n    if (style != "comment" && state.context && state.context.align == null && state.context.type != "pattern") {\n      state.context.align = true;\n    }\n\n    if (curPunc == "(") pushContext(state, ")", stream.column());\n    else if (curPunc == "[") pushContext(state, "]", stream.column());\n    else if (curPunc == "{") pushContext(state, "}", stream.column());\n    else if (/[\\]\\}\\)]/.test(curPunc)) {\n      while (state.context && state.context.type == "pattern") popContext(state);\n      if (state.context && curPunc == state.context.type) popContext(state);\n    }\n    else if (curPunc == "." && state.context && state.context.type == "pattern") popContext(state);\n    else if (/atom|string|variable/.test(style) && state.context) {\n      if (/[\\}\\]]/.test(state.context.type))\n        pushContext(state, "pattern", stream.column());\n      else if (state.context.type == "pattern" && !state.context.align) {\n        state.context.align = true;\n        state.context.col = stream.column();\n      }\n    }\n\n    return style;\n  },\n\n  indent: function(state, textAfter, cx) {\n    var firstChar = textAfter && textAfter.charAt(0);\n    var context = state.context;\n    if (/[\\]\\}]/.test(firstChar))\n      while (context && context.type == "pattern") context = context.prev;\n\n    var closing = context && firstChar == context.type;\n    if (!context)\n      return 0;\n    else if (context.type == "pattern")\n      return context.col;\n    else if (context.align)\n      return context.col + (closing ? 0 : 1);\n    else\n      return context.indent + (closing ? 0 : cx.unit);\n  },\n\n  languageData: {\n    commentTokens: {line: "#"}\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvdHVydGxlLmpzPzMxZTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsd0JBQXdCO0FBQ2xELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSIsImZpbGUiOiI0MzUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY3VyUHVuYztcblxuZnVuY3Rpb24gd29yZFJlZ2V4cCh3b3Jkcykge1xuICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIHdvcmRzLmpvaW4oXCJ8XCIpICsgXCIpJFwiLCBcImlcIik7XG59XG52YXIgb3BzID0gd29yZFJlZ2V4cChbXSk7XG52YXIga2V5d29yZHMgPSB3b3JkUmVnZXhwKFtcIkBwcmVmaXhcIiwgXCJAYmFzZVwiLCBcImFcIl0pO1xudmFyIG9wZXJhdG9yQ2hhcnMgPSAvWyorXFwtPD49JnxdLztcblxuZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgY3VyUHVuYyA9IG51bGw7XG4gIGlmIChjaCA9PSBcIjxcIiAmJiAhc3RyZWFtLm1hdGNoKC9eW1xcc1xcdTAwYTA9XS8sIGZhbHNlKSkge1xuICAgIHN0cmVhbS5tYXRjaCgvXlteXFxzXFx1MDBhMD5dKj4/Lyk7XG4gICAgcmV0dXJuIFwiYXRvbVwiO1xuICB9XG4gIGVsc2UgaWYgKGNoID09IFwiXFxcIlwiIHx8IGNoID09IFwiJ1wiKSB7XG4gICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkxpdGVyYWwoY2gpO1xuICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxuICBlbHNlIGlmICgvW3t9XFwoXFwpLFxcLjtcXFtcXF1dLy50ZXN0KGNoKSkge1xuICAgIGN1clB1bmMgPSBjaDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBlbHNlIGlmIChjaCA9PSBcIiNcIikge1xuICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH1cbiAgZWxzZSBpZiAob3BlcmF0b3JDaGFycy50ZXN0KGNoKSkge1xuICAgIHN0cmVhbS5lYXRXaGlsZShvcGVyYXRvckNoYXJzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBlbHNlIGlmIChjaCA9PSBcIjpcIikge1xuICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bX1xcd1xcZF0vKTtcbiAgICBpZihzdHJlYW0ucGVlaygpID09IFwiOlwiKSB7XG4gICAgICByZXR1cm4gXCJ2YXJpYWJsZU5hbWUuc3BlY2lhbFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCk7XG5cbiAgICAgIGlmKGtleXdvcmRzLnRlc3Qod29yZCkpIHtcbiAgICAgICAgcmV0dXJuIFwibWV0YVwiO1xuICAgICAgfVxuXG4gICAgICBpZihjaCA+PSBcIkFcIiAmJiBjaCA8PSBcIlpcIikge1xuICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB3b3JkID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICBpZiAob3BzLnRlc3Qod29yZCkpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBlbHNlIGlmIChrZXl3b3Jkcy50ZXN0KHdvcmQpKVxuICAgICAgcmV0dXJuIFwibWV0YVwiO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gIH1cbn1cblxuZnVuY3Rpb24gdG9rZW5MaXRlcmFsKHF1b3RlKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgY2g7XG4gICAgd2hpbGUgKChjaCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgIGlmIChjaCA9PSBxdW90ZSAmJiAhZXNjYXBlZCkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgY2ggPT0gXCJcXFxcXCI7XG4gICAgfVxuICAgIHJldHVybiBcInN0cmluZ1wiO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwdXNoQ29udGV4dChzdGF0ZSwgdHlwZSwgY29sKSB7XG4gIHN0YXRlLmNvbnRleHQgPSB7cHJldjogc3RhdGUuY29udGV4dCwgaW5kZW50OiBzdGF0ZS5pbmRlbnQsIGNvbDogY29sLCB0eXBlOiB0eXBlfTtcbn1cbmZ1bmN0aW9uIHBvcENvbnRleHQoc3RhdGUpIHtcbiAgc3RhdGUuaW5kZW50ID0gc3RhdGUuY29udGV4dC5pbmRlbnQ7XG4gIHN0YXRlLmNvbnRleHQgPSBzdGF0ZS5jb250ZXh0LnByZXY7XG59XG5cbmV4cG9ydCBjb25zdCB0dXJ0bGUgPSB7XG4gIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7dG9rZW5pemU6IHRva2VuQmFzZSxcbiAgICAgICAgICAgIGNvbnRleHQ6IG51bGwsXG4gICAgICAgICAgICBpbmRlbnQ6IDAsXG4gICAgICAgICAgICBjb2w6IDB9O1xuICB9LFxuXG4gIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgaWYgKHN0YXRlLmNvbnRleHQgJiYgc3RhdGUuY29udGV4dC5hbGlnbiA9PSBudWxsKSBzdGF0ZS5jb250ZXh0LmFsaWduID0gZmFsc2U7XG4gICAgICBzdGF0ZS5pbmRlbnQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmIChzdHlsZSAhPSBcImNvbW1lbnRcIiAmJiBzdGF0ZS5jb250ZXh0ICYmIHN0YXRlLmNvbnRleHQuYWxpZ24gPT0gbnVsbCAmJiBzdGF0ZS5jb250ZXh0LnR5cGUgIT0gXCJwYXR0ZXJuXCIpIHtcbiAgICAgIHN0YXRlLmNvbnRleHQuYWxpZ24gPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChjdXJQdW5jID09IFwiKFwiKSBwdXNoQ29udGV4dChzdGF0ZSwgXCIpXCIsIHN0cmVhbS5jb2x1bW4oKSk7XG4gICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIltcIikgcHVzaENvbnRleHQoc3RhdGUsIFwiXVwiLCBzdHJlYW0uY29sdW1uKCkpO1xuICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gXCJ7XCIpIHB1c2hDb250ZXh0KHN0YXRlLCBcIn1cIiwgc3RyZWFtLmNvbHVtbigpKTtcbiAgICBlbHNlIGlmICgvW1xcXVxcfVxcKV0vLnRlc3QoY3VyUHVuYykpIHtcbiAgICAgIHdoaWxlIChzdGF0ZS5jb250ZXh0ICYmIHN0YXRlLmNvbnRleHQudHlwZSA9PSBcInBhdHRlcm5cIikgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICBpZiAoc3RhdGUuY29udGV4dCAmJiBjdXJQdW5jID09IHN0YXRlLmNvbnRleHQudHlwZSkgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gXCIuXCIgJiYgc3RhdGUuY29udGV4dCAmJiBzdGF0ZS5jb250ZXh0LnR5cGUgPT0gXCJwYXR0ZXJuXCIpIHBvcENvbnRleHQoc3RhdGUpO1xuICAgIGVsc2UgaWYgKC9hdG9tfHN0cmluZ3x2YXJpYWJsZS8udGVzdChzdHlsZSkgJiYgc3RhdGUuY29udGV4dCkge1xuICAgICAgaWYgKC9bXFx9XFxdXS8udGVzdChzdGF0ZS5jb250ZXh0LnR5cGUpKVxuICAgICAgICBwdXNoQ29udGV4dChzdGF0ZSwgXCJwYXR0ZXJuXCIsIHN0cmVhbS5jb2x1bW4oKSk7XG4gICAgICBlbHNlIGlmIChzdGF0ZS5jb250ZXh0LnR5cGUgPT0gXCJwYXR0ZXJuXCIgJiYgIXN0YXRlLmNvbnRleHQuYWxpZ24pIHtcbiAgICAgICAgc3RhdGUuY29udGV4dC5hbGlnbiA9IHRydWU7XG4gICAgICAgIHN0YXRlLmNvbnRleHQuY29sID0gc3RyZWFtLmNvbHVtbigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcblxuICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIsIGN4KSB7XG4gICAgdmFyIGZpcnN0Q2hhciA9IHRleHRBZnRlciAmJiB0ZXh0QWZ0ZXIuY2hhckF0KDApO1xuICAgIHZhciBjb250ZXh0ID0gc3RhdGUuY29udGV4dDtcbiAgICBpZiAoL1tcXF1cXH1dLy50ZXN0KGZpcnN0Q2hhcikpXG4gICAgICB3aGlsZSAoY29udGV4dCAmJiBjb250ZXh0LnR5cGUgPT0gXCJwYXR0ZXJuXCIpIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XG5cbiAgICB2YXIgY2xvc2luZyA9IGNvbnRleHQgJiYgZmlyc3RDaGFyID09IGNvbnRleHQudHlwZTtcbiAgICBpZiAoIWNvbnRleHQpXG4gICAgICByZXR1cm4gMDtcbiAgICBlbHNlIGlmIChjb250ZXh0LnR5cGUgPT0gXCJwYXR0ZXJuXCIpXG4gICAgICByZXR1cm4gY29udGV4dC5jb2w7XG4gICAgZWxzZSBpZiAoY29udGV4dC5hbGlnbilcbiAgICAgIHJldHVybiBjb250ZXh0LmNvbCArIChjbG9zaW5nID8gMCA6IDEpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBjb250ZXh0LmluZGVudCArIChjbG9zaW5nID8gMCA6IGN4LnVuaXQpO1xuICB9LFxuXG4gIGxhbmd1YWdlRGF0YToge1xuICAgIGNvbW1lbnRUb2tlbnM6IHtsaW5lOiBcIiNcIn1cbiAgfVxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///435\n')}}]);