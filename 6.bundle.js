(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[6],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/haxe.js":
/*!************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/haxe.js ***!
  \************************************************************/
/*! exports provided: haxe, hxml */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"haxe\", function() { return haxe; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hxml\", function() { return hxml; });\n// Tokenizer\n\nfunction kw(type) {return {type: type, style: \"keyword\"};}\nvar A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\nvar operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"}, attribute = {type:\"attribute\", style: \"attribute\"};\nvar type = kw(\"typedef\");\nvar keywords = {\n  \"if\": A, \"while\": A, \"else\": B, \"do\": B, \"try\": B,\n  \"return\": C, \"break\": C, \"continue\": C, \"new\": C, \"throw\": C,\n  \"var\": kw(\"var\"), \"inline\":attribute, \"static\": attribute, \"using\":kw(\"import\"),\n  \"public\": attribute, \"private\": attribute, \"cast\": kw(\"cast\"), \"import\": kw(\"import\"), \"macro\": kw(\"macro\"),\n  \"function\": kw(\"function\"), \"catch\": kw(\"catch\"), \"untyped\": kw(\"untyped\"), \"callback\": kw(\"cb\"),\n  \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n  \"in\": operator, \"never\": kw(\"property_access\"), \"trace\":kw(\"trace\"),\n  \"class\": type, \"abstract\":type, \"enum\":type, \"interface\":type, \"typedef\":type, \"extends\":type, \"implements\":type, \"dynamic\":type,\n  \"true\": atom, \"false\": atom, \"null\": atom\n};\n\nvar isOperatorChar = /[+\\-*&%=<>!?|]/;\n\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\n\nfunction toUnescaped(stream, end) {\n  var escaped = false, next;\n  while ((next = stream.next()) != null) {\n    if (next == end && !escaped)\n      return true;\n    escaped = !escaped && next == \"\\\\\";\n  }\n}\n\n// Used as scratch variables to communicate multiple values without\n// consing up tons of objects.\nvar type, content;\nfunction ret(tp, style, cont) {\n  type = tp; content = cont;\n  return style;\n}\n\nfunction haxeTokenBase(stream, state) {\n  var ch = stream.next();\n  if (ch == '\"' || ch == \"'\") {\n    return chain(stream, state, haxeTokenString(ch));\n  } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n    return ret(ch);\n  } else if (ch == \"0\" && stream.eat(/x/i)) {\n    stream.eatWhile(/[\\da-f]/i);\n    return ret(\"number\", \"number\");\n  } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n    stream.match(/^\\d*(?:\\.\\d*(?!\\.))?(?:[eE][+\\-]?\\d+)?/);\n    return ret(\"number\", \"number\");\n  } else if (state.reAllowed && (ch == \"~\" && stream.eat(/\\//))) {\n    toUnescaped(stream, \"/\");\n    stream.eatWhile(/[gimsu]/);\n    return ret(\"regexp\", \"string.special\");\n  } else if (ch == \"/\") {\n    if (stream.eat(\"*\")) {\n      return chain(stream, state, haxeTokenComment);\n    } else if (stream.eat(\"/\")) {\n      stream.skipToEnd();\n      return ret(\"comment\", \"comment\");\n    } else {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", null, stream.current());\n    }\n  } else if (ch == \"#\") {\n    stream.skipToEnd();\n    return ret(\"conditional\", \"meta\");\n  } else if (ch == \"@\") {\n    stream.eat(/:/);\n    stream.eatWhile(/[\\w_]/);\n    return ret (\"metadata\", \"meta\");\n  } else if (isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return ret(\"operator\", null, stream.current());\n  } else {\n    var word;\n    if(/[A-Z]/.test(ch)) {\n      stream.eatWhile(/[\\w_<>]/);\n      word = stream.current();\n      return ret(\"type\", \"type\", word);\n    } else {\n      stream.eatWhile(/[\\w_]/);\n      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return (known && state.kwAllowed) ? ret(known.type, known.style, word) :\n        ret(\"variable\", \"variable\", word);\n    }\n  }\n}\n\nfunction haxeTokenString(quote) {\n  return function(stream, state) {\n    if (toUnescaped(stream, quote))\n      state.tokenize = haxeTokenBase;\n    return ret(\"string\", \"string\");\n  };\n}\n\nfunction haxeTokenComment(stream, state) {\n  var maybeEnd = false, ch;\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = haxeTokenBase;\n      break;\n    }\n    maybeEnd = (ch == \"*\");\n  }\n  return ret(\"comment\", \"comment\");\n}\n\n// Parser\n\nvar atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true};\n\nfunction HaxeLexical(indented, column, type, align, prev, info) {\n  this.indented = indented;\n  this.column = column;\n  this.type = type;\n  this.prev = prev;\n  this.info = info;\n  if (align != null) this.align = align;\n}\n\nfunction inScope(state, varname) {\n  for (var v = state.localVars; v; v = v.next)\n    if (v.name == varname) return true;\n}\n\nfunction parseHaxe(state, style, type, content, stream) {\n  var cc = state.cc;\n  // Communicate our context to the combinators.\n  // (Less wasteful than consing up a hundred closures on every call.)\n  cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;\n\n  if (!state.lexical.hasOwnProperty(\"align\"))\n    state.lexical.align = true;\n\n  while(true) {\n    var combinator = cc.length ? cc.pop() : statement;\n    if (combinator(type, content)) {\n      while(cc.length && cc[cc.length - 1].lex)\n        cc.pop()();\n      if (cx.marked) return cx.marked;\n      if (type == \"variable\" && inScope(state, content)) return \"variableName.local\";\n      if (type == \"variable\" && imported(state, content)) return \"variableName.special\";\n      return style;\n    }\n  }\n}\n\nfunction imported(state, typename) {\n  if (/[a-z]/.test(typename.charAt(0)))\n    return false;\n  var len = state.importedtypes.length;\n  for (var i = 0; i<len; i++)\n    if(state.importedtypes[i]==typename) return true;\n}\n\nfunction registerimport(importname) {\n  var state = cx.state;\n  for (var t = state.importedtypes; t; t = t.next)\n    if(t.name == importname) return;\n  state.importedtypes = { name: importname, next: state.importedtypes };\n}\n// Combinator utils\n\nvar cx = {state: null, column: null, marked: null, cc: null};\nfunction pass() {\n  for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n}\nfunction cont() {\n  pass.apply(null, arguments);\n  return true;\n}\nfunction inList(name, list) {\n  for (var v = list; v; v = v.next)\n    if (v.name == name) return true;\n  return false;\n}\nfunction register(varname) {\n  var state = cx.state;\n  if (state.context) {\n    cx.marked = \"def\";\n    if (inList(varname, state.localVars)) return;\n    state.localVars = {name: varname, next: state.localVars};\n  } else if (state.globalVars) {\n    if (inList(varname, state.globalVars)) return;\n    state.globalVars = {name: varname, next: state.globalVars};\n  }\n}\n\n// Combinators\n\nvar defaultVars = {name: \"this\", next: null};\nfunction pushcontext() {\n  if (!cx.state.context) cx.state.localVars = defaultVars;\n  cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n}\nfunction popcontext() {\n  cx.state.localVars = cx.state.context.vars;\n  cx.state.context = cx.state.context.prev;\n}\npopcontext.lex = true;\nfunction pushlex(type, info) {\n  var result = function() {\n    var state = cx.state;\n    state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\n  };\n  result.lex = true;\n  return result;\n}\nfunction poplex() {\n  var state = cx.state;\n  if (state.lexical.prev) {\n    if (state.lexical.type == \")\")\n      state.indented = state.lexical.indented;\n    state.lexical = state.lexical.prev;\n  }\n}\npoplex.lex = true;\n\nfunction expect(wanted) {\n  function f(type) {\n    if (type == wanted) return cont();\n    else if (wanted == \";\") return pass();\n    else return cont(f);\n  }\n  return f;\n}\n\nfunction statement(type) {\n  if (type == \"@\") return cont(metadef);\n  if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n  if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n  if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n  if (type == \"{\") return cont(pushlex(\"}\"), pushcontext, block, poplex, popcontext);\n  if (type == \";\") return cont();\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"),\n                                 poplex, statement, poplex);\n  if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n  if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n                                    block, poplex, poplex);\n  if (type == \"case\") return cont(expression, expect(\":\"));\n  if (type == \"default\") return cont(expect(\":\"));\n  if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                   statement, poplex, popcontext);\n  if (type == \"import\") return cont(importdef, expect(\";\"));\n  if (type == \"typedef\") return cont(typedef);\n  return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n}\nfunction expression(type) {\n  if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n  if (type == \"type\" ) return cont(maybeoperator);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"keyword c\") return cont(maybeexpression);\n  if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n  if (type == \"operator\") return cont(expression);\n  if (type == \"[\") return cont(pushlex(\"]\"), commasep(maybeexpression, \"]\"), poplex, maybeoperator);\n  if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n  return cont();\n}\nfunction maybeexpression(type) {\n  if (type.match(/[;\\}\\)\\],]/)) return pass();\n  return pass(expression);\n}\n\nfunction maybeoperator(type, value) {\n  if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\n  if (type == \"operator\" || type == \":\") return cont(expression);\n  if (type == \";\") return;\n  if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n  if (type == \".\") return cont(property, maybeoperator);\n  if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n}\n\nfunction maybeattribute(type) {\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"var\") return cont(vardef1);\n}\n\nfunction metadef(type) {\n  if(type == \":\") return cont(metadef);\n  if(type == \"variable\") return cont(metadef);\n  if(type == \"(\") return cont(pushlex(\")\"), commasep(metaargs, \")\"), poplex, statement);\n}\nfunction metaargs(type) {\n  if(type == \"variable\") return cont();\n}\n\nfunction importdef (type, value) {\n  if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n  else if(type == \"variable\" || type == \"property\" || type == \".\" || value == \"*\") return cont(importdef);\n}\n\nfunction typedef (type, value)\n{\n  if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n  else if (type == \"type\" && /[A-Z]/.test(value.charAt(0))) { return cont(); }\n}\n\nfunction maybelabel(type) {\n  if (type == \":\") return cont(poplex, statement);\n  return pass(maybeoperator, expect(\";\"), poplex);\n}\nfunction property(type) {\n  if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n}\nfunction objprop(type) {\n  if (type == \"variable\") cx.marked = \"property\";\n  if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n}\nfunction commasep(what, end) {\n  function proceed(type) {\n    if (type == \",\") return cont(what, proceed);\n    if (type == end) return cont();\n    return cont(expect(end));\n  }\n  return function(type) {\n    if (type == end) return cont();\n    else return pass(what, proceed);\n  };\n}\nfunction block(type) {\n  if (type == \"}\") return cont();\n  return pass(statement, block);\n}\nfunction vardef1(type, value) {\n  if (type == \"variable\"){register(value); return cont(typeuse, vardef2);}\n  return cont();\n}\nfunction vardef2(type, value) {\n  if (value == \"=\") return cont(expression, vardef2);\n  if (type == \",\") return cont(vardef1);\n}\nfunction forspec1(type, value) {\n  if (type == \"variable\") {\n    register(value);\n    return cont(forin, expression)\n  } else {\n    return pass()\n  }\n}\nfunction forin(_type, value) {\n  if (value == \"in\") return cont();\n}\nfunction functiondef(type, value) {\n  //function names starting with upper-case letters are recognised as types, so cludging them together here.\n  if (type == \"variable\" || type == \"type\") {register(value); return cont(functiondef);}\n  if (value == \"new\") return cont(functiondef);\n  if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, typeuse, statement, popcontext);\n}\nfunction typeuse(type) {\n  if(type == \":\") return cont(typestring);\n}\nfunction typestring(type) {\n  if(type == \"type\") return cont();\n  if(type == \"variable\") return cont();\n  if(type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\"), poplex);\n}\nfunction typeprop(type) {\n  if(type == \"variable\") return cont(typeuse);\n}\nfunction funarg(type, value) {\n  if (type == \"variable\") {register(value); return cont(typeuse);}\n}\n\n// Interface\nconst haxe = {\n  startState: function(indentUnit) {\n    var defaulttypes = [\"Int\", \"Float\", \"String\", \"Void\", \"Std\", \"Bool\", \"Dynamic\", \"Array\"];\n    var state = {\n      tokenize: haxeTokenBase,\n      reAllowed: true,\n      kwAllowed: true,\n      cc: [],\n      lexical: new HaxeLexical(-indentUnit, 0, \"block\", false),\n      importedtypes: defaulttypes,\n      context: null,\n      indented: 0\n    };\n    return state;\n  },\n\n  token: function(stream, state) {\n    if (stream.sol()) {\n      if (!state.lexical.hasOwnProperty(\"align\"))\n        state.lexical.align = false;\n      state.indented = stream.indentation();\n    }\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    if (type == \"comment\") return style;\n    state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\n    state.kwAllowed = type != '.';\n    return parseHaxe(state, style, type, content, stream);\n  },\n\n  indent: function(state, textAfter, cx) {\n    if (state.tokenize != haxeTokenBase) return 0;\n    var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n    if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n    var type = lexical.type, closing = firstChar == type;\n    if (type == \"vardef\") return lexical.indented + 4;\n    else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n    else if (type == \"stat\" || type == \"form\") return lexical.indented + cx.unit;\n    else if (lexical.info == \"switch\" && !closing)\n      return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? cx.unit : 2 * cx.unit);\n    else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n    else return lexical.indented + (closing ? 0 : cx.unit);\n  },\n\n  languageData: {\n    indentOnInput: /^\\s*[{}]$/,\n    commentTokens: {line: \"//\", block: {open: \"/*\", close: \"*/\"}}\n  }\n};\n\nconst hxml = {\n  startState: function () {\n    return {\n      define: false,\n      inString: false\n    };\n  },\n  token: function (stream, state) {\n    var ch = stream.peek();\n    var sol = stream.sol();\n\n    ///* comments */\n    if (ch == \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n    if (sol && ch == \"-\") {\n      var style = \"variable-2\";\n\n      stream.eat(/-/);\n\n      if (stream.peek() == \"-\") {\n        stream.eat(/-/);\n        style = \"keyword a\";\n      }\n\n      if (stream.peek() == \"D\") {\n        stream.eat(/[D]/);\n        style = \"keyword c\";\n        state.define = true;\n      }\n\n      stream.eatWhile(/[A-Z]/i);\n      return style;\n    }\n\n    var ch = stream.peek();\n\n    if (state.inString == false && ch == \"'\") {\n      state.inString = true;\n      stream.next();\n    }\n\n    if (state.inString == true) {\n      if (stream.skipTo(\"'\")) {\n\n      } else {\n        stream.skipToEnd();\n      }\n\n      if (stream.peek() == \"'\") {\n        stream.next();\n        state.inString = false;\n      }\n\n      return \"string\";\n    }\n\n    stream.next();\n    return null;\n  },\n  languageData: {\n    commentTokens: {line: \"#\"}\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvaGF4ZS5qcz9hNTQzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0EsdUNBQXVDLDRCQUE0QixlQUFlO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGtCQUFrQixNQUFNO0FBQzNCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsR0FBRztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsR0FBRztBQUN0QztBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBLFVBQVU7QUFDVjtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixHQUFHO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSx1QkFBdUI7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCLHdCQUF3QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsRUFBRTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyREFBMkQsdUJBQXVCLGVBQWU7QUFDakc7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkRBQTJELHVCQUF1QixlQUFlO0FBQ2pHLDZEQUE2RCxlQUFlO0FBQzVFOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCLHlCQUF5QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQzs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixJQUFJO0FBQzVGO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvaGF4ZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRva2VuaXplclxuXG5mdW5jdGlvbiBrdyh0eXBlKSB7cmV0dXJuIHt0eXBlOiB0eXBlLCBzdHlsZTogXCJrZXl3b3JkXCJ9O31cbnZhciBBID0ga3coXCJrZXl3b3JkIGFcIiksIEIgPSBrdyhcImtleXdvcmQgYlwiKSwgQyA9IGt3KFwia2V5d29yZCBjXCIpO1xudmFyIG9wZXJhdG9yID0ga3coXCJvcGVyYXRvclwiKSwgYXRvbSA9IHt0eXBlOiBcImF0b21cIiwgc3R5bGU6IFwiYXRvbVwifSwgYXR0cmlidXRlID0ge3R5cGU6XCJhdHRyaWJ1dGVcIiwgc3R5bGU6IFwiYXR0cmlidXRlXCJ9O1xudmFyIHR5cGUgPSBrdyhcInR5cGVkZWZcIik7XG52YXIga2V5d29yZHMgPSB7XG4gIFwiaWZcIjogQSwgXCJ3aGlsZVwiOiBBLCBcImVsc2VcIjogQiwgXCJkb1wiOiBCLCBcInRyeVwiOiBCLFxuICBcInJldHVyblwiOiBDLCBcImJyZWFrXCI6IEMsIFwiY29udGludWVcIjogQywgXCJuZXdcIjogQywgXCJ0aHJvd1wiOiBDLFxuICBcInZhclwiOiBrdyhcInZhclwiKSwgXCJpbmxpbmVcIjphdHRyaWJ1dGUsIFwic3RhdGljXCI6IGF0dHJpYnV0ZSwgXCJ1c2luZ1wiOmt3KFwiaW1wb3J0XCIpLFxuICBcInB1YmxpY1wiOiBhdHRyaWJ1dGUsIFwicHJpdmF0ZVwiOiBhdHRyaWJ1dGUsIFwiY2FzdFwiOiBrdyhcImNhc3RcIiksIFwiaW1wb3J0XCI6IGt3KFwiaW1wb3J0XCIpLCBcIm1hY3JvXCI6IGt3KFwibWFjcm9cIiksXG4gIFwiZnVuY3Rpb25cIjoga3coXCJmdW5jdGlvblwiKSwgXCJjYXRjaFwiOiBrdyhcImNhdGNoXCIpLCBcInVudHlwZWRcIjoga3coXCJ1bnR5cGVkXCIpLCBcImNhbGxiYWNrXCI6IGt3KFwiY2JcIiksXG4gIFwiZm9yXCI6IGt3KFwiZm9yXCIpLCBcInN3aXRjaFwiOiBrdyhcInN3aXRjaFwiKSwgXCJjYXNlXCI6IGt3KFwiY2FzZVwiKSwgXCJkZWZhdWx0XCI6IGt3KFwiZGVmYXVsdFwiKSxcbiAgXCJpblwiOiBvcGVyYXRvciwgXCJuZXZlclwiOiBrdyhcInByb3BlcnR5X2FjY2Vzc1wiKSwgXCJ0cmFjZVwiOmt3KFwidHJhY2VcIiksXG4gIFwiY2xhc3NcIjogdHlwZSwgXCJhYnN0cmFjdFwiOnR5cGUsIFwiZW51bVwiOnR5cGUsIFwiaW50ZXJmYWNlXCI6dHlwZSwgXCJ0eXBlZGVmXCI6dHlwZSwgXCJleHRlbmRzXCI6dHlwZSwgXCJpbXBsZW1lbnRzXCI6dHlwZSwgXCJkeW5hbWljXCI6dHlwZSxcbiAgXCJ0cnVlXCI6IGF0b20sIFwiZmFsc2VcIjogYXRvbSwgXCJudWxsXCI6IGF0b21cbn07XG5cbnZhciBpc09wZXJhdG9yQ2hhciA9IC9bK1xcLSomJT08PiE/fF0vO1xuXG5mdW5jdGlvbiBjaGFpbihzdHJlYW0sIHN0YXRlLCBmKSB7XG4gIHN0YXRlLnRva2VuaXplID0gZjtcbiAgcmV0dXJuIGYoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIHRvVW5lc2NhcGVkKHN0cmVhbSwgZW5kKSB7XG4gIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQ7XG4gIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICBpZiAobmV4dCA9PSBlbmQgJiYgIWVzY2FwZWQpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIjtcbiAgfVxufVxuXG4vLyBVc2VkIGFzIHNjcmF0Y2ggdmFyaWFibGVzIHRvIGNvbW11bmljYXRlIG11bHRpcGxlIHZhbHVlcyB3aXRob3V0XG4vLyBjb25zaW5nIHVwIHRvbnMgb2Ygb2JqZWN0cy5cbnZhciB0eXBlLCBjb250ZW50O1xuZnVuY3Rpb24gcmV0KHRwLCBzdHlsZSwgY29udCkge1xuICB0eXBlID0gdHA7IGNvbnRlbnQgPSBjb250O1xuICByZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGhheGVUb2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICBpZiAoY2ggPT0gJ1wiJyB8fCBjaCA9PSBcIidcIikge1xuICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCBoYXhlVG9rZW5TdHJpbmcoY2gpKTtcbiAgfSBlbHNlIGlmICgvW1xcW1xcXXt9XFwoXFwpLDtcXDpcXC5dLy50ZXN0KGNoKSkge1xuICAgIHJldHVybiByZXQoY2gpO1xuICB9IGVsc2UgaWYgKGNoID09IFwiMFwiICYmIHN0cmVhbS5lYXQoL3gvaSkpIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXGRhLWZdL2kpO1xuICAgIHJldHVybiByZXQoXCJudW1iZXJcIiwgXCJudW1iZXJcIik7XG4gIH0gZWxzZSBpZiAoL1xcZC8udGVzdChjaCkgfHwgY2ggPT0gXCItXCIgJiYgc3RyZWFtLmVhdCgvXFxkLykpIHtcbiAgICBzdHJlYW0ubWF0Y2goL15cXGQqKD86XFwuXFxkKig/IVxcLikpPyg/OltlRV1bK1xcLV0/XFxkKyk/Lyk7XG4gICAgcmV0dXJuIHJldChcIm51bWJlclwiLCBcIm51bWJlclwiKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5yZUFsbG93ZWQgJiYgKGNoID09IFwiflwiICYmIHN0cmVhbS5lYXQoL1xcLy8pKSkge1xuICAgIHRvVW5lc2NhcGVkKHN0cmVhbSwgXCIvXCIpO1xuICAgIHN0cmVhbS5lYXRXaGlsZSgvW2dpbXN1XS8pO1xuICAgIHJldHVybiByZXQoXCJyZWdleHBcIiwgXCJzdHJpbmcuc3BlY2lhbFwiKTtcbiAgfSBlbHNlIGlmIChjaCA9PSBcIi9cIikge1xuICAgIGlmIChzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIGhheGVUb2tlbkNvbW1lbnQpO1xuICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdChcIi9cIikpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiByZXQoXCJjb21tZW50XCIsIFwiY29tbWVudFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKGlzT3BlcmF0b3JDaGFyKTtcbiAgICAgIHJldHVybiByZXQoXCJvcGVyYXRvclwiLCBudWxsLCBzdHJlYW0uY3VycmVudCgpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY2ggPT0gXCIjXCIpIHtcbiAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgcmV0dXJuIHJldChcImNvbmRpdGlvbmFsXCIsIFwibWV0YVwiKTtcbiAgfSBlbHNlIGlmIChjaCA9PSBcIkBcIikge1xuICAgIHN0cmVhbS5lYXQoLzovKTtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdfXS8pO1xuICAgIHJldHVybiByZXQgKFwibWV0YWRhdGFcIiwgXCJtZXRhXCIpO1xuICB9IGVsc2UgaWYgKGlzT3BlcmF0b3JDaGFyLnRlc3QoY2gpKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKGlzT3BlcmF0b3JDaGFyKTtcbiAgICByZXR1cm4gcmV0KFwib3BlcmF0b3JcIiwgbnVsbCwgc3RyZWFtLmN1cnJlbnQoKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHdvcmQ7XG4gICAgaWYoL1tBLVpdLy50ZXN0KGNoKSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3Xzw+XS8pO1xuICAgICAgd29yZCA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICByZXR1cm4gcmV0KFwidHlwZVwiLCBcInR5cGVcIiwgd29yZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd19dLyk7XG4gICAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCksIGtub3duID0ga2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUod29yZCkgJiYga2V5d29yZHNbd29yZF07XG4gICAgICByZXR1cm4gKGtub3duICYmIHN0YXRlLmt3QWxsb3dlZCkgPyByZXQoa25vd24udHlwZSwga25vd24uc3R5bGUsIHdvcmQpIDpcbiAgICAgICAgcmV0KFwidmFyaWFibGVcIiwgXCJ2YXJpYWJsZVwiLCB3b3JkKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaGF4ZVRva2VuU3RyaW5nKHF1b3RlKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHRvVW5lc2NhcGVkKHN0cmVhbSwgcXVvdGUpKVxuICAgICAgc3RhdGUudG9rZW5pemUgPSBoYXhlVG9rZW5CYXNlO1xuICAgIHJldHVybiByZXQoXCJzdHJpbmdcIiwgXCJzdHJpbmdcIik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGhheGVUb2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbWF5YmVFbmQgPSBmYWxzZSwgY2g7XG4gIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICBpZiAoY2ggPT0gXCIvXCIgJiYgbWF5YmVFbmQpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gaGF4ZVRva2VuQmFzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBtYXliZUVuZCA9IChjaCA9PSBcIipcIik7XG4gIH1cbiAgcmV0dXJuIHJldChcImNvbW1lbnRcIiwgXCJjb21tZW50XCIpO1xufVxuXG4vLyBQYXJzZXJcblxudmFyIGF0b21pY1R5cGVzID0ge1wiYXRvbVwiOiB0cnVlLCBcIm51bWJlclwiOiB0cnVlLCBcInZhcmlhYmxlXCI6IHRydWUsIFwic3RyaW5nXCI6IHRydWUsIFwicmVnZXhwXCI6IHRydWV9O1xuXG5mdW5jdGlvbiBIYXhlTGV4aWNhbChpbmRlbnRlZCwgY29sdW1uLCB0eXBlLCBhbGlnbiwgcHJldiwgaW5mbykge1xuICB0aGlzLmluZGVudGVkID0gaW5kZW50ZWQ7XG4gIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnByZXYgPSBwcmV2O1xuICB0aGlzLmluZm8gPSBpbmZvO1xuICBpZiAoYWxpZ24gIT0gbnVsbCkgdGhpcy5hbGlnbiA9IGFsaWduO1xufVxuXG5mdW5jdGlvbiBpblNjb3BlKHN0YXRlLCB2YXJuYW1lKSB7XG4gIGZvciAodmFyIHYgPSBzdGF0ZS5sb2NhbFZhcnM7IHY7IHYgPSB2Lm5leHQpXG4gICAgaWYgKHYubmFtZSA9PSB2YXJuYW1lKSByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcGFyc2VIYXhlKHN0YXRlLCBzdHlsZSwgdHlwZSwgY29udGVudCwgc3RyZWFtKSB7XG4gIHZhciBjYyA9IHN0YXRlLmNjO1xuICAvLyBDb21tdW5pY2F0ZSBvdXIgY29udGV4dCB0byB0aGUgY29tYmluYXRvcnMuXG4gIC8vIChMZXNzIHdhc3RlZnVsIHRoYW4gY29uc2luZyB1cCBhIGh1bmRyZWQgY2xvc3VyZXMgb24gZXZlcnkgY2FsbC4pXG4gIGN4LnN0YXRlID0gc3RhdGU7IGN4LnN0cmVhbSA9IHN0cmVhbTsgY3gubWFya2VkID0gbnVsbCwgY3guY2MgPSBjYztcblxuICBpZiAoIXN0YXRlLmxleGljYWwuaGFzT3duUHJvcGVydHkoXCJhbGlnblwiKSlcbiAgICBzdGF0ZS5sZXhpY2FsLmFsaWduID0gdHJ1ZTtcblxuICB3aGlsZSh0cnVlKSB7XG4gICAgdmFyIGNvbWJpbmF0b3IgPSBjYy5sZW5ndGggPyBjYy5wb3AoKSA6IHN0YXRlbWVudDtcbiAgICBpZiAoY29tYmluYXRvcih0eXBlLCBjb250ZW50KSkge1xuICAgICAgd2hpbGUoY2MubGVuZ3RoICYmIGNjW2NjLmxlbmd0aCAtIDFdLmxleClcbiAgICAgICAgY2MucG9wKCkoKTtcbiAgICAgIGlmIChjeC5tYXJrZWQpIHJldHVybiBjeC5tYXJrZWQ7XG4gICAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIgJiYgaW5TY29wZShzdGF0ZSwgY29udGVudCkpIHJldHVybiBcInZhcmlhYmxlTmFtZS5sb2NhbFwiO1xuICAgICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiICYmIGltcG9ydGVkKHN0YXRlLCBjb250ZW50KSkgcmV0dXJuIFwidmFyaWFibGVOYW1lLnNwZWNpYWxcIjtcbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW1wb3J0ZWQoc3RhdGUsIHR5cGVuYW1lKSB7XG4gIGlmICgvW2Etel0vLnRlc3QodHlwZW5hbWUuY2hhckF0KDApKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHZhciBsZW4gPSBzdGF0ZS5pbXBvcnRlZHR5cGVzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGk8bGVuOyBpKyspXG4gICAgaWYoc3RhdGUuaW1wb3J0ZWR0eXBlc1tpXT09dHlwZW5hbWUpIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlcmltcG9ydChpbXBvcnRuYW1lKSB7XG4gIHZhciBzdGF0ZSA9IGN4LnN0YXRlO1xuICBmb3IgKHZhciB0ID0gc3RhdGUuaW1wb3J0ZWR0eXBlczsgdDsgdCA9IHQubmV4dClcbiAgICBpZih0Lm5hbWUgPT0gaW1wb3J0bmFtZSkgcmV0dXJuO1xuICBzdGF0ZS5pbXBvcnRlZHR5cGVzID0geyBuYW1lOiBpbXBvcnRuYW1lLCBuZXh0OiBzdGF0ZS5pbXBvcnRlZHR5cGVzIH07XG59XG4vLyBDb21iaW5hdG9yIHV0aWxzXG5cbnZhciBjeCA9IHtzdGF0ZTogbnVsbCwgY29sdW1uOiBudWxsLCBtYXJrZWQ6IG51bGwsIGNjOiBudWxsfTtcbmZ1bmN0aW9uIHBhc3MoKSB7XG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGN4LmNjLnB1c2goYXJndW1lbnRzW2ldKTtcbn1cbmZ1bmN0aW9uIGNvbnQoKSB7XG4gIHBhc3MuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBpbkxpc3QobmFtZSwgbGlzdCkge1xuICBmb3IgKHZhciB2ID0gbGlzdDsgdjsgdiA9IHYubmV4dClcbiAgICBpZiAodi5uYW1lID09IG5hbWUpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZWdpc3Rlcih2YXJuYW1lKSB7XG4gIHZhciBzdGF0ZSA9IGN4LnN0YXRlO1xuICBpZiAoc3RhdGUuY29udGV4dCkge1xuICAgIGN4Lm1hcmtlZCA9IFwiZGVmXCI7XG4gICAgaWYgKGluTGlzdCh2YXJuYW1lLCBzdGF0ZS5sb2NhbFZhcnMpKSByZXR1cm47XG4gICAgc3RhdGUubG9jYWxWYXJzID0ge25hbWU6IHZhcm5hbWUsIG5leHQ6IHN0YXRlLmxvY2FsVmFyc307XG4gIH0gZWxzZSBpZiAoc3RhdGUuZ2xvYmFsVmFycykge1xuICAgIGlmIChpbkxpc3QodmFybmFtZSwgc3RhdGUuZ2xvYmFsVmFycykpIHJldHVybjtcbiAgICBzdGF0ZS5nbG9iYWxWYXJzID0ge25hbWU6IHZhcm5hbWUsIG5leHQ6IHN0YXRlLmdsb2JhbFZhcnN9O1xuICB9XG59XG5cbi8vIENvbWJpbmF0b3JzXG5cbnZhciBkZWZhdWx0VmFycyA9IHtuYW1lOiBcInRoaXNcIiwgbmV4dDogbnVsbH07XG5mdW5jdGlvbiBwdXNoY29udGV4dCgpIHtcbiAgaWYgKCFjeC5zdGF0ZS5jb250ZXh0KSBjeC5zdGF0ZS5sb2NhbFZhcnMgPSBkZWZhdWx0VmFycztcbiAgY3guc3RhdGUuY29udGV4dCA9IHtwcmV2OiBjeC5zdGF0ZS5jb250ZXh0LCB2YXJzOiBjeC5zdGF0ZS5sb2NhbFZhcnN9O1xufVxuZnVuY3Rpb24gcG9wY29udGV4dCgpIHtcbiAgY3guc3RhdGUubG9jYWxWYXJzID0gY3guc3RhdGUuY29udGV4dC52YXJzO1xuICBjeC5zdGF0ZS5jb250ZXh0ID0gY3guc3RhdGUuY29udGV4dC5wcmV2O1xufVxucG9wY29udGV4dC5sZXggPSB0cnVlO1xuZnVuY3Rpb24gcHVzaGxleCh0eXBlLCBpbmZvKSB7XG4gIHZhciByZXN1bHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhdGUgPSBjeC5zdGF0ZTtcbiAgICBzdGF0ZS5sZXhpY2FsID0gbmV3IEhheGVMZXhpY2FsKHN0YXRlLmluZGVudGVkLCBjeC5zdHJlYW0uY29sdW1uKCksIHR5cGUsIG51bGwsIHN0YXRlLmxleGljYWwsIGluZm8pO1xuICB9O1xuICByZXN1bHQubGV4ID0gdHJ1ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBvcGxleCgpIHtcbiAgdmFyIHN0YXRlID0gY3guc3RhdGU7XG4gIGlmIChzdGF0ZS5sZXhpY2FsLnByZXYpIHtcbiAgICBpZiAoc3RhdGUubGV4aWNhbC50eXBlID09IFwiKVwiKVxuICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdGF0ZS5sZXhpY2FsLmluZGVudGVkO1xuICAgIHN0YXRlLmxleGljYWwgPSBzdGF0ZS5sZXhpY2FsLnByZXY7XG4gIH1cbn1cbnBvcGxleC5sZXggPSB0cnVlO1xuXG5mdW5jdGlvbiBleHBlY3Qod2FudGVkKSB7XG4gIGZ1bmN0aW9uIGYodHlwZSkge1xuICAgIGlmICh0eXBlID09IHdhbnRlZCkgcmV0dXJuIGNvbnQoKTtcbiAgICBlbHNlIGlmICh3YW50ZWQgPT0gXCI7XCIpIHJldHVybiBwYXNzKCk7XG4gICAgZWxzZSByZXR1cm4gY29udChmKTtcbiAgfVxuICByZXR1cm4gZjtcbn1cblxuZnVuY3Rpb24gc3RhdGVtZW50KHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gXCJAXCIpIHJldHVybiBjb250KG1ldGFkZWYpO1xuICBpZiAodHlwZSA9PSBcInZhclwiKSByZXR1cm4gY29udChwdXNobGV4KFwidmFyZGVmXCIpLCB2YXJkZWYxLCBleHBlY3QoXCI7XCIpLCBwb3BsZXgpO1xuICBpZiAodHlwZSA9PSBcImtleXdvcmQgYVwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgZXhwcmVzc2lvbiwgc3RhdGVtZW50LCBwb3BsZXgpO1xuICBpZiAodHlwZSA9PSBcImtleXdvcmQgYlwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgc3RhdGVtZW50LCBwb3BsZXgpO1xuICBpZiAodHlwZSA9PSBcIntcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIn1cIiksIHB1c2hjb250ZXh0LCBibG9jaywgcG9wbGV4LCBwb3Bjb250ZXh0KTtcbiAgaWYgKHR5cGUgPT0gXCI7XCIpIHJldHVybiBjb250KCk7XG4gIGlmICh0eXBlID09IFwiYXR0cmlidXRlXCIpIHJldHVybiBjb250KG1heWJlYXR0cmlidXRlKTtcbiAgaWYgKHR5cGUgPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gY29udChmdW5jdGlvbmRlZik7XG4gIGlmICh0eXBlID09IFwiZm9yXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBleHBlY3QoXCIoXCIpLCBwdXNobGV4KFwiKVwiKSwgZm9yc3BlYzEsIGV4cGVjdChcIilcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3BsZXgsIHN0YXRlbWVudCwgcG9wbGV4KTtcbiAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSByZXR1cm4gY29udChwdXNobGV4KFwic3RhdFwiKSwgbWF5YmVsYWJlbCk7XG4gIGlmICh0eXBlID09IFwic3dpdGNoXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBleHByZXNzaW9uLCBwdXNobGV4KFwifVwiLCBcInN3aXRjaFwiKSwgZXhwZWN0KFwie1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrLCBwb3BsZXgsIHBvcGxleCk7XG4gIGlmICh0eXBlID09IFwiY2FzZVwiKSByZXR1cm4gY29udChleHByZXNzaW9uLCBleHBlY3QoXCI6XCIpKTtcbiAgaWYgKHR5cGUgPT0gXCJkZWZhdWx0XCIpIHJldHVybiBjb250KGV4cGVjdChcIjpcIikpO1xuICBpZiAodHlwZSA9PSBcImNhdGNoXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBwdXNoY29udGV4dCwgZXhwZWN0KFwiKFwiKSwgZnVuYXJnLCBleHBlY3QoXCIpXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQsIHBvcGxleCwgcG9wY29udGV4dCk7XG4gIGlmICh0eXBlID09IFwiaW1wb3J0XCIpIHJldHVybiBjb250KGltcG9ydGRlZiwgZXhwZWN0KFwiO1wiKSk7XG4gIGlmICh0eXBlID09IFwidHlwZWRlZlwiKSByZXR1cm4gY29udCh0eXBlZGVmKTtcbiAgcmV0dXJuIHBhc3MocHVzaGxleChcInN0YXRcIiksIGV4cHJlc3Npb24sIGV4cGVjdChcIjtcIiksIHBvcGxleCk7XG59XG5mdW5jdGlvbiBleHByZXNzaW9uKHR5cGUpIHtcbiAgaWYgKGF0b21pY1R5cGVzLmhhc093blByb3BlcnR5KHR5cGUpKSByZXR1cm4gY29udChtYXliZW9wZXJhdG9yKTtcbiAgaWYgKHR5cGUgPT0gXCJ0eXBlXCIgKSByZXR1cm4gY29udChtYXliZW9wZXJhdG9yKTtcbiAgaWYgKHR5cGUgPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gY29udChmdW5jdGlvbmRlZik7XG4gIGlmICh0eXBlID09IFwia2V5d29yZCBjXCIpIHJldHVybiBjb250KG1heWJlZXhwcmVzc2lvbik7XG4gIGlmICh0eXBlID09IFwiKFwiKSByZXR1cm4gY29udChwdXNobGV4KFwiKVwiKSwgbWF5YmVleHByZXNzaW9uLCBleHBlY3QoXCIpXCIpLCBwb3BsZXgsIG1heWJlb3BlcmF0b3IpO1xuICBpZiAodHlwZSA9PSBcIm9wZXJhdG9yXCIpIHJldHVybiBjb250KGV4cHJlc3Npb24pO1xuICBpZiAodHlwZSA9PSBcIltcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIl1cIiksIGNvbW1hc2VwKG1heWJlZXhwcmVzc2lvbiwgXCJdXCIpLCBwb3BsZXgsIG1heWJlb3BlcmF0b3IpO1xuICBpZiAodHlwZSA9PSBcIntcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIn1cIiksIGNvbW1hc2VwKG9ianByb3AsIFwifVwiKSwgcG9wbGV4LCBtYXliZW9wZXJhdG9yKTtcbiAgcmV0dXJuIGNvbnQoKTtcbn1cbmZ1bmN0aW9uIG1heWJlZXhwcmVzc2lvbih0eXBlKSB7XG4gIGlmICh0eXBlLm1hdGNoKC9bO1xcfVxcKVxcXSxdLykpIHJldHVybiBwYXNzKCk7XG4gIHJldHVybiBwYXNzKGV4cHJlc3Npb24pO1xufVxuXG5mdW5jdGlvbiBtYXliZW9wZXJhdG9yKHR5cGUsIHZhbHVlKSB7XG4gIGlmICh0eXBlID09IFwib3BlcmF0b3JcIiAmJiAvXFwrXFwrfC0tLy50ZXN0KHZhbHVlKSkgcmV0dXJuIGNvbnQobWF5YmVvcGVyYXRvcik7XG4gIGlmICh0eXBlID09IFwib3BlcmF0b3JcIiB8fCB0eXBlID09IFwiOlwiKSByZXR1cm4gY29udChleHByZXNzaW9uKTtcbiAgaWYgKHR5cGUgPT0gXCI7XCIpIHJldHVybjtcbiAgaWYgKHR5cGUgPT0gXCIoXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCIpXCIpLCBjb21tYXNlcChleHByZXNzaW9uLCBcIilcIiksIHBvcGxleCwgbWF5YmVvcGVyYXRvcik7XG4gIGlmICh0eXBlID09IFwiLlwiKSByZXR1cm4gY29udChwcm9wZXJ0eSwgbWF5YmVvcGVyYXRvcik7XG4gIGlmICh0eXBlID09IFwiW1wiKSByZXR1cm4gY29udChwdXNobGV4KFwiXVwiKSwgZXhwcmVzc2lvbiwgZXhwZWN0KFwiXVwiKSwgcG9wbGV4LCBtYXliZW9wZXJhdG9yKTtcbn1cblxuZnVuY3Rpb24gbWF5YmVhdHRyaWJ1dGUodHlwZSkge1xuICBpZiAodHlwZSA9PSBcImF0dHJpYnV0ZVwiKSByZXR1cm4gY29udChtYXliZWF0dHJpYnV0ZSk7XG4gIGlmICh0eXBlID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGNvbnQoZnVuY3Rpb25kZWYpO1xuICBpZiAodHlwZSA9PSBcInZhclwiKSByZXR1cm4gY29udCh2YXJkZWYxKTtcbn1cblxuZnVuY3Rpb24gbWV0YWRlZih0eXBlKSB7XG4gIGlmKHR5cGUgPT0gXCI6XCIpIHJldHVybiBjb250KG1ldGFkZWYpO1xuICBpZih0eXBlID09IFwidmFyaWFibGVcIikgcmV0dXJuIGNvbnQobWV0YWRlZik7XG4gIGlmKHR5cGUgPT0gXCIoXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCIpXCIpLCBjb21tYXNlcChtZXRhYXJncywgXCIpXCIpLCBwb3BsZXgsIHN0YXRlbWVudCk7XG59XG5mdW5jdGlvbiBtZXRhYXJncyh0eXBlKSB7XG4gIGlmKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSByZXR1cm4gY29udCgpO1xufVxuXG5mdW5jdGlvbiBpbXBvcnRkZWYgKHR5cGUsIHZhbHVlKSB7XG4gIGlmKHR5cGUgPT0gXCJ2YXJpYWJsZVwiICYmIC9bQS1aXS8udGVzdCh2YWx1ZS5jaGFyQXQoMCkpKSB7IHJlZ2lzdGVyaW1wb3J0KHZhbHVlKTsgcmV0dXJuIGNvbnQoKTsgfVxuICBlbHNlIGlmKHR5cGUgPT0gXCJ2YXJpYWJsZVwiIHx8IHR5cGUgPT0gXCJwcm9wZXJ0eVwiIHx8IHR5cGUgPT0gXCIuXCIgfHwgdmFsdWUgPT0gXCIqXCIpIHJldHVybiBjb250KGltcG9ydGRlZik7XG59XG5cbmZ1bmN0aW9uIHR5cGVkZWYgKHR5cGUsIHZhbHVlKVxue1xuICBpZih0eXBlID09IFwidmFyaWFibGVcIiAmJiAvW0EtWl0vLnRlc3QodmFsdWUuY2hhckF0KDApKSkgeyByZWdpc3RlcmltcG9ydCh2YWx1ZSk7IHJldHVybiBjb250KCk7IH1cbiAgZWxzZSBpZiAodHlwZSA9PSBcInR5cGVcIiAmJiAvW0EtWl0vLnRlc3QodmFsdWUuY2hhckF0KDApKSkgeyByZXR1cm4gY29udCgpOyB9XG59XG5cbmZ1bmN0aW9uIG1heWJlbGFiZWwodHlwZSkge1xuICBpZiAodHlwZSA9PSBcIjpcIikgcmV0dXJuIGNvbnQocG9wbGV4LCBzdGF0ZW1lbnQpO1xuICByZXR1cm4gcGFzcyhtYXliZW9wZXJhdG9yLCBleHBlY3QoXCI7XCIpLCBwb3BsZXgpO1xufVxuZnVuY3Rpb24gcHJvcGVydHkodHlwZSkge1xuICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHtjeC5tYXJrZWQgPSBcInByb3BlcnR5XCI7IHJldHVybiBjb250KCk7fVxufVxuZnVuY3Rpb24gb2JqcHJvcCh0eXBlKSB7XG4gIGlmICh0eXBlID09IFwidmFyaWFibGVcIikgY3gubWFya2VkID0gXCJwcm9wZXJ0eVwiO1xuICBpZiAoYXRvbWljVHlwZXMuaGFzT3duUHJvcGVydHkodHlwZSkpIHJldHVybiBjb250KGV4cGVjdChcIjpcIiksIGV4cHJlc3Npb24pO1xufVxuZnVuY3Rpb24gY29tbWFzZXAod2hhdCwgZW5kKSB7XG4gIGZ1bmN0aW9uIHByb2NlZWQodHlwZSkge1xuICAgIGlmICh0eXBlID09IFwiLFwiKSByZXR1cm4gY29udCh3aGF0LCBwcm9jZWVkKTtcbiAgICBpZiAodHlwZSA9PSBlbmQpIHJldHVybiBjb250KCk7XG4gICAgcmV0dXJuIGNvbnQoZXhwZWN0KGVuZCkpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbih0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gZW5kKSByZXR1cm4gY29udCgpO1xuICAgIGVsc2UgcmV0dXJuIHBhc3Mod2hhdCwgcHJvY2VlZCk7XG4gIH07XG59XG5mdW5jdGlvbiBibG9jayh0eXBlKSB7XG4gIGlmICh0eXBlID09IFwifVwiKSByZXR1cm4gY29udCgpO1xuICByZXR1cm4gcGFzcyhzdGF0ZW1lbnQsIGJsb2NrKTtcbn1cbmZ1bmN0aW9uIHZhcmRlZjEodHlwZSwgdmFsdWUpIHtcbiAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKXtyZWdpc3Rlcih2YWx1ZSk7IHJldHVybiBjb250KHR5cGV1c2UsIHZhcmRlZjIpO31cbiAgcmV0dXJuIGNvbnQoKTtcbn1cbmZ1bmN0aW9uIHZhcmRlZjIodHlwZSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IFwiPVwiKSByZXR1cm4gY29udChleHByZXNzaW9uLCB2YXJkZWYyKTtcbiAgaWYgKHR5cGUgPT0gXCIsXCIpIHJldHVybiBjb250KHZhcmRlZjEpO1xufVxuZnVuY3Rpb24gZm9yc3BlYzEodHlwZSwgdmFsdWUpIHtcbiAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSB7XG4gICAgcmVnaXN0ZXIodmFsdWUpO1xuICAgIHJldHVybiBjb250KGZvcmluLCBleHByZXNzaW9uKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXNzKClcbiAgfVxufVxuZnVuY3Rpb24gZm9yaW4oX3R5cGUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBcImluXCIpIHJldHVybiBjb250KCk7XG59XG5mdW5jdGlvbiBmdW5jdGlvbmRlZih0eXBlLCB2YWx1ZSkge1xuICAvL2Z1bmN0aW9uIG5hbWVzIHN0YXJ0aW5nIHdpdGggdXBwZXItY2FzZSBsZXR0ZXJzIGFyZSByZWNvZ25pc2VkIGFzIHR5cGVzLCBzbyBjbHVkZ2luZyB0aGVtIHRvZ2V0aGVyIGhlcmUuXG4gIGlmICh0eXBlID09IFwidmFyaWFibGVcIiB8fCB0eXBlID09IFwidHlwZVwiKSB7cmVnaXN0ZXIodmFsdWUpOyByZXR1cm4gY29udChmdW5jdGlvbmRlZik7fVxuICBpZiAodmFsdWUgPT0gXCJuZXdcIikgcmV0dXJuIGNvbnQoZnVuY3Rpb25kZWYpO1xuICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIilcIiksIHB1c2hjb250ZXh0LCBjb21tYXNlcChmdW5hcmcsIFwiKVwiKSwgcG9wbGV4LCB0eXBldXNlLCBzdGF0ZW1lbnQsIHBvcGNvbnRleHQpO1xufVxuZnVuY3Rpb24gdHlwZXVzZSh0eXBlKSB7XG4gIGlmKHR5cGUgPT0gXCI6XCIpIHJldHVybiBjb250KHR5cGVzdHJpbmcpO1xufVxuZnVuY3Rpb24gdHlwZXN0cmluZyh0eXBlKSB7XG4gIGlmKHR5cGUgPT0gXCJ0eXBlXCIpIHJldHVybiBjb250KCk7XG4gIGlmKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSByZXR1cm4gY29udCgpO1xuICBpZih0eXBlID09IFwie1wiKSByZXR1cm4gY29udChwdXNobGV4KFwifVwiKSwgY29tbWFzZXAodHlwZXByb3AsIFwifVwiKSwgcG9wbGV4KTtcbn1cbmZ1bmN0aW9uIHR5cGVwcm9wKHR5cGUpIHtcbiAgaWYodHlwZSA9PSBcInZhcmlhYmxlXCIpIHJldHVybiBjb250KHR5cGV1c2UpO1xufVxuZnVuY3Rpb24gZnVuYXJnKHR5cGUsIHZhbHVlKSB7XG4gIGlmICh0eXBlID09IFwidmFyaWFibGVcIikge3JlZ2lzdGVyKHZhbHVlKTsgcmV0dXJuIGNvbnQodHlwZXVzZSk7fVxufVxuXG4vLyBJbnRlcmZhY2VcbmV4cG9ydCBjb25zdCBoYXhlID0ge1xuICBzdGFydFN0YXRlOiBmdW5jdGlvbihpbmRlbnRVbml0KSB7XG4gICAgdmFyIGRlZmF1bHR0eXBlcyA9IFtcIkludFwiLCBcIkZsb2F0XCIsIFwiU3RyaW5nXCIsIFwiVm9pZFwiLCBcIlN0ZFwiLCBcIkJvb2xcIiwgXCJEeW5hbWljXCIsIFwiQXJyYXlcIl07XG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgdG9rZW5pemU6IGhheGVUb2tlbkJhc2UsXG4gICAgICByZUFsbG93ZWQ6IHRydWUsXG4gICAgICBrd0FsbG93ZWQ6IHRydWUsXG4gICAgICBjYzogW10sXG4gICAgICBsZXhpY2FsOiBuZXcgSGF4ZUxleGljYWwoLWluZGVudFVuaXQsIDAsIFwiYmxvY2tcIiwgZmFsc2UpLFxuICAgICAgaW1wb3J0ZWR0eXBlczogZGVmYXVsdHR5cGVzLFxuICAgICAgY29udGV4dDogbnVsbCxcbiAgICAgIGluZGVudGVkOiAwXG4gICAgfTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH0sXG5cbiAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgICBpZiAoIXN0YXRlLmxleGljYWwuaGFzT3duUHJvcGVydHkoXCJhbGlnblwiKSlcbiAgICAgICAgc3RhdGUubGV4aWNhbC5hbGlnbiA9IGZhbHNlO1xuICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAodHlwZSA9PSBcImNvbW1lbnRcIikgcmV0dXJuIHN0eWxlO1xuICAgIHN0YXRlLnJlQWxsb3dlZCA9ICEhKHR5cGUgPT0gXCJvcGVyYXRvclwiIHx8IHR5cGUgPT0gXCJrZXl3b3JkIGNcIiB8fCB0eXBlLm1hdGNoKC9eW1xcW3t9XFwoLDs6XSQvKSk7XG4gICAgc3RhdGUua3dBbGxvd2VkID0gdHlwZSAhPSAnLic7XG4gICAgcmV0dXJuIHBhcnNlSGF4ZShzdGF0ZSwgc3R5bGUsIHR5cGUsIGNvbnRlbnQsIHN0cmVhbSk7XG4gIH0sXG5cbiAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyLCBjeCkge1xuICAgIGlmIChzdGF0ZS50b2tlbml6ZSAhPSBoYXhlVG9rZW5CYXNlKSByZXR1cm4gMDtcbiAgICB2YXIgZmlyc3RDaGFyID0gdGV4dEFmdGVyICYmIHRleHRBZnRlci5jaGFyQXQoMCksIGxleGljYWwgPSBzdGF0ZS5sZXhpY2FsO1xuICAgIGlmIChsZXhpY2FsLnR5cGUgPT0gXCJzdGF0XCIgJiYgZmlyc3RDaGFyID09IFwifVwiKSBsZXhpY2FsID0gbGV4aWNhbC5wcmV2O1xuICAgIHZhciB0eXBlID0gbGV4aWNhbC50eXBlLCBjbG9zaW5nID0gZmlyc3RDaGFyID09IHR5cGU7XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJkZWZcIikgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQgKyA0O1xuICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJmb3JtXCIgJiYgZmlyc3RDaGFyID09IFwie1wiKSByZXR1cm4gbGV4aWNhbC5pbmRlbnRlZDtcbiAgICBlbHNlIGlmICh0eXBlID09IFwic3RhdFwiIHx8IHR5cGUgPT0gXCJmb3JtXCIpIHJldHVybiBsZXhpY2FsLmluZGVudGVkICsgY3gudW5pdDtcbiAgICBlbHNlIGlmIChsZXhpY2FsLmluZm8gPT0gXCJzd2l0Y2hcIiAmJiAhY2xvc2luZylcbiAgICAgIHJldHVybiBsZXhpY2FsLmluZGVudGVkICsgKC9eKD86Y2FzZXxkZWZhdWx0KVxcYi8udGVzdCh0ZXh0QWZ0ZXIpID8gY3gudW5pdCA6IDIgKiBjeC51bml0KTtcbiAgICBlbHNlIGlmIChsZXhpY2FsLmFsaWduKSByZXR1cm4gbGV4aWNhbC5jb2x1bW4gKyAoY2xvc2luZyA/IDAgOiAxKTtcbiAgICBlbHNlIHJldHVybiBsZXhpY2FsLmluZGVudGVkICsgKGNsb3NpbmcgPyAwIDogY3gudW5pdCk7XG4gIH0sXG5cbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgaW5kZW50T25JbnB1dDogL15cXHMqW3t9XSQvLFxuICAgIGNvbW1lbnRUb2tlbnM6IHtsaW5lOiBcIi8vXCIsIGJsb2NrOiB7b3BlbjogXCIvKlwiLCBjbG9zZTogXCIqL1wifX1cbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGh4bWwgPSB7XG4gIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGVmaW5lOiBmYWxzZSxcbiAgICAgIGluU3RyaW5nOiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIHRva2VuOiBmdW5jdGlvbiAoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0cmVhbS5wZWVrKCk7XG4gICAgdmFyIHNvbCA9IHN0cmVhbS5zb2woKTtcblxuICAgIC8vLyogY29tbWVudHMgKi9cbiAgICBpZiAoY2ggPT0gXCIjXCIpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICB9XG4gICAgaWYgKHNvbCAmJiBjaCA9PSBcIi1cIikge1xuICAgICAgdmFyIHN0eWxlID0gXCJ2YXJpYWJsZS0yXCI7XG5cbiAgICAgIHN0cmVhbS5lYXQoLy0vKTtcblxuICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT0gXCItXCIpIHtcbiAgICAgICAgc3RyZWFtLmVhdCgvLS8pO1xuICAgICAgICBzdHlsZSA9IFwia2V5d29yZCBhXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJlYW0ucGVlaygpID09IFwiRFwiKSB7XG4gICAgICAgIHN0cmVhbS5lYXQoL1tEXS8pO1xuICAgICAgICBzdHlsZSA9IFwia2V5d29yZCBjXCI7XG4gICAgICAgIHN0YXRlLmRlZmluZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW0EtWl0vaSk7XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuXG4gICAgdmFyIGNoID0gc3RyZWFtLnBlZWsoKTtcblxuICAgIGlmIChzdGF0ZS5pblN0cmluZyA9PSBmYWxzZSAmJiBjaCA9PSBcIidcIikge1xuICAgICAgc3RhdGUuaW5TdHJpbmcgPSB0cnVlO1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuaW5TdHJpbmcgPT0gdHJ1ZSkge1xuICAgICAgaWYgKHN0cmVhbS5za2lwVG8oXCInXCIpKSB7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT0gXCInXCIpIHtcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgc3RhdGUuaW5TdHJpbmcgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfVxuXG4gICAgc3RyZWFtLm5leHQoKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgY29tbWVudFRva2Vuczoge2xpbmU6IFwiI1wifVxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/legacy-modes/mode/haxe.js\n");

/***/ })

}]);