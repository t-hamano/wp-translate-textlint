(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{389:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "haskell", function() { return haskell; });\nfunction switchState(source, setState, f) {\n  setState(f);\n  return f(source, setState);\n}\n\n// These should all be Unicode extended, as per the Haskell 2010 report\nvar smallRE = /[a-z_]/;\nvar largeRE = /[A-Z]/;\nvar digitRE = /\\d/;\nvar hexitRE = /[0-9A-Fa-f]/;\nvar octitRE = /[0-7]/;\nvar idRE = /[a-z_A-Z0-9\'\\xa1-\\uffff]/;\nvar symbolRE = /[-!#$%&*+.\\/<=>?@\\\\^|~:]/;\nvar specialRE = /[(),;[\\]`{}]/;\nvar whiteCharRE = /[ \\t\\v\\f]/; // newlines are handled in tokenizer\n\nfunction normal(source, setState) {\n  if (source.eatWhile(whiteCharRE)) {\n    return null;\n  }\n\n  var ch = source.next();\n  if (specialRE.test(ch)) {\n    if (ch == \'{\' && source.eat(\'-\')) {\n      var t = "comment";\n      if (source.eat(\'#\')) {\n        t = "meta";\n      }\n      return switchState(source, setState, ncomment(t, 1));\n    }\n    return null;\n  }\n\n  if (ch == \'\\\'\') {\n    if (source.eat(\'\\\\\')) {\n      source.next();  // should handle other escapes here\n    }\n    else {\n      source.next();\n    }\n    if (source.eat(\'\\\'\')) {\n      return "string";\n    }\n    return "error";\n  }\n\n  if (ch == \'"\') {\n    return switchState(source, setState, stringLiteral);\n  }\n\n  if (largeRE.test(ch)) {\n    source.eatWhile(idRE);\n    if (source.eat(\'.\')) {\n      return "qualifier";\n    }\n    return "type";\n  }\n\n  if (smallRE.test(ch)) {\n    source.eatWhile(idRE);\n    return "variable";\n  }\n\n  if (digitRE.test(ch)) {\n    if (ch == \'0\') {\n      if (source.eat(/[xX]/)) {\n        source.eatWhile(hexitRE); // should require at least 1\n        return "integer";\n      }\n      if (source.eat(/[oO]/)) {\n        source.eatWhile(octitRE); // should require at least 1\n        return "number";\n      }\n    }\n    source.eatWhile(digitRE);\n    var t = "number";\n    if (source.match(/^\\.\\d+/)) {\n      t = "number";\n    }\n    if (source.eat(/[eE]/)) {\n      t = "number";\n      source.eat(/[-+]/);\n      source.eatWhile(digitRE); // should require at least 1\n    }\n    return t;\n  }\n\n  if (ch == "." && source.eat("."))\n    return "keyword";\n\n  if (symbolRE.test(ch)) {\n    if (ch == \'-\' && source.eat(/-/)) {\n      source.eatWhile(/-/);\n      if (!source.eat(symbolRE)) {\n        source.skipToEnd();\n        return "comment";\n      }\n    }\n    source.eatWhile(symbolRE);\n    return "variable"\n  }\n\n  return "error";\n}\n\nfunction ncomment(type, nest) {\n  if (nest == 0) {\n    return normal;\n  }\n  return function(source, setState) {\n    var currNest = nest;\n    while (!source.eol()) {\n      var ch = source.next();\n      if (ch == \'{\' && source.eat(\'-\')) {\n        ++currNest;\n      }\n      else if (ch == \'-\' && source.eat(\'}\')) {\n        --currNest;\n        if (currNest == 0) {\n          setState(normal);\n          return type;\n        }\n      }\n    }\n    setState(ncomment(type, currNest));\n    return type;\n  };\n}\n\nfunction stringLiteral(source, setState) {\n  while (!source.eol()) {\n    var ch = source.next();\n    if (ch == \'"\') {\n      setState(normal);\n      return "string";\n    }\n    if (ch == \'\\\\\') {\n      if (source.eol() || source.eat(whiteCharRE)) {\n        setState(stringGap);\n        return "string";\n      }\n      if (source.eat(\'&\')) {\n      }\n      else {\n        source.next(); // should handle other escapes here\n      }\n    }\n  }\n  setState(normal);\n  return "error";\n}\n\nfunction stringGap(source, setState) {\n  if (source.eat(\'\\\\\')) {\n    return switchState(source, setState, stringLiteral);\n  }\n  source.next();\n  setState(normal);\n  return "error";\n}\n\n\nvar wellKnownWords = (function() {\n  var wkw = {};\n  function setType(t) {\n    return function () {\n      for (var i = 0; i < arguments.length; i++)\n        wkw[arguments[i]] = t;\n    };\n  }\n\n  setType("keyword")(\n    "case", "class", "data", "default", "deriving", "do", "else", "foreign",\n    "if", "import", "in", "infix", "infixl", "infixr", "instance", "let",\n    "module", "newtype", "of", "then", "type", "where", "_");\n\n  setType("keyword")(\n    "\\.\\.", ":", "::", "=", "\\\\", "<-", "->", "@", "~", "=>");\n\n  setType("builtin")(\n    "!!", "$!", "$", "&&", "+", "++", "-", ".", "/", "/=", "<", "<*", "<=",\n    "<$>", "<*>", "=<<", "==", ">", ">=", ">>", ">>=", "^", "^^", "||", "*",\n    "*>", "**");\n\n  setType("builtin")(\n    "Applicative", "Bool", "Bounded", "Char", "Double", "EQ", "Either", "Enum",\n    "Eq", "False", "FilePath", "Float", "Floating", "Fractional", "Functor",\n    "GT", "IO", "IOError", "Int", "Integer", "Integral", "Just", "LT", "Left",\n    "Maybe", "Monad", "Nothing", "Num", "Ord", "Ordering", "Rational", "Read",\n    "ReadS", "Real", "RealFloat", "RealFrac", "Right", "Show", "ShowS",\n    "String", "True");\n\n  setType("builtin")(\n    "abs", "acos", "acosh", "all", "and", "any", "appendFile", "asTypeOf",\n    "asin", "asinh", "atan", "atan2", "atanh", "break", "catch", "ceiling",\n    "compare", "concat", "concatMap", "const", "cos", "cosh", "curry",\n    "cycle", "decodeFloat", "div", "divMod", "drop", "dropWhile", "either",\n    "elem", "encodeFloat", "enumFrom", "enumFromThen", "enumFromThenTo",\n    "enumFromTo", "error", "even", "exp", "exponent", "fail", "filter",\n    "flip", "floatDigits", "floatRadix", "floatRange", "floor", "fmap",\n    "foldl", "foldl1", "foldr", "foldr1", "fromEnum", "fromInteger",\n    "fromIntegral", "fromRational", "fst", "gcd", "getChar", "getContents",\n    "getLine", "head", "id", "init", "interact", "ioError", "isDenormalized",\n    "isIEEE", "isInfinite", "isNaN", "isNegativeZero", "iterate", "last",\n    "lcm", "length", "lex", "lines", "log", "logBase", "lookup", "map",\n    "mapM", "mapM_", "max", "maxBound", "maximum", "maybe", "min", "minBound",\n    "minimum", "mod", "negate", "not", "notElem", "null", "odd", "or",\n    "otherwise", "pi", "pred", "print", "product", "properFraction", "pure",\n    "putChar", "putStr", "putStrLn", "quot", "quotRem", "read", "readFile",\n    "readIO", "readList", "readLn", "readParen", "reads", "readsPrec",\n    "realToFrac", "recip", "rem", "repeat", "replicate", "return", "reverse",\n    "round", "scaleFloat", "scanl", "scanl1", "scanr", "scanr1", "seq",\n    "sequence", "sequence_", "show", "showChar", "showList", "showParen",\n    "showString", "shows", "showsPrec", "significand", "signum", "sin",\n    "sinh", "snd", "span", "splitAt", "sqrt", "subtract", "succ", "sum",\n    "tail", "take", "takeWhile", "tan", "tanh", "toEnum", "toInteger",\n    "toRational", "truncate", "uncurry", "undefined", "unlines", "until",\n    "unwords", "unzip", "unzip3", "userError", "words", "writeFile", "zip",\n    "zip3", "zipWith", "zipWith3");\n\n  return wkw;\n})();\n\nconst haskell = {\n  startState: function ()  { return { f: normal }; },\n  copyState:  function (s) { return { f: s.f }; },\n\n  token: function(stream, state) {\n    var t = state.f(stream, function(s) { state.f = s; });\n    var w = stream.current();\n    return wellKnownWords.hasOwnProperty(w) ? wellKnownWords[w] : t;\n  },\n\n  languageData: {\n    commentTokens: {line: "--", block: {open: "{-", close: "-}"}}\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvaGFza2VsbC5qcz85ZjE1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU07QUFDNUIsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFTTtBQUNQLDRCQUE0QixTQUFTLGFBQWEsRUFBRTtBQUNwRCw0QkFBNEIsU0FBUyxVQUFVLEVBQUU7O0FBRWpEO0FBQ0EseUNBQXlDLGFBQWEsRUFBRTtBQUN4RDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLG9CQUFvQixvQkFBb0IsUUFBUSxjQUFjO0FBQzlEO0FBQ0EiLCJmaWxlIjoiMzg5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gc3dpdGNoU3RhdGUoc291cmNlLCBzZXRTdGF0ZSwgZikge1xuICBzZXRTdGF0ZShmKTtcbiAgcmV0dXJuIGYoc291cmNlLCBzZXRTdGF0ZSk7XG59XG5cbi8vIFRoZXNlIHNob3VsZCBhbGwgYmUgVW5pY29kZSBleHRlbmRlZCwgYXMgcGVyIHRoZSBIYXNrZWxsIDIwMTAgcmVwb3J0XG52YXIgc21hbGxSRSA9IC9bYS16X10vO1xudmFyIGxhcmdlUkUgPSAvW0EtWl0vO1xudmFyIGRpZ2l0UkUgPSAvXFxkLztcbnZhciBoZXhpdFJFID0gL1swLTlBLUZhLWZdLztcbnZhciBvY3RpdFJFID0gL1swLTddLztcbnZhciBpZFJFID0gL1thLXpfQS1aMC05J1xceGExLVxcdWZmZmZdLztcbnZhciBzeW1ib2xSRSA9IC9bLSEjJCUmKisuXFwvPD0+P0BcXFxcXnx+Ol0vO1xudmFyIHNwZWNpYWxSRSA9IC9bKCksO1tcXF1ge31dLztcbnZhciB3aGl0ZUNoYXJSRSA9IC9bIFxcdFxcdlxcZl0vOyAvLyBuZXdsaW5lcyBhcmUgaGFuZGxlZCBpbiB0b2tlbml6ZXJcblxuZnVuY3Rpb24gbm9ybWFsKHNvdXJjZSwgc2V0U3RhdGUpIHtcbiAgaWYgKHNvdXJjZS5lYXRXaGlsZSh3aGl0ZUNoYXJSRSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBjaCA9IHNvdXJjZS5uZXh0KCk7XG4gIGlmIChzcGVjaWFsUkUudGVzdChjaCkpIHtcbiAgICBpZiAoY2ggPT0gJ3snICYmIHNvdXJjZS5lYXQoJy0nKSkge1xuICAgICAgdmFyIHQgPSBcImNvbW1lbnRcIjtcbiAgICAgIGlmIChzb3VyY2UuZWF0KCcjJykpIHtcbiAgICAgICAgdCA9IFwibWV0YVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN3aXRjaFN0YXRlKHNvdXJjZSwgc2V0U3RhdGUsIG5jb21tZW50KHQsIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY2ggPT0gJ1xcJycpIHtcbiAgICBpZiAoc291cmNlLmVhdCgnXFxcXCcpKSB7XG4gICAgICBzb3VyY2UubmV4dCgpOyAgLy8gc2hvdWxkIGhhbmRsZSBvdGhlciBlc2NhcGVzIGhlcmVcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzb3VyY2UubmV4dCgpO1xuICAgIH1cbiAgICBpZiAoc291cmNlLmVhdCgnXFwnJykpIHtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH1cbiAgICByZXR1cm4gXCJlcnJvclwiO1xuICB9XG5cbiAgaWYgKGNoID09ICdcIicpIHtcbiAgICByZXR1cm4gc3dpdGNoU3RhdGUoc291cmNlLCBzZXRTdGF0ZSwgc3RyaW5nTGl0ZXJhbCk7XG4gIH1cblxuICBpZiAobGFyZ2VSRS50ZXN0KGNoKSkge1xuICAgIHNvdXJjZS5lYXRXaGlsZShpZFJFKTtcbiAgICBpZiAoc291cmNlLmVhdCgnLicpKSB7XG4gICAgICByZXR1cm4gXCJxdWFsaWZpZXJcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwidHlwZVwiO1xuICB9XG5cbiAgaWYgKHNtYWxsUkUudGVzdChjaCkpIHtcbiAgICBzb3VyY2UuZWF0V2hpbGUoaWRSRSk7XG4gICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgfVxuXG4gIGlmIChkaWdpdFJFLnRlc3QoY2gpKSB7XG4gICAgaWYgKGNoID09ICcwJykge1xuICAgICAgaWYgKHNvdXJjZS5lYXQoL1t4WF0vKSkge1xuICAgICAgICBzb3VyY2UuZWF0V2hpbGUoaGV4aXRSRSk7IC8vIHNob3VsZCByZXF1aXJlIGF0IGxlYXN0IDFcbiAgICAgICAgcmV0dXJuIFwiaW50ZWdlclwiO1xuICAgICAgfVxuICAgICAgaWYgKHNvdXJjZS5lYXQoL1tvT10vKSkge1xuICAgICAgICBzb3VyY2UuZWF0V2hpbGUob2N0aXRSRSk7IC8vIHNob3VsZCByZXF1aXJlIGF0IGxlYXN0IDFcbiAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHNvdXJjZS5lYXRXaGlsZShkaWdpdFJFKTtcbiAgICB2YXIgdCA9IFwibnVtYmVyXCI7XG4gICAgaWYgKHNvdXJjZS5tYXRjaCgvXlxcLlxcZCsvKSkge1xuICAgICAgdCA9IFwibnVtYmVyXCI7XG4gICAgfVxuICAgIGlmIChzb3VyY2UuZWF0KC9bZUVdLykpIHtcbiAgICAgIHQgPSBcIm51bWJlclwiO1xuICAgICAgc291cmNlLmVhdCgvWy0rXS8pO1xuICAgICAgc291cmNlLmVhdFdoaWxlKGRpZ2l0UkUpOyAvLyBzaG91bGQgcmVxdWlyZSBhdCBsZWFzdCAxXG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG5cbiAgaWYgKGNoID09IFwiLlwiICYmIHNvdXJjZS5lYXQoXCIuXCIpKVxuICAgIHJldHVybiBcImtleXdvcmRcIjtcblxuICBpZiAoc3ltYm9sUkUudGVzdChjaCkpIHtcbiAgICBpZiAoY2ggPT0gJy0nICYmIHNvdXJjZS5lYXQoLy0vKSkge1xuICAgICAgc291cmNlLmVhdFdoaWxlKC8tLyk7XG4gICAgICBpZiAoIXNvdXJjZS5lYXQoc3ltYm9sUkUpKSB7XG4gICAgICAgIHNvdXJjZS5za2lwVG9FbmQoKTtcbiAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3VyY2UuZWF0V2hpbGUoc3ltYm9sUkUpO1xuICAgIHJldHVybiBcInZhcmlhYmxlXCJcbiAgfVxuXG4gIHJldHVybiBcImVycm9yXCI7XG59XG5cbmZ1bmN0aW9uIG5jb21tZW50KHR5cGUsIG5lc3QpIHtcbiAgaWYgKG5lc3QgPT0gMCkge1xuICAgIHJldHVybiBub3JtYWw7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKHNvdXJjZSwgc2V0U3RhdGUpIHtcbiAgICB2YXIgY3Vyck5lc3QgPSBuZXN0O1xuICAgIHdoaWxlICghc291cmNlLmVvbCgpKSB7XG4gICAgICB2YXIgY2ggPSBzb3VyY2UubmV4dCgpO1xuICAgICAgaWYgKGNoID09ICd7JyAmJiBzb3VyY2UuZWF0KCctJykpIHtcbiAgICAgICAgKytjdXJyTmVzdDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNoID09ICctJyAmJiBzb3VyY2UuZWF0KCd9JykpIHtcbiAgICAgICAgLS1jdXJyTmVzdDtcbiAgICAgICAgaWYgKGN1cnJOZXN0ID09IDApIHtcbiAgICAgICAgICBzZXRTdGF0ZShub3JtYWwpO1xuICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNldFN0YXRlKG5jb21tZW50KHR5cGUsIGN1cnJOZXN0KSk7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0cmluZ0xpdGVyYWwoc291cmNlLCBzZXRTdGF0ZSkge1xuICB3aGlsZSAoIXNvdXJjZS5lb2woKSkge1xuICAgIHZhciBjaCA9IHNvdXJjZS5uZXh0KCk7XG4gICAgaWYgKGNoID09ICdcIicpIHtcbiAgICAgIHNldFN0YXRlKG5vcm1hbCk7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9XG4gICAgaWYgKGNoID09ICdcXFxcJykge1xuICAgICAgaWYgKHNvdXJjZS5lb2woKSB8fCBzb3VyY2UuZWF0KHdoaXRlQ2hhclJFKSkge1xuICAgICAgICBzZXRTdGF0ZShzdHJpbmdHYXApO1xuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgIH1cbiAgICAgIGlmIChzb3VyY2UuZWF0KCcmJykpIHtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzb3VyY2UubmV4dCgpOyAvLyBzaG91bGQgaGFuZGxlIG90aGVyIGVzY2FwZXMgaGVyZVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzZXRTdGF0ZShub3JtYWwpO1xuICByZXR1cm4gXCJlcnJvclwiO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdHYXAoc291cmNlLCBzZXRTdGF0ZSkge1xuICBpZiAoc291cmNlLmVhdCgnXFxcXCcpKSB7XG4gICAgcmV0dXJuIHN3aXRjaFN0YXRlKHNvdXJjZSwgc2V0U3RhdGUsIHN0cmluZ0xpdGVyYWwpO1xuICB9XG4gIHNvdXJjZS5uZXh0KCk7XG4gIHNldFN0YXRlKG5vcm1hbCk7XG4gIHJldHVybiBcImVycm9yXCI7XG59XG5cblxudmFyIHdlbGxLbm93bldvcmRzID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgd2t3ID0ge307XG4gIGZ1bmN0aW9uIHNldFR5cGUodCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgd2t3W2FyZ3VtZW50c1tpXV0gPSB0O1xuICAgIH07XG4gIH1cblxuICBzZXRUeXBlKFwia2V5d29yZFwiKShcbiAgICBcImNhc2VcIiwgXCJjbGFzc1wiLCBcImRhdGFcIiwgXCJkZWZhdWx0XCIsIFwiZGVyaXZpbmdcIiwgXCJkb1wiLCBcImVsc2VcIiwgXCJmb3JlaWduXCIsXG4gICAgXCJpZlwiLCBcImltcG9ydFwiLCBcImluXCIsIFwiaW5maXhcIiwgXCJpbmZpeGxcIiwgXCJpbmZpeHJcIiwgXCJpbnN0YW5jZVwiLCBcImxldFwiLFxuICAgIFwibW9kdWxlXCIsIFwibmV3dHlwZVwiLCBcIm9mXCIsIFwidGhlblwiLCBcInR5cGVcIiwgXCJ3aGVyZVwiLCBcIl9cIik7XG5cbiAgc2V0VHlwZShcImtleXdvcmRcIikoXG4gICAgXCJcXC5cXC5cIiwgXCI6XCIsIFwiOjpcIiwgXCI9XCIsIFwiXFxcXFwiLCBcIjwtXCIsIFwiLT5cIiwgXCJAXCIsIFwiflwiLCBcIj0+XCIpO1xuXG4gIHNldFR5cGUoXCJidWlsdGluXCIpKFxuICAgIFwiISFcIiwgXCIkIVwiLCBcIiRcIiwgXCImJlwiLCBcIitcIiwgXCIrK1wiLCBcIi1cIiwgXCIuXCIsIFwiL1wiLCBcIi89XCIsIFwiPFwiLCBcIjwqXCIsIFwiPD1cIixcbiAgICBcIjwkPlwiLCBcIjwqPlwiLCBcIj08PFwiLCBcIj09XCIsIFwiPlwiLCBcIj49XCIsIFwiPj5cIiwgXCI+Pj1cIiwgXCJeXCIsIFwiXl5cIiwgXCJ8fFwiLCBcIipcIixcbiAgICBcIio+XCIsIFwiKipcIik7XG5cbiAgc2V0VHlwZShcImJ1aWx0aW5cIikoXG4gICAgXCJBcHBsaWNhdGl2ZVwiLCBcIkJvb2xcIiwgXCJCb3VuZGVkXCIsIFwiQ2hhclwiLCBcIkRvdWJsZVwiLCBcIkVRXCIsIFwiRWl0aGVyXCIsIFwiRW51bVwiLFxuICAgIFwiRXFcIiwgXCJGYWxzZVwiLCBcIkZpbGVQYXRoXCIsIFwiRmxvYXRcIiwgXCJGbG9hdGluZ1wiLCBcIkZyYWN0aW9uYWxcIiwgXCJGdW5jdG9yXCIsXG4gICAgXCJHVFwiLCBcIklPXCIsIFwiSU9FcnJvclwiLCBcIkludFwiLCBcIkludGVnZXJcIiwgXCJJbnRlZ3JhbFwiLCBcIkp1c3RcIiwgXCJMVFwiLCBcIkxlZnRcIixcbiAgICBcIk1heWJlXCIsIFwiTW9uYWRcIiwgXCJOb3RoaW5nXCIsIFwiTnVtXCIsIFwiT3JkXCIsIFwiT3JkZXJpbmdcIiwgXCJSYXRpb25hbFwiLCBcIlJlYWRcIixcbiAgICBcIlJlYWRTXCIsIFwiUmVhbFwiLCBcIlJlYWxGbG9hdFwiLCBcIlJlYWxGcmFjXCIsIFwiUmlnaHRcIiwgXCJTaG93XCIsIFwiU2hvd1NcIixcbiAgICBcIlN0cmluZ1wiLCBcIlRydWVcIik7XG5cbiAgc2V0VHlwZShcImJ1aWx0aW5cIikoXG4gICAgXCJhYnNcIiwgXCJhY29zXCIsIFwiYWNvc2hcIiwgXCJhbGxcIiwgXCJhbmRcIiwgXCJhbnlcIiwgXCJhcHBlbmRGaWxlXCIsIFwiYXNUeXBlT2ZcIixcbiAgICBcImFzaW5cIiwgXCJhc2luaFwiLCBcImF0YW5cIiwgXCJhdGFuMlwiLCBcImF0YW5oXCIsIFwiYnJlYWtcIiwgXCJjYXRjaFwiLCBcImNlaWxpbmdcIixcbiAgICBcImNvbXBhcmVcIiwgXCJjb25jYXRcIiwgXCJjb25jYXRNYXBcIiwgXCJjb25zdFwiLCBcImNvc1wiLCBcImNvc2hcIiwgXCJjdXJyeVwiLFxuICAgIFwiY3ljbGVcIiwgXCJkZWNvZGVGbG9hdFwiLCBcImRpdlwiLCBcImRpdk1vZFwiLCBcImRyb3BcIiwgXCJkcm9wV2hpbGVcIiwgXCJlaXRoZXJcIixcbiAgICBcImVsZW1cIiwgXCJlbmNvZGVGbG9hdFwiLCBcImVudW1Gcm9tXCIsIFwiZW51bUZyb21UaGVuXCIsIFwiZW51bUZyb21UaGVuVG9cIixcbiAgICBcImVudW1Gcm9tVG9cIiwgXCJlcnJvclwiLCBcImV2ZW5cIiwgXCJleHBcIiwgXCJleHBvbmVudFwiLCBcImZhaWxcIiwgXCJmaWx0ZXJcIixcbiAgICBcImZsaXBcIiwgXCJmbG9hdERpZ2l0c1wiLCBcImZsb2F0UmFkaXhcIiwgXCJmbG9hdFJhbmdlXCIsIFwiZmxvb3JcIiwgXCJmbWFwXCIsXG4gICAgXCJmb2xkbFwiLCBcImZvbGRsMVwiLCBcImZvbGRyXCIsIFwiZm9sZHIxXCIsIFwiZnJvbUVudW1cIiwgXCJmcm9tSW50ZWdlclwiLFxuICAgIFwiZnJvbUludGVncmFsXCIsIFwiZnJvbVJhdGlvbmFsXCIsIFwiZnN0XCIsIFwiZ2NkXCIsIFwiZ2V0Q2hhclwiLCBcImdldENvbnRlbnRzXCIsXG4gICAgXCJnZXRMaW5lXCIsIFwiaGVhZFwiLCBcImlkXCIsIFwiaW5pdFwiLCBcImludGVyYWN0XCIsIFwiaW9FcnJvclwiLCBcImlzRGVub3JtYWxpemVkXCIsXG4gICAgXCJpc0lFRUVcIiwgXCJpc0luZmluaXRlXCIsIFwiaXNOYU5cIiwgXCJpc05lZ2F0aXZlWmVyb1wiLCBcIml0ZXJhdGVcIiwgXCJsYXN0XCIsXG4gICAgXCJsY21cIiwgXCJsZW5ndGhcIiwgXCJsZXhcIiwgXCJsaW5lc1wiLCBcImxvZ1wiLCBcImxvZ0Jhc2VcIiwgXCJsb29rdXBcIiwgXCJtYXBcIixcbiAgICBcIm1hcE1cIiwgXCJtYXBNX1wiLCBcIm1heFwiLCBcIm1heEJvdW5kXCIsIFwibWF4aW11bVwiLCBcIm1heWJlXCIsIFwibWluXCIsIFwibWluQm91bmRcIixcbiAgICBcIm1pbmltdW1cIiwgXCJtb2RcIiwgXCJuZWdhdGVcIiwgXCJub3RcIiwgXCJub3RFbGVtXCIsIFwibnVsbFwiLCBcIm9kZFwiLCBcIm9yXCIsXG4gICAgXCJvdGhlcndpc2VcIiwgXCJwaVwiLCBcInByZWRcIiwgXCJwcmludFwiLCBcInByb2R1Y3RcIiwgXCJwcm9wZXJGcmFjdGlvblwiLCBcInB1cmVcIixcbiAgICBcInB1dENoYXJcIiwgXCJwdXRTdHJcIiwgXCJwdXRTdHJMblwiLCBcInF1b3RcIiwgXCJxdW90UmVtXCIsIFwicmVhZFwiLCBcInJlYWRGaWxlXCIsXG4gICAgXCJyZWFkSU9cIiwgXCJyZWFkTGlzdFwiLCBcInJlYWRMblwiLCBcInJlYWRQYXJlblwiLCBcInJlYWRzXCIsIFwicmVhZHNQcmVjXCIsXG4gICAgXCJyZWFsVG9GcmFjXCIsIFwicmVjaXBcIiwgXCJyZW1cIiwgXCJyZXBlYXRcIiwgXCJyZXBsaWNhdGVcIiwgXCJyZXR1cm5cIiwgXCJyZXZlcnNlXCIsXG4gICAgXCJyb3VuZFwiLCBcInNjYWxlRmxvYXRcIiwgXCJzY2FubFwiLCBcInNjYW5sMVwiLCBcInNjYW5yXCIsIFwic2NhbnIxXCIsIFwic2VxXCIsXG4gICAgXCJzZXF1ZW5jZVwiLCBcInNlcXVlbmNlX1wiLCBcInNob3dcIiwgXCJzaG93Q2hhclwiLCBcInNob3dMaXN0XCIsIFwic2hvd1BhcmVuXCIsXG4gICAgXCJzaG93U3RyaW5nXCIsIFwic2hvd3NcIiwgXCJzaG93c1ByZWNcIiwgXCJzaWduaWZpY2FuZFwiLCBcInNpZ251bVwiLCBcInNpblwiLFxuICAgIFwic2luaFwiLCBcInNuZFwiLCBcInNwYW5cIiwgXCJzcGxpdEF0XCIsIFwic3FydFwiLCBcInN1YnRyYWN0XCIsIFwic3VjY1wiLCBcInN1bVwiLFxuICAgIFwidGFpbFwiLCBcInRha2VcIiwgXCJ0YWtlV2hpbGVcIiwgXCJ0YW5cIiwgXCJ0YW5oXCIsIFwidG9FbnVtXCIsIFwidG9JbnRlZ2VyXCIsXG4gICAgXCJ0b1JhdGlvbmFsXCIsIFwidHJ1bmNhdGVcIiwgXCJ1bmN1cnJ5XCIsIFwidW5kZWZpbmVkXCIsIFwidW5saW5lc1wiLCBcInVudGlsXCIsXG4gICAgXCJ1bndvcmRzXCIsIFwidW56aXBcIiwgXCJ1bnppcDNcIiwgXCJ1c2VyRXJyb3JcIiwgXCJ3b3Jkc1wiLCBcIndyaXRlRmlsZVwiLCBcInppcFwiLFxuICAgIFwiemlwM1wiLCBcInppcFdpdGhcIiwgXCJ6aXBXaXRoM1wiKTtcblxuICByZXR1cm4gd2t3O1xufSkoKTtcblxuZXhwb3J0IGNvbnN0IGhhc2tlbGwgPSB7XG4gIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uICgpICB7IHJldHVybiB7IGY6IG5vcm1hbCB9OyB9LFxuICBjb3B5U3RhdGU6ICBmdW5jdGlvbiAocykgeyByZXR1cm4geyBmOiBzLmYgfTsgfSxcblxuICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciB0ID0gc3RhdGUuZihzdHJlYW0sIGZ1bmN0aW9uKHMpIHsgc3RhdGUuZiA9IHM7IH0pO1xuICAgIHZhciB3ID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICByZXR1cm4gd2VsbEtub3duV29yZHMuaGFzT3duUHJvcGVydHkodykgPyB3ZWxsS25vd25Xb3Jkc1t3XSA6IHQ7XG4gIH0sXG5cbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgY29tbWVudFRva2Vuczoge2xpbmU6IFwiLS1cIiwgYmxvY2s6IHtvcGVuOiBcInstXCIsIGNsb3NlOiBcIi19XCJ9fVxuICB9XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///389\n')}}]);