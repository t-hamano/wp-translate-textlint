(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[59],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/modelica.js":
/*!****************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/modelica.js ***!
  \****************************************************************/
/*! exports provided: modelica */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"modelica\", function() { return modelica; });\nfunction words(str) {\n  var obj = {}, words = str.split(\" \");\n  for (var i=0; i<words.length; ++i)\n    obj[words[i]] = true;\n  return obj;\n}\n\nvar keywords = words(\"algorithm and annotation assert block break class connect connector constant constrainedby der discrete each else elseif elsewhen encapsulated end enumeration equation expandable extends external false final flow for function if import impure in initial inner input loop model not operator or outer output package parameter partial protected public pure record redeclare replaceable return stream then true type when while within\")\nvar builtin = words(\"abs acos actualStream asin atan atan2 cardinality ceil cos cosh delay div edge exp floor getInstanceName homotopy inStream integer log log10 mod pre reinit rem semiLinear sign sin sinh spatialDistribution sqrt tan tanh\")\nvar atoms = words(\"Real Boolean Integer String\")\n\nvar completions = [].concat(Object.keys(keywords), Object.keys(builtin), Object.keys(atoms))\n\nvar isSingleOperatorChar = /[;=\\(:\\),{}.*<>+\\-\\/^\\[\\]]/;\nvar isDoubleOperatorChar = /(:=|<=|>=|==|<>|\\.\\+|\\.\\-|\\.\\*|\\.\\/|\\.\\^)/;\nvar isDigit = /[0-9]/;\nvar isNonDigit = /[_a-zA-Z]/;\n\nfunction tokenLineComment(stream, state) {\n  stream.skipToEnd();\n  state.tokenize = null;\n  return \"comment\";\n}\n\nfunction tokenBlockComment(stream, state) {\n  var maybeEnd = false, ch;\n  while (ch = stream.next()) {\n    if (maybeEnd && ch == \"/\") {\n      state.tokenize = null;\n      break;\n    }\n    maybeEnd = (ch == \"*\");\n  }\n  return \"comment\";\n}\n\nfunction tokenString(stream, state) {\n  var escaped = false, ch;\n  while ((ch = stream.next()) != null) {\n    if (ch == '\"' && !escaped) {\n      state.tokenize = null;\n      state.sol = false;\n      break;\n    }\n    escaped = !escaped && ch == \"\\\\\";\n  }\n\n  return \"string\";\n}\n\nfunction tokenIdent(stream, state) {\n  stream.eatWhile(isDigit);\n  while (stream.eat(isDigit) || stream.eat(isNonDigit)) { }\n\n\n  var cur = stream.current();\n\n  if(state.sol && (cur == \"package\" || cur == \"model\" || cur == \"when\" || cur == \"connector\")) state.level++;\n  else if(state.sol && cur == \"end\" && state.level > 0) state.level--;\n\n  state.tokenize = null;\n  state.sol = false;\n\n  if (keywords.propertyIsEnumerable(cur)) return \"keyword\";\n  else if (builtin.propertyIsEnumerable(cur)) return \"builtin\";\n  else if (atoms.propertyIsEnumerable(cur)) return \"atom\";\n  else return \"variable\";\n}\n\nfunction tokenQIdent(stream, state) {\n  while (stream.eat(/[^']/)) { }\n\n  state.tokenize = null;\n  state.sol = false;\n\n  if(stream.eat(\"'\"))\n    return \"variable\";\n  else\n    return \"error\";\n}\n\nfunction tokenUnsignedNumber(stream, state) {\n  stream.eatWhile(isDigit);\n  if (stream.eat('.')) {\n    stream.eatWhile(isDigit);\n  }\n  if (stream.eat('e') || stream.eat('E')) {\n    if (!stream.eat('-'))\n      stream.eat('+');\n    stream.eatWhile(isDigit);\n  }\n\n  state.tokenize = null;\n  state.sol = false;\n  return \"number\";\n}\n\n// Interface\nconst modelica = {\n  startState: function() {\n    return {\n      tokenize: null,\n      level: 0,\n      sol: true\n    };\n  },\n\n  token: function(stream, state) {\n    if(state.tokenize != null) {\n      return state.tokenize(stream, state);\n    }\n\n    if(stream.sol()) {\n      state.sol = true;\n    }\n\n    // WHITESPACE\n    if(stream.eatSpace()) {\n      state.tokenize = null;\n      return null;\n    }\n\n    var ch = stream.next();\n\n    // LINECOMMENT\n    if(ch == '/' && stream.eat('/')) {\n      state.tokenize = tokenLineComment;\n    }\n    // BLOCKCOMMENT\n    else if(ch == '/' && stream.eat('*')) {\n      state.tokenize = tokenBlockComment;\n    }\n    // TWO SYMBOL TOKENS\n    else if(isDoubleOperatorChar.test(ch+stream.peek())) {\n      stream.next();\n      state.tokenize = null;\n      return \"operator\";\n    }\n    // SINGLE SYMBOL TOKENS\n    else if(isSingleOperatorChar.test(ch)) {\n      state.tokenize = null;\n      return \"operator\";\n    }\n    // IDENT\n    else if(isNonDigit.test(ch)) {\n      state.tokenize = tokenIdent;\n    }\n    // Q-IDENT\n    else if(ch == \"'\" && stream.peek() && stream.peek() != \"'\") {\n      state.tokenize = tokenQIdent;\n    }\n    // STRING\n    else if(ch == '\"') {\n      state.tokenize = tokenString;\n    }\n    // UNSIGNED_NUMBER\n    else if(isDigit.test(ch)) {\n      state.tokenize = tokenUnsignedNumber;\n    }\n    // ERROR\n    else {\n      state.tokenize = null;\n      return \"error\";\n    }\n\n    return state.tokenize(stream, state);\n  },\n\n  indent: function(state, textAfter, cx) {\n    if (state.tokenize != null) return null;\n\n    var level = state.level;\n    if(/(algorithm)/.test(textAfter)) level--;\n    if(/(equation)/.test(textAfter)) level--;\n    if(/(initial algorithm)/.test(textAfter)) level--;\n    if(/(initial equation)/.test(textAfter)) level--;\n    if(/(end)/.test(textAfter)) level--;\n\n    if(level > 0)\n      return cx.unit*level;\n    else\n      return 0;\n  },\n\n  languageData: {\n    commentTokens: {line: \"//\", block: {open: \"/*\", close: \"*/\"}},\n    autocomplete: completions\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvbW9kZWxpY2EuanM/ZGZmOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQSxjQUFjO0FBQ2QsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4QkFBOEIsU0FBUztBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUF5RDs7O0FBR3pEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLG9CQUFvQixvQkFBb0IseUJBQXlCO0FBQ2pFO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS9tb2RlbGljYS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHdvcmRzKHN0cikge1xuICB2YXIgb2JqID0ge30sIHdvcmRzID0gc3RyLnNwbGl0KFwiIFwiKTtcbiAgZm9yICh2YXIgaT0wOyBpPHdvcmRzLmxlbmd0aDsgKytpKVxuICAgIG9ialt3b3Jkc1tpXV0gPSB0cnVlO1xuICByZXR1cm4gb2JqO1xufVxuXG52YXIga2V5d29yZHMgPSB3b3JkcyhcImFsZ29yaXRobSBhbmQgYW5ub3RhdGlvbiBhc3NlcnQgYmxvY2sgYnJlYWsgY2xhc3MgY29ubmVjdCBjb25uZWN0b3IgY29uc3RhbnQgY29uc3RyYWluZWRieSBkZXIgZGlzY3JldGUgZWFjaCBlbHNlIGVsc2VpZiBlbHNld2hlbiBlbmNhcHN1bGF0ZWQgZW5kIGVudW1lcmF0aW9uIGVxdWF0aW9uIGV4cGFuZGFibGUgZXh0ZW5kcyBleHRlcm5hbCBmYWxzZSBmaW5hbCBmbG93IGZvciBmdW5jdGlvbiBpZiBpbXBvcnQgaW1wdXJlIGluIGluaXRpYWwgaW5uZXIgaW5wdXQgbG9vcCBtb2RlbCBub3Qgb3BlcmF0b3Igb3Igb3V0ZXIgb3V0cHV0IHBhY2thZ2UgcGFyYW1ldGVyIHBhcnRpYWwgcHJvdGVjdGVkIHB1YmxpYyBwdXJlIHJlY29yZCByZWRlY2xhcmUgcmVwbGFjZWFibGUgcmV0dXJuIHN0cmVhbSB0aGVuIHRydWUgdHlwZSB3aGVuIHdoaWxlIHdpdGhpblwiKVxudmFyIGJ1aWx0aW4gPSB3b3JkcyhcImFicyBhY29zIGFjdHVhbFN0cmVhbSBhc2luIGF0YW4gYXRhbjIgY2FyZGluYWxpdHkgY2VpbCBjb3MgY29zaCBkZWxheSBkaXYgZWRnZSBleHAgZmxvb3IgZ2V0SW5zdGFuY2VOYW1lIGhvbW90b3B5IGluU3RyZWFtIGludGVnZXIgbG9nIGxvZzEwIG1vZCBwcmUgcmVpbml0IHJlbSBzZW1pTGluZWFyIHNpZ24gc2luIHNpbmggc3BhdGlhbERpc3RyaWJ1dGlvbiBzcXJ0IHRhbiB0YW5oXCIpXG52YXIgYXRvbXMgPSB3b3JkcyhcIlJlYWwgQm9vbGVhbiBJbnRlZ2VyIFN0cmluZ1wiKVxuXG52YXIgY29tcGxldGlvbnMgPSBbXS5jb25jYXQoT2JqZWN0LmtleXMoa2V5d29yZHMpLCBPYmplY3Qua2V5cyhidWlsdGluKSwgT2JqZWN0LmtleXMoYXRvbXMpKVxuXG52YXIgaXNTaW5nbGVPcGVyYXRvckNoYXIgPSAvWzs9XFwoOlxcKSx7fS4qPD4rXFwtXFwvXlxcW1xcXV0vO1xudmFyIGlzRG91YmxlT3BlcmF0b3JDaGFyID0gLyg6PXw8PXw+PXw9PXw8PnxcXC5cXCt8XFwuXFwtfFxcLlxcKnxcXC5cXC98XFwuXFxeKS87XG52YXIgaXNEaWdpdCA9IC9bMC05XS87XG52YXIgaXNOb25EaWdpdCA9IC9bX2EtekEtWl0vO1xuXG5mdW5jdGlvbiB0b2tlbkxpbmVDb21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gIHJldHVybiBcImNvbW1lbnRcIjtcbn1cblxuZnVuY3Rpb24gdG9rZW5CbG9ja0NvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbWF5YmVFbmQgPSBmYWxzZSwgY2g7XG4gIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICBpZiAobWF5YmVFbmQgJiYgY2ggPT0gXCIvXCIpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBtYXliZUVuZCA9IChjaCA9PSBcIipcIik7XG4gIH1cbiAgcmV0dXJuIFwiY29tbWVudFwiO1xufVxuXG5mdW5jdGlvbiB0b2tlblN0cmluZyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBlc2NhcGVkID0gZmFsc2UsIGNoO1xuICB3aGlsZSAoKGNoID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgIGlmIChjaCA9PSAnXCInICYmICFlc2NhcGVkKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgICBzdGF0ZS5zb2wgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgY2ggPT0gXCJcXFxcXCI7XG4gIH1cblxuICByZXR1cm4gXCJzdHJpbmdcIjtcbn1cblxuZnVuY3Rpb24gdG9rZW5JZGVudChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5lYXRXaGlsZShpc0RpZ2l0KTtcbiAgd2hpbGUgKHN0cmVhbS5lYXQoaXNEaWdpdCkgfHwgc3RyZWFtLmVhdChpc05vbkRpZ2l0KSkgeyB9XG5cblxuICB2YXIgY3VyID0gc3RyZWFtLmN1cnJlbnQoKTtcblxuICBpZihzdGF0ZS5zb2wgJiYgKGN1ciA9PSBcInBhY2thZ2VcIiB8fCBjdXIgPT0gXCJtb2RlbFwiIHx8IGN1ciA9PSBcIndoZW5cIiB8fCBjdXIgPT0gXCJjb25uZWN0b3JcIikpIHN0YXRlLmxldmVsKys7XG4gIGVsc2UgaWYoc3RhdGUuc29sICYmIGN1ciA9PSBcImVuZFwiICYmIHN0YXRlLmxldmVsID4gMCkgc3RhdGUubGV2ZWwtLTtcblxuICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gIHN0YXRlLnNvbCA9IGZhbHNlO1xuXG4gIGlmIChrZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSByZXR1cm4gXCJrZXl3b3JkXCI7XG4gIGVsc2UgaWYgKGJ1aWx0aW4ucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkgcmV0dXJuIFwiYnVpbHRpblwiO1xuICBlbHNlIGlmIChhdG9tcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSByZXR1cm4gXCJhdG9tXCI7XG4gIGVsc2UgcmV0dXJuIFwidmFyaWFibGVcIjtcbn1cblxuZnVuY3Rpb24gdG9rZW5RSWRlbnQoc3RyZWFtLCBzdGF0ZSkge1xuICB3aGlsZSAoc3RyZWFtLmVhdCgvW14nXS8pKSB7IH1cblxuICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gIHN0YXRlLnNvbCA9IGZhbHNlO1xuXG4gIGlmKHN0cmVhbS5lYXQoXCInXCIpKVxuICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gIGVsc2VcbiAgICByZXR1cm4gXCJlcnJvclwiO1xufVxuXG5mdW5jdGlvbiB0b2tlblVuc2lnbmVkTnVtYmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLmVhdFdoaWxlKGlzRGlnaXQpO1xuICBpZiAoc3RyZWFtLmVhdCgnLicpKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKGlzRGlnaXQpO1xuICB9XG4gIGlmIChzdHJlYW0uZWF0KCdlJykgfHwgc3RyZWFtLmVhdCgnRScpKSB7XG4gICAgaWYgKCFzdHJlYW0uZWF0KCctJykpXG4gICAgICBzdHJlYW0uZWF0KCcrJyk7XG4gICAgc3RyZWFtLmVhdFdoaWxlKGlzRGlnaXQpO1xuICB9XG5cbiAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICBzdGF0ZS5zb2wgPSBmYWxzZTtcbiAgcmV0dXJuIFwibnVtYmVyXCI7XG59XG5cbi8vIEludGVyZmFjZVxuZXhwb3J0IGNvbnN0IG1vZGVsaWNhID0ge1xuICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5pemU6IG51bGwsXG4gICAgICBsZXZlbDogMCxcbiAgICAgIHNvbDogdHJ1ZVxuICAgIH07XG4gIH0sXG5cbiAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZihzdGF0ZS50b2tlbml6ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYoc3RyZWFtLnNvbCgpKSB7XG4gICAgICBzdGF0ZS5zb2wgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIFdISVRFU1BBQ0VcbiAgICBpZihzdHJlYW0uZWF0U3BhY2UoKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcblxuICAgIC8vIExJTkVDT01NRU5UXG4gICAgaWYoY2ggPT0gJy8nICYmIHN0cmVhbS5lYXQoJy8nKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkxpbmVDb21tZW50O1xuICAgIH1cbiAgICAvLyBCTE9DS0NPTU1FTlRcbiAgICBlbHNlIGlmKGNoID09ICcvJyAmJiBzdHJlYW0uZWF0KCcqJykpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CbG9ja0NvbW1lbnQ7XG4gICAgfVxuICAgIC8vIFRXTyBTWU1CT0wgVE9LRU5TXG4gICAgZWxzZSBpZihpc0RvdWJsZU9wZXJhdG9yQ2hhci50ZXN0KGNoK3N0cmVhbS5wZWVrKCkpKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICB9XG4gICAgLy8gU0lOR0xFIFNZTUJPTCBUT0tFTlNcbiAgICBlbHNlIGlmKGlzU2luZ2xlT3BlcmF0b3JDaGFyLnRlc3QoY2gpKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgIH1cbiAgICAvLyBJREVOVFxuICAgIGVsc2UgaWYoaXNOb25EaWdpdC50ZXN0KGNoKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbklkZW50O1xuICAgIH1cbiAgICAvLyBRLUlERU5UXG4gICAgZWxzZSBpZihjaCA9PSBcIidcIiAmJiBzdHJlYW0ucGVlaygpICYmIHN0cmVhbS5wZWVrKCkgIT0gXCInXCIpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5RSWRlbnQ7XG4gICAgfVxuICAgIC8vIFNUUklOR1xuICAgIGVsc2UgaWYoY2ggPT0gJ1wiJykge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZztcbiAgICB9XG4gICAgLy8gVU5TSUdORURfTlVNQkVSXG4gICAgZWxzZSBpZihpc0RpZ2l0LnRlc3QoY2gpKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuVW5zaWduZWROdW1iZXI7XG4gICAgfVxuICAgIC8vIEVSUk9SXG4gICAgZWxzZSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgICByZXR1cm4gXCJlcnJvclwiO1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgfSxcblxuICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIsIGN4KSB7XG4gICAgaWYgKHN0YXRlLnRva2VuaXplICE9IG51bGwpIHJldHVybiBudWxsO1xuXG4gICAgdmFyIGxldmVsID0gc3RhdGUubGV2ZWw7XG4gICAgaWYoLyhhbGdvcml0aG0pLy50ZXN0KHRleHRBZnRlcikpIGxldmVsLS07XG4gICAgaWYoLyhlcXVhdGlvbikvLnRlc3QodGV4dEFmdGVyKSkgbGV2ZWwtLTtcbiAgICBpZigvKGluaXRpYWwgYWxnb3JpdGhtKS8udGVzdCh0ZXh0QWZ0ZXIpKSBsZXZlbC0tO1xuICAgIGlmKC8oaW5pdGlhbCBlcXVhdGlvbikvLnRlc3QodGV4dEFmdGVyKSkgbGV2ZWwtLTtcbiAgICBpZigvKGVuZCkvLnRlc3QodGV4dEFmdGVyKSkgbGV2ZWwtLTtcblxuICAgIGlmKGxldmVsID4gMClcbiAgICAgIHJldHVybiBjeC51bml0KmxldmVsO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiAwO1xuICB9LFxuXG4gIGxhbmd1YWdlRGF0YToge1xuICAgIGNvbW1lbnRUb2tlbnM6IHtsaW5lOiBcIi8vXCIsIGJsb2NrOiB7b3BlbjogXCIvKlwiLCBjbG9zZTogXCIqL1wifX0sXG4gICAgYXV0b2NvbXBsZXRlOiBjb21wbGV0aW9uc1xuICB9XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/legacy-modes/mode/modelica.js\n");

/***/ })

}]);