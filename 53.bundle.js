(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[53],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/julia.js":
/*!*************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/julia.js ***!
  \*************************************************************/
/*! exports provided: julia */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"julia\", function() { return julia; });\nfunction wordRegexp(words, end, pre) {\n  if (typeof pre === \"undefined\") pre = \"\";\n  if (typeof end === \"undefined\") { end = \"\\\\b\"; }\n  return new RegExp(\"^\" + pre + \"((\" + words.join(\")|(\") + \"))\" + end);\n}\n\nvar octChar = \"\\\\\\\\[0-7]{1,3}\";\nvar hexChar = \"\\\\\\\\x[A-Fa-f0-9]{1,2}\";\nvar sChar = \"\\\\\\\\[abefnrtv0%?'\\\"\\\\\\\\]\";\nvar uChar = \"([^\\\\u0027\\\\u005C\\\\uD800-\\\\uDFFF]|[\\\\uD800-\\\\uDFFF][\\\\uDC00-\\\\uDFFF])\";\n\nvar asciiOperatorsList = [\n  \"[<>]:\", \"[<>=]=\", \"<<=?\", \">>>?=?\", \"=>\", \"--?>\", \"<--[->]?\", \"\\\\/\\\\/\",\n  \"\\\\.{2,3}\", \"[\\\\.\\\\\\\\%*+\\\\-<>!\\\\/^|&]=?\", \"\\\\?\", \"\\\\$\", \"~\", \":\"\n];\nvar operators = wordRegexp([\n  \"[<>]:\", \"[<>=]=\", \"[!=]==\", \"<<=?\", \">>>?=?\", \"=>?\", \"--?>\", \"<--[->]?\", \"\\\\/\\\\/\",\n  \"[\\\\\\\\%*+\\\\-<>!\\\\/^|&\\\\u00F7\\\\u22BB]=?\", \"\\\\?\", \"\\\\$\", \"~\", \":\",\n  \"\\\\u00D7\", \"\\\\u2208\", \"\\\\u2209\", \"\\\\u220B\", \"\\\\u220C\", \"\\\\u2218\",\n  \"\\\\u221A\", \"\\\\u221B\", \"\\\\u2229\", \"\\\\u222A\", \"\\\\u2260\", \"\\\\u2264\",\n  \"\\\\u2265\", \"\\\\u2286\", \"\\\\u2288\", \"\\\\u228A\", \"\\\\u22C5\",\n  \"\\\\b(in|isa)\\\\b(?!\\.?\\\\()\"\n], \"\");\nvar delimiters = /^[;,()[\\]{}]/;\nvar identifiers = /^[_A-Za-z\\u00A1-\\u2217\\u2219-\\uFFFF][\\w\\u00A1-\\u2217\\u2219-\\uFFFF]*!*/;\n\nvar chars = wordRegexp([octChar, hexChar, sChar, uChar], \"'\");\n\nvar openersList = [\"begin\", \"function\", \"type\", \"struct\", \"immutable\", \"let\",\n                   \"macro\", \"for\", \"while\", \"quote\", \"if\", \"else\", \"elseif\", \"try\",\n                   \"finally\", \"catch\", \"do\"];\n\nvar closersList = [\"end\", \"else\", \"elseif\", \"catch\", \"finally\"];\n\nvar keywordsList = [\"if\", \"else\", \"elseif\", \"while\", \"for\", \"begin\", \"let\",\n                    \"end\", \"do\", \"try\", \"catch\", \"finally\", \"return\", \"break\", \"continue\",\n                    \"global\", \"local\", \"const\", \"export\", \"import\", \"importall\", \"using\",\n                    \"function\", \"where\", \"macro\", \"module\", \"baremodule\", \"struct\", \"type\",\n                    \"mutable\", \"immutable\", \"quote\", \"typealias\", \"abstract\", \"primitive\",\n                    \"bitstype\"];\n\nvar builtinsList = [\"true\", \"false\", \"nothing\", \"NaN\", \"Inf\"];\n\nvar openers = wordRegexp(openersList);\nvar closers = wordRegexp(closersList);\nvar keywords = wordRegexp(keywordsList);\nvar builtins = wordRegexp(builtinsList);\n\nvar macro = /^@[_A-Za-z\\u00A1-\\uFFFF][\\w\\u00A1-\\uFFFF]*!*/;\nvar symbol = /^:[_A-Za-z\\u00A1-\\uFFFF][\\w\\u00A1-\\uFFFF]*!*/;\nvar stringPrefixes = /^(`|([_A-Za-z\\u00A1-\\uFFFF]*\"(\"\")?))/;\n\nvar macroOperators = wordRegexp(asciiOperatorsList, \"\", \"@\");\nvar symbolOperators = wordRegexp(asciiOperatorsList, \"\", \":\");\n\nfunction inArray(state) {\n  return (state.nestedArrays > 0);\n}\n\nfunction inGenerator(state) {\n  return (state.nestedGenerators > 0);\n}\n\nfunction currentScope(state, n) {\n  if (typeof(n) === \"undefined\") { n = 0; }\n  if (state.scopes.length <= n) {\n    return null;\n  }\n  return state.scopes[state.scopes.length - (n + 1)];\n}\n\n// tokenizers\nfunction tokenBase(stream, state) {\n  // Handle multiline comments\n  if (stream.match('#=', false)) {\n    state.tokenize = tokenComment;\n    return state.tokenize(stream, state);\n  }\n\n  // Handle scope changes\n  var leavingExpr = state.leavingExpr;\n  if (stream.sol()) {\n    leavingExpr = false;\n  }\n  state.leavingExpr = false;\n\n  if (leavingExpr) {\n    if (stream.match(/^'+/)) {\n      return \"operator\";\n    }\n  }\n\n  if (stream.match(/\\.{4,}/)) {\n    return \"error\";\n  } else if (stream.match(/\\.{1,3}/)) {\n    return \"operator\";\n  }\n\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  var ch = stream.peek();\n\n  // Handle single line comments\n  if (ch === '#') {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  if (ch === '[') {\n    state.scopes.push('[');\n    state.nestedArrays++;\n  }\n\n  if (ch === '(') {\n    state.scopes.push('(');\n    state.nestedGenerators++;\n  }\n\n  if (inArray(state) && ch === ']') {\n    while (state.scopes.length && currentScope(state) !== \"[\") { state.scopes.pop(); }\n    state.scopes.pop();\n    state.nestedArrays--;\n    state.leavingExpr = true;\n  }\n\n  if (inGenerator(state) && ch === ')') {\n    while (state.scopes.length && currentScope(state) !== \"(\") { state.scopes.pop(); }\n    state.scopes.pop();\n    state.nestedGenerators--;\n    state.leavingExpr = true;\n  }\n\n  if (inArray(state)) {\n    if (state.lastToken == \"end\" && stream.match(':')) {\n      return \"operator\";\n    }\n    if (stream.match('end')) {\n      return \"number\";\n    }\n  }\n\n  var match;\n  if (match = stream.match(openers, false)) {\n    state.scopes.push(match[0]);\n  }\n\n  if (stream.match(closers, false)) {\n    state.scopes.pop();\n  }\n\n  // Handle type annotations\n  if (stream.match(/^::(?![:\\$])/)) {\n    state.tokenize = tokenAnnotation;\n    return state.tokenize(stream, state);\n  }\n\n  // Handle symbols\n  if (!leavingExpr && (stream.match(symbol) || stream.match(symbolOperators))) {\n    return \"builtin\";\n  }\n\n  // Handle parametric types\n  //if (stream.match(/^{[^}]*}(?=\\()/)) {\n  //  return \"builtin\";\n  //}\n\n  // Handle operators and Delimiters\n  if (stream.match(operators)) {\n    return \"operator\";\n  }\n\n  // Handle Number Literals\n  if (stream.match(/^\\.?\\d/, false)) {\n    var imMatcher = RegExp(/^im\\b/);\n    var numberLiteral = false;\n    if (stream.match(/^0x\\.[0-9a-f_]+p[\\+\\-]?[_\\d]+/i)) { numberLiteral = true; }\n    // Integers\n    if (stream.match(/^0x[0-9a-f_]+/i)) { numberLiteral = true; } // Hex\n    if (stream.match(/^0b[01_]+/i)) { numberLiteral = true; } // Binary\n    if (stream.match(/^0o[0-7_]+/i)) { numberLiteral = true; } // Octal\n    // Floats\n    if (stream.match(/^(?:(?:\\d[_\\d]*)?\\.(?!\\.)(?:\\d[_\\d]*)?|\\d[_\\d]*\\.(?!\\.)(?:\\d[_\\d]*))?([Eef][\\+\\-]?[_\\d]+)?/i)) { numberLiteral = true; }\n    if (stream.match(/^\\d[_\\d]*(e[\\+\\-]?\\d+)?/i)) { numberLiteral = true; } // Decimal\n    if (numberLiteral) {\n      // Integer literals may be \"long\"\n      stream.match(imMatcher);\n      state.leavingExpr = true;\n      return \"number\";\n    }\n  }\n\n  // Handle Chars\n  if (stream.match(\"'\")) {\n    state.tokenize = tokenChar;\n    return state.tokenize(stream, state);\n  }\n\n  // Handle Strings\n  if (stream.match(stringPrefixes)) {\n    state.tokenize = tokenStringFactory(stream.current());\n    return state.tokenize(stream, state);\n  }\n\n  if (stream.match(macro) || stream.match(macroOperators)) {\n    return \"meta\";\n  }\n\n  if (stream.match(delimiters)) {\n    return null;\n  }\n\n  if (stream.match(keywords)) {\n    return \"keyword\";\n  }\n\n  if (stream.match(builtins)) {\n    return \"builtin\";\n  }\n\n  var isDefinition = state.isDefinition || state.lastToken == \"function\" ||\n      state.lastToken == \"macro\" || state.lastToken == \"type\" ||\n      state.lastToken == \"struct\" || state.lastToken == \"immutable\";\n\n  if (stream.match(identifiers)) {\n    if (isDefinition) {\n      if (stream.peek() === '.') {\n        state.isDefinition = true;\n        return \"variable\";\n      }\n      state.isDefinition = false;\n      return \"def\";\n    }\n    state.leavingExpr = true;\n    return \"variable\";\n  }\n\n  // Handle non-detected items\n  stream.next();\n  return \"error\";\n}\n\nfunction tokenAnnotation(stream, state) {\n  stream.match(/.*?(?=[,;{}()=\\s]|$)/);\n  if (stream.match('{')) {\n    state.nestedParameters++;\n  } else if (stream.match('}') && state.nestedParameters > 0) {\n    state.nestedParameters--;\n  }\n  if (state.nestedParameters > 0) {\n    stream.match(/.*?(?={|})/) || stream.next();\n  } else if (state.nestedParameters == 0) {\n    state.tokenize = tokenBase;\n  }\n  return \"builtin\";\n}\n\nfunction tokenComment(stream, state) {\n  if (stream.match('#=')) {\n    state.nestedComments++;\n  }\n  if (!stream.match(/.*?(?=(#=|=#))/)) {\n    stream.skipToEnd();\n  }\n  if (stream.match('=#')) {\n    state.nestedComments--;\n    if (state.nestedComments == 0)\n      state.tokenize = tokenBase;\n  }\n  return \"comment\";\n}\n\nfunction tokenChar(stream, state) {\n  var isChar = false, match;\n  if (stream.match(chars)) {\n    isChar = true;\n  } else if (match = stream.match(/\\\\u([a-f0-9]{1,4})(?=')/i)) {\n    var value = parseInt(match[1], 16);\n    if (value <= 55295 || value >= 57344) { // (U+0,U+D7FF), (U+E000,U+FFFF)\n      isChar = true;\n      stream.next();\n    }\n  } else if (match = stream.match(/\\\\U([A-Fa-f0-9]{5,8})(?=')/)) {\n    var value = parseInt(match[1], 16);\n    if (value <= 1114111) { // U+10FFFF\n      isChar = true;\n      stream.next();\n    }\n  }\n  if (isChar) {\n    state.leavingExpr = true;\n    state.tokenize = tokenBase;\n    return \"string\";\n  }\n  if (!stream.match(/^[^']+(?=')/)) { stream.skipToEnd(); }\n  if (stream.match(\"'\")) { state.tokenize = tokenBase; }\n  return \"error\";\n}\n\nfunction tokenStringFactory(delimiter) {\n  if (delimiter.substr(-3) === '\"\"\"') {\n    delimiter = '\"\"\"';\n  } else if (delimiter.substr(-1) === '\"') {\n    delimiter = '\"';\n  }\n  function tokenString(stream, state) {\n    if (stream.eat('\\\\')) {\n      stream.next();\n    } else if (stream.match(delimiter)) {\n      state.tokenize = tokenBase;\n      state.leavingExpr = true;\n      return \"string\";\n    } else {\n      stream.eat(/[`\"]/);\n    }\n    stream.eatWhile(/[^\\\\`\"]/);\n    return \"string\";\n  }\n  return tokenString;\n}\n\nconst julia = {\n  startState: function() {\n    return {\n      tokenize: tokenBase,\n      scopes: [],\n      lastToken: null,\n      leavingExpr: false,\n      isDefinition: false,\n      nestedArrays: 0,\n      nestedComments: 0,\n      nestedGenerators: 0,\n      nestedParameters: 0,\n      firstParenPos: -1\n    };\n  },\n\n  token: function(stream, state) {\n    var style = state.tokenize(stream, state);\n    var current = stream.current();\n\n    if (current && style) {\n      state.lastToken = current;\n    }\n\n    return style;\n  },\n\n  indent: function(state, textAfter, cx) {\n    var delta = 0;\n    if ( textAfter === ']' || textAfter === ')' || /^end\\b/.test(textAfter) ||\n         /^else/.test(textAfter) || /^catch\\b/.test(textAfter) || /^elseif\\b/.test(textAfter) ||\n         /^finally/.test(textAfter) ) {\n      delta = -1;\n    }\n    return (state.scopes.length + delta) * cx.unit;\n  },\n\n  languageData: {\n    indentOnInput: /^\\s*(end|else|catch|finally)\\b$/,\n    commentTokens: {line: \"#\", block: {open: \"#=\", close: \"=#\"}},\n    closeBrackets: {brackets: [\"(\", \"[\", \"{\", '\"']},\n    autocomplete: keywordsList.concat(builtinsList)\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvanVsaWEuanM/MjM2MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hEO0FBQ0E7O0FBRUEseUJBQXlCLElBQUk7QUFDN0IsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTyxJQUFJO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsR0FBRztBQUMxQjtBQUNBLEdBQUcsMkJBQTJCLElBQUk7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdFQUFnRSxvQkFBb0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnRUFBZ0Usb0JBQW9CO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsR0FBRyxHQUFHO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsc0JBQXNCO0FBQy9FO0FBQ0EseUNBQXlDLHNCQUFzQixFQUFFO0FBQ2pFLHFDQUFxQyxzQkFBc0IsRUFBRTtBQUM3RCxzQ0FBc0Msc0JBQXNCLEVBQUU7QUFDOUQ7QUFDQSxzSEFBc0gsc0JBQXNCO0FBQzVJLG1EQUFtRCxzQkFBc0IsRUFBRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0IscUJBQXFCO0FBQ3JCO0FBQ0EsR0FBRyx5QkFBeUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEVBQUU7QUFDM0IsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDZDQUE2QyxJQUFJO0FBQ3BEO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZ0RBQWdELElBQUk7QUFDdkQ7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG9CQUFvQjtBQUN6RCwwQkFBMEIsNEJBQTRCO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CLHlCQUF5QjtBQUNoRSxvQkFBb0IsdUJBQXVCLFFBQVE7QUFDbkQ7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xlZ2FjeS1tb2Rlcy9tb2RlL2p1bGlhLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gd29yZFJlZ2V4cCh3b3JkcywgZW5kLCBwcmUpIHtcbiAgaWYgKHR5cGVvZiBwcmUgPT09IFwidW5kZWZpbmVkXCIpIHByZSA9IFwiXCI7XG4gIGlmICh0eXBlb2YgZW5kID09PSBcInVuZGVmaW5lZFwiKSB7IGVuZCA9IFwiXFxcXGJcIjsgfVxuICByZXR1cm4gbmV3IFJlZ0V4cChcIl5cIiArIHByZSArIFwiKChcIiArIHdvcmRzLmpvaW4oXCIpfChcIikgKyBcIikpXCIgKyBlbmQpO1xufVxuXG52YXIgb2N0Q2hhciA9IFwiXFxcXFxcXFxbMC03XXsxLDN9XCI7XG52YXIgaGV4Q2hhciA9IFwiXFxcXFxcXFx4W0EtRmEtZjAtOV17MSwyfVwiO1xudmFyIHNDaGFyID0gXCJcXFxcXFxcXFthYmVmbnJ0djAlPydcXFwiXFxcXFxcXFxdXCI7XG52YXIgdUNoYXIgPSBcIihbXlxcXFx1MDAyN1xcXFx1MDA1Q1xcXFx1RDgwMC1cXFxcdURGRkZdfFtcXFxcdUQ4MDAtXFxcXHVERkZGXVtcXFxcdURDMDAtXFxcXHVERkZGXSlcIjtcblxudmFyIGFzY2lpT3BlcmF0b3JzTGlzdCA9IFtcbiAgXCJbPD5dOlwiLCBcIls8Pj1dPVwiLCBcIjw8PT9cIiwgXCI+Pj4/PT9cIiwgXCI9PlwiLCBcIi0tPz5cIiwgXCI8LS1bLT5dP1wiLCBcIlxcXFwvXFxcXC9cIixcbiAgXCJcXFxcLnsyLDN9XCIsIFwiW1xcXFwuXFxcXFxcXFwlKitcXFxcLTw+IVxcXFwvXnwmXT0/XCIsIFwiXFxcXD9cIiwgXCJcXFxcJFwiLCBcIn5cIiwgXCI6XCJcbl07XG52YXIgb3BlcmF0b3JzID0gd29yZFJlZ2V4cChbXG4gIFwiWzw+XTpcIiwgXCJbPD49XT1cIiwgXCJbIT1dPT1cIiwgXCI8PD0/XCIsIFwiPj4+Pz0/XCIsIFwiPT4/XCIsIFwiLS0/PlwiLCBcIjwtLVstPl0/XCIsIFwiXFxcXC9cXFxcL1wiLFxuICBcIltcXFxcXFxcXCUqK1xcXFwtPD4hXFxcXC9efCZcXFxcdTAwRjdcXFxcdTIyQkJdPT9cIiwgXCJcXFxcP1wiLCBcIlxcXFwkXCIsIFwiflwiLCBcIjpcIixcbiAgXCJcXFxcdTAwRDdcIiwgXCJcXFxcdTIyMDhcIiwgXCJcXFxcdTIyMDlcIiwgXCJcXFxcdTIyMEJcIiwgXCJcXFxcdTIyMENcIiwgXCJcXFxcdTIyMThcIixcbiAgXCJcXFxcdTIyMUFcIiwgXCJcXFxcdTIyMUJcIiwgXCJcXFxcdTIyMjlcIiwgXCJcXFxcdTIyMkFcIiwgXCJcXFxcdTIyNjBcIiwgXCJcXFxcdTIyNjRcIixcbiAgXCJcXFxcdTIyNjVcIiwgXCJcXFxcdTIyODZcIiwgXCJcXFxcdTIyODhcIiwgXCJcXFxcdTIyOEFcIiwgXCJcXFxcdTIyQzVcIixcbiAgXCJcXFxcYihpbnxpc2EpXFxcXGIoPyFcXC4/XFxcXCgpXCJcbl0sIFwiXCIpO1xudmFyIGRlbGltaXRlcnMgPSAvXls7LCgpW1xcXXt9XS87XG52YXIgaWRlbnRpZmllcnMgPSAvXltfQS1aYS16XFx1MDBBMS1cXHUyMjE3XFx1MjIxOS1cXHVGRkZGXVtcXHdcXHUwMEExLVxcdTIyMTdcXHUyMjE5LVxcdUZGRkZdKiEqLztcblxudmFyIGNoYXJzID0gd29yZFJlZ2V4cChbb2N0Q2hhciwgaGV4Q2hhciwgc0NoYXIsIHVDaGFyXSwgXCInXCIpO1xuXG52YXIgb3BlbmVyc0xpc3QgPSBbXCJiZWdpblwiLCBcImZ1bmN0aW9uXCIsIFwidHlwZVwiLCBcInN0cnVjdFwiLCBcImltbXV0YWJsZVwiLCBcImxldFwiLFxuICAgICAgICAgICAgICAgICAgIFwibWFjcm9cIiwgXCJmb3JcIiwgXCJ3aGlsZVwiLCBcInF1b3RlXCIsIFwiaWZcIiwgXCJlbHNlXCIsIFwiZWxzZWlmXCIsIFwidHJ5XCIsXG4gICAgICAgICAgICAgICAgICAgXCJmaW5hbGx5XCIsIFwiY2F0Y2hcIiwgXCJkb1wiXTtcblxudmFyIGNsb3NlcnNMaXN0ID0gW1wiZW5kXCIsIFwiZWxzZVwiLCBcImVsc2VpZlwiLCBcImNhdGNoXCIsIFwiZmluYWxseVwiXTtcblxudmFyIGtleXdvcmRzTGlzdCA9IFtcImlmXCIsIFwiZWxzZVwiLCBcImVsc2VpZlwiLCBcIndoaWxlXCIsIFwiZm9yXCIsIFwiYmVnaW5cIiwgXCJsZXRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJlbmRcIiwgXCJkb1wiLCBcInRyeVwiLCBcImNhdGNoXCIsIFwiZmluYWxseVwiLCBcInJldHVyblwiLCBcImJyZWFrXCIsIFwiY29udGludWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJnbG9iYWxcIiwgXCJsb2NhbFwiLCBcImNvbnN0XCIsIFwiZXhwb3J0XCIsIFwiaW1wb3J0XCIsIFwiaW1wb3J0YWxsXCIsIFwidXNpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiLCBcIndoZXJlXCIsIFwibWFjcm9cIiwgXCJtb2R1bGVcIiwgXCJiYXJlbW9kdWxlXCIsIFwic3RydWN0XCIsIFwidHlwZVwiLFxuICAgICAgICAgICAgICAgICAgICBcIm11dGFibGVcIiwgXCJpbW11dGFibGVcIiwgXCJxdW90ZVwiLCBcInR5cGVhbGlhc1wiLCBcImFic3RyYWN0XCIsIFwicHJpbWl0aXZlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYml0c3R5cGVcIl07XG5cbnZhciBidWlsdGluc0xpc3QgPSBbXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJub3RoaW5nXCIsIFwiTmFOXCIsIFwiSW5mXCJdO1xuXG52YXIgb3BlbmVycyA9IHdvcmRSZWdleHAob3BlbmVyc0xpc3QpO1xudmFyIGNsb3NlcnMgPSB3b3JkUmVnZXhwKGNsb3NlcnNMaXN0KTtcbnZhciBrZXl3b3JkcyA9IHdvcmRSZWdleHAoa2V5d29yZHNMaXN0KTtcbnZhciBidWlsdGlucyA9IHdvcmRSZWdleHAoYnVpbHRpbnNMaXN0KTtcblxudmFyIG1hY3JvID0gL15AW19BLVphLXpcXHUwMEExLVxcdUZGRkZdW1xcd1xcdTAwQTEtXFx1RkZGRl0qISovO1xudmFyIHN5bWJvbCA9IC9eOltfQS1aYS16XFx1MDBBMS1cXHVGRkZGXVtcXHdcXHUwMEExLVxcdUZGRkZdKiEqLztcbnZhciBzdHJpbmdQcmVmaXhlcyA9IC9eKGB8KFtfQS1aYS16XFx1MDBBMS1cXHVGRkZGXSpcIihcIlwiKT8pKS87XG5cbnZhciBtYWNyb09wZXJhdG9ycyA9IHdvcmRSZWdleHAoYXNjaWlPcGVyYXRvcnNMaXN0LCBcIlwiLCBcIkBcIik7XG52YXIgc3ltYm9sT3BlcmF0b3JzID0gd29yZFJlZ2V4cChhc2NpaU9wZXJhdG9yc0xpc3QsIFwiXCIsIFwiOlwiKTtcblxuZnVuY3Rpb24gaW5BcnJheShzdGF0ZSkge1xuICByZXR1cm4gKHN0YXRlLm5lc3RlZEFycmF5cyA+IDApO1xufVxuXG5mdW5jdGlvbiBpbkdlbmVyYXRvcihzdGF0ZSkge1xuICByZXR1cm4gKHN0YXRlLm5lc3RlZEdlbmVyYXRvcnMgPiAwKTtcbn1cblxuZnVuY3Rpb24gY3VycmVudFNjb3BlKHN0YXRlLCBuKSB7XG4gIGlmICh0eXBlb2YobikgPT09IFwidW5kZWZpbmVkXCIpIHsgbiA9IDA7IH1cbiAgaWYgKHN0YXRlLnNjb3Blcy5sZW5ndGggPD0gbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBzdGF0ZS5zY29wZXNbc3RhdGUuc2NvcGVzLmxlbmd0aCAtIChuICsgMSldO1xufVxuXG4vLyB0b2tlbml6ZXJzXG5mdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICAvLyBIYW5kbGUgbXVsdGlsaW5lIGNvbW1lbnRzXG4gIGlmIChzdHJlYW0ubWF0Y2goJyM9JywgZmFsc2UpKSB7XG4gICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNvbW1lbnQ7XG4gICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICB9XG5cbiAgLy8gSGFuZGxlIHNjb3BlIGNoYW5nZXNcbiAgdmFyIGxlYXZpbmdFeHByID0gc3RhdGUubGVhdmluZ0V4cHI7XG4gIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICBsZWF2aW5nRXhwciA9IGZhbHNlO1xuICB9XG4gIHN0YXRlLmxlYXZpbmdFeHByID0gZmFsc2U7XG5cbiAgaWYgKGxlYXZpbmdFeHByKSB7XG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXicrLykpIHtcbiAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0cmVhbS5tYXRjaCgvXFwuezQsfS8pKSB7XG4gICAgcmV0dXJuIFwiZXJyb3JcIjtcbiAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goL1xcLnsxLDN9LykpIHtcbiAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICB9XG5cbiAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgY2ggPSBzdHJlYW0ucGVlaygpO1xuXG4gIC8vIEhhbmRsZSBzaW5nbGUgbGluZSBjb21tZW50c1xuICBpZiAoY2ggPT09ICcjJykge1xuICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH1cblxuICBpZiAoY2ggPT09ICdbJykge1xuICAgIHN0YXRlLnNjb3Blcy5wdXNoKCdbJyk7XG4gICAgc3RhdGUubmVzdGVkQXJyYXlzKys7XG4gIH1cblxuICBpZiAoY2ggPT09ICcoJykge1xuICAgIHN0YXRlLnNjb3Blcy5wdXNoKCcoJyk7XG4gICAgc3RhdGUubmVzdGVkR2VuZXJhdG9ycysrO1xuICB9XG5cbiAgaWYgKGluQXJyYXkoc3RhdGUpICYmIGNoID09PSAnXScpIHtcbiAgICB3aGlsZSAoc3RhdGUuc2NvcGVzLmxlbmd0aCAmJiBjdXJyZW50U2NvcGUoc3RhdGUpICE9PSBcIltcIikgeyBzdGF0ZS5zY29wZXMucG9wKCk7IH1cbiAgICBzdGF0ZS5zY29wZXMucG9wKCk7XG4gICAgc3RhdGUubmVzdGVkQXJyYXlzLS07XG4gICAgc3RhdGUubGVhdmluZ0V4cHIgPSB0cnVlO1xuICB9XG5cbiAgaWYgKGluR2VuZXJhdG9yKHN0YXRlKSAmJiBjaCA9PT0gJyknKSB7XG4gICAgd2hpbGUgKHN0YXRlLnNjb3Blcy5sZW5ndGggJiYgY3VycmVudFNjb3BlKHN0YXRlKSAhPT0gXCIoXCIpIHsgc3RhdGUuc2NvcGVzLnBvcCgpOyB9XG4gICAgc3RhdGUuc2NvcGVzLnBvcCgpO1xuICAgIHN0YXRlLm5lc3RlZEdlbmVyYXRvcnMtLTtcbiAgICBzdGF0ZS5sZWF2aW5nRXhwciA9IHRydWU7XG4gIH1cblxuICBpZiAoaW5BcnJheShzdGF0ZSkpIHtcbiAgICBpZiAoc3RhdGUubGFzdFRva2VuID09IFwiZW5kXCIgJiYgc3RyZWFtLm1hdGNoKCc6JykpIHtcbiAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgfVxuICAgIGlmIChzdHJlYW0ubWF0Y2goJ2VuZCcpKSB7XG4gICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICB9XG4gIH1cblxuICB2YXIgbWF0Y2g7XG4gIGlmIChtYXRjaCA9IHN0cmVhbS5tYXRjaChvcGVuZXJzLCBmYWxzZSkpIHtcbiAgICBzdGF0ZS5zY29wZXMucHVzaChtYXRjaFswXSk7XG4gIH1cblxuICBpZiAoc3RyZWFtLm1hdGNoKGNsb3NlcnMsIGZhbHNlKSkge1xuICAgIHN0YXRlLnNjb3Blcy5wb3AoKTtcbiAgfVxuXG4gIC8vIEhhbmRsZSB0eXBlIGFubm90YXRpb25zXG4gIGlmIChzdHJlYW0ubWF0Y2goL146Oig/IVs6XFwkXSkvKSkge1xuICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5Bbm5vdGF0aW9uO1xuICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxuXG4gIC8vIEhhbmRsZSBzeW1ib2xzXG4gIGlmICghbGVhdmluZ0V4cHIgJiYgKHN0cmVhbS5tYXRjaChzeW1ib2wpIHx8IHN0cmVhbS5tYXRjaChzeW1ib2xPcGVyYXRvcnMpKSkge1xuICAgIHJldHVybiBcImJ1aWx0aW5cIjtcbiAgfVxuXG4gIC8vIEhhbmRsZSBwYXJhbWV0cmljIHR5cGVzXG4gIC8vaWYgKHN0cmVhbS5tYXRjaCgvXntbXn1dKn0oPz1cXCgpLykpIHtcbiAgLy8gIHJldHVybiBcImJ1aWx0aW5cIjtcbiAgLy99XG5cbiAgLy8gSGFuZGxlIG9wZXJhdG9ycyBhbmQgRGVsaW1pdGVyc1xuICBpZiAoc3RyZWFtLm1hdGNoKG9wZXJhdG9ycykpIHtcbiAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICB9XG5cbiAgLy8gSGFuZGxlIE51bWJlciBMaXRlcmFsc1xuICBpZiAoc3RyZWFtLm1hdGNoKC9eXFwuP1xcZC8sIGZhbHNlKSkge1xuICAgIHZhciBpbU1hdGNoZXIgPSBSZWdFeHAoL15pbVxcYi8pO1xuICAgIHZhciBudW1iZXJMaXRlcmFsID0gZmFsc2U7XG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXjB4XFwuWzAtOWEtZl9dK3BbXFwrXFwtXT9bX1xcZF0rL2kpKSB7IG51bWJlckxpdGVyYWwgPSB0cnVlOyB9XG4gICAgLy8gSW50ZWdlcnNcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eMHhbMC05YS1mX10rL2kpKSB7IG51bWJlckxpdGVyYWwgPSB0cnVlOyB9IC8vIEhleFxuICAgIGlmIChzdHJlYW0ubWF0Y2goL14wYlswMV9dKy9pKSkgeyBudW1iZXJMaXRlcmFsID0gdHJ1ZTsgfSAvLyBCaW5hcnlcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eMG9bMC03X10rL2kpKSB7IG51bWJlckxpdGVyYWwgPSB0cnVlOyB9IC8vIE9jdGFsXG4gICAgLy8gRmxvYXRzXG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXig/Oig/OlxcZFtfXFxkXSopP1xcLig/IVxcLikoPzpcXGRbX1xcZF0qKT98XFxkW19cXGRdKlxcLig/IVxcLikoPzpcXGRbX1xcZF0qKSk/KFtFZWZdW1xcK1xcLV0/W19cXGRdKyk/L2kpKSB7IG51bWJlckxpdGVyYWwgPSB0cnVlOyB9XG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXlxcZFtfXFxkXSooZVtcXCtcXC1dP1xcZCspPy9pKSkgeyBudW1iZXJMaXRlcmFsID0gdHJ1ZTsgfSAvLyBEZWNpbWFsXG4gICAgaWYgKG51bWJlckxpdGVyYWwpIHtcbiAgICAgIC8vIEludGVnZXIgbGl0ZXJhbHMgbWF5IGJlIFwibG9uZ1wiXG4gICAgICBzdHJlYW0ubWF0Y2goaW1NYXRjaGVyKTtcbiAgICAgIHN0YXRlLmxlYXZpbmdFeHByID0gdHJ1ZTtcbiAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhhbmRsZSBDaGFyc1xuICBpZiAoc3RyZWFtLm1hdGNoKFwiJ1wiKSkge1xuICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5DaGFyO1xuICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxuXG4gIC8vIEhhbmRsZSBTdHJpbmdzXG4gIGlmIChzdHJlYW0ubWF0Y2goc3RyaW5nUHJlZml4ZXMpKSB7XG4gICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZ0ZhY3Rvcnkoc3RyZWFtLmN1cnJlbnQoKSk7XG4gICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICB9XG5cbiAgaWYgKHN0cmVhbS5tYXRjaChtYWNybykgfHwgc3RyZWFtLm1hdGNoKG1hY3JvT3BlcmF0b3JzKSkge1xuICAgIHJldHVybiBcIm1ldGFcIjtcbiAgfVxuXG4gIGlmIChzdHJlYW0ubWF0Y2goZGVsaW1pdGVycykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChzdHJlYW0ubWF0Y2goa2V5d29yZHMpKSB7XG4gICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICB9XG5cbiAgaWYgKHN0cmVhbS5tYXRjaChidWlsdGlucykpIHtcbiAgICByZXR1cm4gXCJidWlsdGluXCI7XG4gIH1cblxuICB2YXIgaXNEZWZpbml0aW9uID0gc3RhdGUuaXNEZWZpbml0aW9uIHx8IHN0YXRlLmxhc3RUb2tlbiA9PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgIHN0YXRlLmxhc3RUb2tlbiA9PSBcIm1hY3JvXCIgfHwgc3RhdGUubGFzdFRva2VuID09IFwidHlwZVwiIHx8XG4gICAgICBzdGF0ZS5sYXN0VG9rZW4gPT0gXCJzdHJ1Y3RcIiB8fCBzdGF0ZS5sYXN0VG9rZW4gPT0gXCJpbW11dGFibGVcIjtcblxuICBpZiAoc3RyZWFtLm1hdGNoKGlkZW50aWZpZXJzKSkge1xuICAgIGlmIChpc0RlZmluaXRpb24pIHtcbiAgICAgIGlmIChzdHJlYW0ucGVlaygpID09PSAnLicpIHtcbiAgICAgICAgc3RhdGUuaXNEZWZpbml0aW9uID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmlzRGVmaW5pdGlvbiA9IGZhbHNlO1xuICAgICAgcmV0dXJuIFwiZGVmXCI7XG4gICAgfVxuICAgIHN0YXRlLmxlYXZpbmdFeHByID0gdHJ1ZTtcbiAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICB9XG5cbiAgLy8gSGFuZGxlIG5vbi1kZXRlY3RlZCBpdGVtc1xuICBzdHJlYW0ubmV4dCgpO1xuICByZXR1cm4gXCJlcnJvclwiO1xufVxuXG5mdW5jdGlvbiB0b2tlbkFubm90YXRpb24oc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0ubWF0Y2goLy4qPyg/PVssO3t9KCk9XFxzXXwkKS8pO1xuICBpZiAoc3RyZWFtLm1hdGNoKCd7JykpIHtcbiAgICBzdGF0ZS5uZXN0ZWRQYXJhbWV0ZXJzKys7XG4gIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKCd9JykgJiYgc3RhdGUubmVzdGVkUGFyYW1ldGVycyA+IDApIHtcbiAgICBzdGF0ZS5uZXN0ZWRQYXJhbWV0ZXJzLS07XG4gIH1cbiAgaWYgKHN0YXRlLm5lc3RlZFBhcmFtZXRlcnMgPiAwKSB7XG4gICAgc3RyZWFtLm1hdGNoKC8uKj8oPz17fH0pLykgfHwgc3RyZWFtLm5leHQoKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5uZXN0ZWRQYXJhbWV0ZXJzID09IDApIHtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgfVxuICByZXR1cm4gXCJidWlsdGluXCI7XG59XG5cbmZ1bmN0aW9uIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdHJlYW0ubWF0Y2goJyM9JykpIHtcbiAgICBzdGF0ZS5uZXN0ZWRDb21tZW50cysrO1xuICB9XG4gIGlmICghc3RyZWFtLm1hdGNoKC8uKj8oPz0oIz18PSMpKS8pKSB7XG4gICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICB9XG4gIGlmIChzdHJlYW0ubWF0Y2goJz0jJykpIHtcbiAgICBzdGF0ZS5uZXN0ZWRDb21tZW50cy0tO1xuICAgIGlmIChzdGF0ZS5uZXN0ZWRDb21tZW50cyA9PSAwKVxuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gIH1cbiAgcmV0dXJuIFwiY29tbWVudFwiO1xufVxuXG5mdW5jdGlvbiB0b2tlbkNoYXIoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgaXNDaGFyID0gZmFsc2UsIG1hdGNoO1xuICBpZiAoc3RyZWFtLm1hdGNoKGNoYXJzKSkge1xuICAgIGlzQ2hhciA9IHRydWU7XG4gIH0gZWxzZSBpZiAobWF0Y2ggPSBzdHJlYW0ubWF0Y2goL1xcXFx1KFthLWYwLTldezEsNH0pKD89JykvaSkpIHtcbiAgICB2YXIgdmFsdWUgPSBwYXJzZUludChtYXRjaFsxXSwgMTYpO1xuICAgIGlmICh2YWx1ZSA8PSA1NTI5NSB8fCB2YWx1ZSA+PSA1NzM0NCkgeyAvLyAoVSswLFUrRDdGRiksIChVK0UwMDAsVStGRkZGKVxuICAgICAgaXNDaGFyID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKG1hdGNoID0gc3RyZWFtLm1hdGNoKC9cXFxcVShbQS1GYS1mMC05XXs1LDh9KSg/PScpLykpIHtcbiAgICB2YXIgdmFsdWUgPSBwYXJzZUludChtYXRjaFsxXSwgMTYpO1xuICAgIGlmICh2YWx1ZSA8PSAxMTE0MTExKSB7IC8vIFUrMTBGRkZGXG4gICAgICBpc0NoYXIgPSB0cnVlO1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQ2hhcikge1xuICAgIHN0YXRlLmxlYXZpbmdFeHByID0gdHJ1ZTtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgfVxuICBpZiAoIXN0cmVhbS5tYXRjaCgvXlteJ10rKD89JykvKSkgeyBzdHJlYW0uc2tpcFRvRW5kKCk7IH1cbiAgaWYgKHN0cmVhbS5tYXRjaChcIidcIikpIHsgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7IH1cbiAgcmV0dXJuIFwiZXJyb3JcIjtcbn1cblxuZnVuY3Rpb24gdG9rZW5TdHJpbmdGYWN0b3J5KGRlbGltaXRlcikge1xuICBpZiAoZGVsaW1pdGVyLnN1YnN0cigtMykgPT09ICdcIlwiXCInKSB7XG4gICAgZGVsaW1pdGVyID0gJ1wiXCJcIic7XG4gIH0gZWxzZSBpZiAoZGVsaW1pdGVyLnN1YnN0cigtMSkgPT09ICdcIicpIHtcbiAgICBkZWxpbWl0ZXIgPSAnXCInO1xuICB9XG4gIGZ1bmN0aW9uIHRva2VuU3RyaW5nKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLmVhdCgnXFxcXCcpKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKGRlbGltaXRlcikpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgc3RhdGUubGVhdmluZ0V4cHIgPSB0cnVlO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5lYXQoL1tgXCJdLyk7XG4gICAgfVxuICAgIHN0cmVhbS5lYXRXaGlsZSgvW15cXFxcYFwiXS8pO1xuICAgIHJldHVybiBcInN0cmluZ1wiO1xuICB9XG4gIHJldHVybiB0b2tlblN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IGp1bGlhID0ge1xuICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5pemU6IHRva2VuQmFzZSxcbiAgICAgIHNjb3BlczogW10sXG4gICAgICBsYXN0VG9rZW46IG51bGwsXG4gICAgICBsZWF2aW5nRXhwcjogZmFsc2UsXG4gICAgICBpc0RlZmluaXRpb246IGZhbHNlLFxuICAgICAgbmVzdGVkQXJyYXlzOiAwLFxuICAgICAgbmVzdGVkQ29tbWVudHM6IDAsXG4gICAgICBuZXN0ZWRHZW5lcmF0b3JzOiAwLFxuICAgICAgbmVzdGVkUGFyYW1ldGVyczogMCxcbiAgICAgIGZpcnN0UGFyZW5Qb3M6IC0xXG4gICAgfTtcbiAgfSxcblxuICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIHZhciBjdXJyZW50ID0gc3RyZWFtLmN1cnJlbnQoKTtcblxuICAgIGlmIChjdXJyZW50ICYmIHN0eWxlKSB7XG4gICAgICBzdGF0ZS5sYXN0VG9rZW4gPSBjdXJyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcblxuICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIsIGN4KSB7XG4gICAgdmFyIGRlbHRhID0gMDtcbiAgICBpZiAoIHRleHRBZnRlciA9PT0gJ10nIHx8IHRleHRBZnRlciA9PT0gJyknIHx8IC9eZW5kXFxiLy50ZXN0KHRleHRBZnRlcikgfHxcbiAgICAgICAgIC9eZWxzZS8udGVzdCh0ZXh0QWZ0ZXIpIHx8IC9eY2F0Y2hcXGIvLnRlc3QodGV4dEFmdGVyKSB8fCAvXmVsc2VpZlxcYi8udGVzdCh0ZXh0QWZ0ZXIpIHx8XG4gICAgICAgICAvXmZpbmFsbHkvLnRlc3QodGV4dEFmdGVyKSApIHtcbiAgICAgIGRlbHRhID0gLTE7XG4gICAgfVxuICAgIHJldHVybiAoc3RhdGUuc2NvcGVzLmxlbmd0aCArIGRlbHRhKSAqIGN4LnVuaXQ7XG4gIH0sXG5cbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgaW5kZW50T25JbnB1dDogL15cXHMqKGVuZHxlbHNlfGNhdGNofGZpbmFsbHkpXFxiJC8sXG4gICAgY29tbWVudFRva2Vuczoge2xpbmU6IFwiI1wiLCBibG9jazoge29wZW46IFwiIz1cIiwgY2xvc2U6IFwiPSNcIn19LFxuICAgIGNsb3NlQnJhY2tldHM6IHticmFja2V0czogW1wiKFwiLCBcIltcIiwgXCJ7XCIsICdcIiddfSxcbiAgICBhdXRvY29tcGxldGU6IGtleXdvcmRzTGlzdC5jb25jYXQoYnVpbHRpbnNMaXN0KVxuICB9XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/legacy-modes/mode/julia.js\n");

/***/ })

}]);