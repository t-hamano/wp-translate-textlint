(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{379:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "erlang", function() { return erlang; });\n/////////////////////////////////////////////////////////////////////////////\n// constants\n\nvar typeWords = [\n  "-type", "-spec", "-export_type", "-opaque"];\n\nvar keywordWords = [\n  "after","begin","catch","case","cond","end","fun","if",\n  "let","of","query","receive","try","when"];\n\nvar separatorRE    = /[\\->,;]/;\nvar separatorWords = [\n  "->",";",","];\n\nvar operatorAtomWords = [\n  "and","andalso","band","bnot","bor","bsl","bsr","bxor",\n  "div","not","or","orelse","rem","xor"];\n\nvar operatorSymbolRE    = /[\\+\\-\\*\\/<>=\\|:!]/;\nvar operatorSymbolWords = [\n  "=","+","-","*","/",">",">=","<","=<","=:=","==","=/=","/=","||","<-","!"];\n\nvar openParenRE    = /[<\\(\\[\\{]/;\nvar openParenWords = [\n  "<<","(","[","{"];\n\nvar closeParenRE    = /[>\\)\\]\\}]/;\nvar closeParenWords = [\n  "}","]",")",">>"];\n\nvar guardWords = [\n  "is_atom","is_binary","is_bitstring","is_boolean","is_float",\n  "is_function","is_integer","is_list","is_number","is_pid",\n  "is_port","is_record","is_reference","is_tuple",\n  "atom","binary","bitstring","boolean","function","integer","list",\n  "number","pid","port","record","reference","tuple"];\n\nvar bifWords = [\n  "abs","adler32","adler32_combine","alive","apply","atom_to_binary",\n  "atom_to_list","binary_to_atom","binary_to_existing_atom",\n  "binary_to_list","binary_to_term","bit_size","bitstring_to_list",\n  "byte_size","check_process_code","contact_binary","crc32",\n  "crc32_combine","date","decode_packet","delete_module",\n  "disconnect_node","element","erase","exit","float","float_to_list",\n  "garbage_collect","get","get_keys","group_leader","halt","hd",\n  "integer_to_list","internal_bif","iolist_size","iolist_to_binary",\n  "is_alive","is_atom","is_binary","is_bitstring","is_boolean",\n  "is_float","is_function","is_integer","is_list","is_number","is_pid",\n  "is_port","is_process_alive","is_record","is_reference","is_tuple",\n  "length","link","list_to_atom","list_to_binary","list_to_bitstring",\n  "list_to_existing_atom","list_to_float","list_to_integer",\n  "list_to_pid","list_to_tuple","load_module","make_ref","module_loaded",\n  "monitor_node","node","node_link","node_unlink","nodes","notalive",\n  "now","open_port","pid_to_list","port_close","port_command",\n  "port_connect","port_control","pre_loaded","process_flag",\n  "process_info","processes","purge_module","put","register",\n  "registered","round","self","setelement","size","spawn","spawn_link",\n  "spawn_monitor","spawn_opt","split_binary","statistics",\n  "term_to_binary","time","throw","tl","trunc","tuple_size",\n  "tuple_to_list","unlink","unregister","whereis"];\n\n// upper case: [A-Z] [Ø-Þ] [À-Ö]\n// lower case: [a-z] [ß-ö] [ø-ÿ]\nvar anumRE       = /[\\w@Ø-ÞÀ-Öß-öø-ÿ]/;\nvar escapesRE    =\n    /[0-7]{1,3}|[bdefnrstv\\\\"\']|\\^[a-zA-Z]|x[0-9a-zA-Z]{2}|x{[0-9a-zA-Z]+}/;\n\n/////////////////////////////////////////////////////////////////////////////\n// tokenizer\n\nfunction tokenizer(stream,state) {\n  // in multi-line string\n  if (state.in_string) {\n    state.in_string = (!doubleQuote(stream));\n    return rval(state,stream,"string");\n  }\n\n  // in multi-line atom\n  if (state.in_atom) {\n    state.in_atom = (!singleQuote(stream));\n    return rval(state,stream,"atom");\n  }\n\n  // whitespace\n  if (stream.eatSpace()) {\n    return rval(state,stream,"whitespace");\n  }\n\n  // attributes and type specs\n  if (!peekToken(state) &&\n      stream.match(/-\\s*[a-zß-öø-ÿ][\\wØ-ÞÀ-Öß-öø-ÿ]*/)) {\n    if (is_member(stream.current(),typeWords)) {\n      return rval(state,stream,"type");\n    }else{\n      return rval(state,stream,"attribute");\n    }\n  }\n\n  var ch = stream.next();\n\n  // comment\n  if (ch == \'%\') {\n    stream.skipToEnd();\n    return rval(state,stream,"comment");\n  }\n\n  // colon\n  if (ch == ":") {\n    return rval(state,stream,"colon");\n  }\n\n  // macro\n  if (ch == \'?\') {\n    stream.eatSpace();\n    stream.eatWhile(anumRE);\n    return rval(state,stream,"macro");\n  }\n\n  // record\n  if (ch == "#") {\n    stream.eatSpace();\n    stream.eatWhile(anumRE);\n    return rval(state,stream,"record");\n  }\n\n  // dollar escape\n  if (ch == "$") {\n    if (stream.next() == "\\\\" && !stream.match(escapesRE)) {\n      return rval(state,stream,"error");\n    }\n    return rval(state,stream,"number");\n  }\n\n  // dot\n  if (ch == ".") {\n    return rval(state,stream,"dot");\n  }\n\n  // quoted atom\n  if (ch == \'\\\'\') {\n    if (!(state.in_atom = (!singleQuote(stream)))) {\n      if (stream.match(/\\s*\\/\\s*[0-9]/,false)) {\n        stream.match(/\\s*\\/\\s*[0-9]/,true);\n        return rval(state,stream,"fun");      // \'f\'/0 style fun\n      }\n      if (stream.match(/\\s*\\(/,false) || stream.match(/\\s*:/,false)) {\n        return rval(state,stream,"function");\n      }\n    }\n    return rval(state,stream,"atom");\n  }\n\n  // string\n  if (ch == \'"\') {\n    state.in_string = (!doubleQuote(stream));\n    return rval(state,stream,"string");\n  }\n\n  // variable\n  if (/[A-Z_Ø-ÞÀ-Ö]/.test(ch)) {\n    stream.eatWhile(anumRE);\n    return rval(state,stream,"variable");\n  }\n\n  // atom/keyword/BIF/function\n  if (/[a-z_ß-öø-ÿ]/.test(ch)) {\n    stream.eatWhile(anumRE);\n\n    if (stream.match(/\\s*\\/\\s*[0-9]/,false)) {\n      stream.match(/\\s*\\/\\s*[0-9]/,true);\n      return rval(state,stream,"fun");      // f/0 style fun\n    }\n\n    var w = stream.current();\n\n    if (is_member(w,keywordWords)) {\n      return rval(state,stream,"keyword");\n    }else if (is_member(w,operatorAtomWords)) {\n      return rval(state,stream,"operator");\n    }else if (stream.match(/\\s*\\(/,false)) {\n      // \'put\' and \'erlang:put\' are bifs, \'foo:put\' is not\n      if (is_member(w,bifWords) &&\n          ((peekToken(state).token != ":") ||\n           (peekToken(state,2).token == "erlang"))) {\n        return rval(state,stream,"builtin");\n      }else if (is_member(w,guardWords)) {\n        return rval(state,stream,"guard");\n      }else{\n        return rval(state,stream,"function");\n      }\n    }else if (lookahead(stream) == ":") {\n      if (w == "erlang") {\n        return rval(state,stream,"builtin");\n      } else {\n        return rval(state,stream,"function");\n      }\n    }else if (is_member(w,["true","false"])) {\n      return rval(state,stream,"boolean");\n    }else{\n      return rval(state,stream,"atom");\n    }\n  }\n\n  // number\n  var digitRE      = /[0-9]/;\n  var radixRE      = /[0-9a-zA-Z]/;         // 36#zZ style int\n  if (digitRE.test(ch)) {\n    stream.eatWhile(digitRE);\n    if (stream.eat(\'#\')) {                // 36#aZ  style integer\n      if (!stream.eatWhile(radixRE)) {\n        stream.backUp(1);                 //"36#" - syntax error\n      }\n    } else if (stream.eat(\'.\')) {       // float\n      if (!stream.eatWhile(digitRE)) {\n        stream.backUp(1);        // "3." - probably end of function\n      } else {\n        if (stream.eat(/[eE]/)) {        // float with exponent\n          if (stream.eat(/[-+]/)) {\n            if (!stream.eatWhile(digitRE)) {\n              stream.backUp(2);            // "2e-" - syntax error\n            }\n          } else {\n            if (!stream.eatWhile(digitRE)) {\n              stream.backUp(1);            // "2e" - syntax error\n            }\n          }\n        }\n      }\n    }\n    return rval(state,stream,"number");   // normal integer\n  }\n\n  // open parens\n  if (nongreedy(stream,openParenRE,openParenWords)) {\n    return rval(state,stream,"open_paren");\n  }\n\n  // close parens\n  if (nongreedy(stream,closeParenRE,closeParenWords)) {\n    return rval(state,stream,"close_paren");\n  }\n\n  // separators\n  if (greedy(stream,separatorRE,separatorWords)) {\n    return rval(state,stream,"separator");\n  }\n\n  // operators\n  if (greedy(stream,operatorSymbolRE,operatorSymbolWords)) {\n    return rval(state,stream,"operator");\n  }\n\n  return rval(state,stream,null);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// utilities\nfunction nongreedy(stream,re,words) {\n  if (stream.current().length == 1 && re.test(stream.current())) {\n    stream.backUp(1);\n    while (re.test(stream.peek())) {\n      stream.next();\n      if (is_member(stream.current(),words)) {\n        return true;\n      }\n    }\n    stream.backUp(stream.current().length-1);\n  }\n  return false;\n}\n\nfunction greedy(stream,re,words) {\n  if (stream.current().length == 1 && re.test(stream.current())) {\n    while (re.test(stream.peek())) {\n      stream.next();\n    }\n    while (0 < stream.current().length) {\n      if (is_member(stream.current(),words)) {\n        return true;\n      }else{\n        stream.backUp(1);\n      }\n    }\n    stream.next();\n  }\n  return false;\n}\n\nfunction doubleQuote(stream) {\n  return quote(stream, \'"\', \'\\\\\');\n}\n\nfunction singleQuote(stream) {\n  return quote(stream,\'\\\'\',\'\\\\\');\n}\n\nfunction quote(stream,quoteChar,escapeChar) {\n  while (!stream.eol()) {\n    var ch = stream.next();\n    if (ch == quoteChar) {\n      return true;\n    }else if (ch == escapeChar) {\n      stream.next();\n    }\n  }\n  return false;\n}\n\nfunction lookahead(stream) {\n  var m = stream.match(/^\\s*([^\\s%])/, false)\n  return m ? m[1] : "";\n}\n\nfunction is_member(element,list) {\n  return (-1 < list.indexOf(element));\n}\n\nfunction rval(state,stream,type) {\n\n  // parse stack\n  pushToken(state,realToken(type,stream));\n\n  // map erlang token type to CodeMirror style class\n  //     erlang             -> CodeMirror tag\n  switch (type) {\n  case "atom":        return "atom";\n  case "attribute":   return "attribute";\n  case "boolean":     return "atom";\n  case "builtin":     return "builtin";\n  case "close_paren": return null;\n  case "colon":       return null;\n  case "comment":     return "comment";\n  case "dot":         return null;\n  case "error":       return "error";\n  case "fun":         return "meta";\n  case "function":    return "tag";\n  case "guard":       return "property";\n  case "keyword":     return "keyword";\n  case "macro":       return "macroName";\n  case "number":      return "number";\n  case "open_paren":  return null;\n  case "operator":    return "operator";\n  case "record":      return "bracket";\n  case "separator":   return null;\n  case "string":      return "string";\n  case "type":        return "def";\n  case "variable":    return "variable";\n  default:            return null;\n  }\n}\n\nfunction aToken(tok,col,ind,typ) {\n  return {token:  tok,\n          column: col,\n          indent: ind,\n          type:   typ};\n}\n\nfunction realToken(type,stream) {\n  return aToken(stream.current(),\n                stream.column(),\n                stream.indentation(),\n                type);\n}\n\nfunction fakeToken(type) {\n  return aToken(type,0,0,type);\n}\n\nfunction peekToken(state,depth) {\n  var len = state.tokenStack.length;\n  var dep = (depth ? depth : 1);\n\n  if (len < dep) {\n    return false;\n  }else{\n    return state.tokenStack[len-dep];\n  }\n}\n\nfunction pushToken(state,token) {\n\n  if (!(token.type == "comment" || token.type == "whitespace")) {\n    state.tokenStack = maybe_drop_pre(state.tokenStack,token);\n    state.tokenStack = maybe_drop_post(state.tokenStack);\n  }\n}\n\nfunction maybe_drop_pre(s,token) {\n  var last = s.length-1;\n\n  if (0 < last && s[last].type === "record" && token.type === "dot") {\n    s.pop();\n  }else if (0 < last && s[last].type === "group") {\n    s.pop();\n    s.push(token);\n  }else{\n    s.push(token);\n  }\n  return s;\n}\n\nfunction maybe_drop_post(s) {\n  if (!s.length) return s\n  var last = s.length-1;\n\n  if (s[last].type === "dot") {\n    return [];\n  }\n  if (last > 1 && s[last].type === "fun" && s[last-1].token === "fun") {\n    return s.slice(0,last-1);\n  }\n  switch (s[last].token) {\n  case "}":    return d(s,{g:["{"]});\n  case "]":    return d(s,{i:["["]});\n  case ")":    return d(s,{i:["("]});\n  case ">>":   return d(s,{i:["<<"]});\n  case "end":  return d(s,{i:["begin","case","fun","if","receive","try"]});\n  case ",":    return d(s,{e:["begin","try","when","->",\n                              ",","(","[","{","<<"]});\n  case "->":   return d(s,{r:["when"],\n                           m:["try","if","case","receive"]});\n  case ";":    return d(s,{E:["case","fun","if","receive","try","when"]});\n  case "catch":return d(s,{e:["try"]});\n  case "of":   return d(s,{e:["case"]});\n  case "after":return d(s,{e:["receive","try"]});\n  default:     return s;\n  }\n}\n\nfunction d(stack,tt) {\n  // stack is a stack of Token objects.\n  // tt is an object; {type:tokens}\n  // type is a char, tokens is a list of token strings.\n  // The function returns (possibly truncated) stack.\n  // It will descend the stack, looking for a Token such that Token.token\n  //  is a member of tokens. If it does not find that, it will normally (but\n  //  see "E" below) return stack. If it does find a match, it will remove\n  //  all the Tokens between the top and the matched Token.\n  // If type is "m", that is all it does.\n  // If type is "i", it will also remove the matched Token and the top Token.\n  // If type is "g", like "i", but add a fake "group" token at the top.\n  // If type is "r", it will remove the matched Token, but not the top Token.\n  // If type is "e", it will keep the matched Token but not the top Token.\n  // If type is "E", it behaves as for type "e", except if there is no match,\n  //  in which case it will return an empty stack.\n\n  for (var type in tt) {\n    var len = stack.length-1;\n    var tokens = tt[type];\n    for (var i = len-1; -1 < i ; i--) {\n      if (is_member(stack[i].token,tokens)) {\n        var ss = stack.slice(0,i);\n        switch (type) {\n        case "m": return ss.concat(stack[i]).concat(stack[len]);\n        case "r": return ss.concat(stack[len]);\n        case "i": return ss;\n        case "g": return ss.concat(fakeToken("group"));\n        case "E": return ss.concat(stack[i]);\n        case "e": return ss.concat(stack[i]);\n        }\n      }\n    }\n  }\n  return (type == "E" ? [] : stack);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// indenter\n\nfunction indenter(state, textAfter, cx) {\n  var t;\n  var wordAfter = wordafter(textAfter);\n  var currT = peekToken(state,1);\n  var prevT = peekToken(state,2);\n\n  if (state.in_string || state.in_atom) {\n    return null;\n  }else if (!prevT) {\n    return 0;\n  }else if (currT.token == "when") {\n    return currT.column + cx.unit;\n  }else if (wordAfter === "when" && prevT.type === "function") {\n    return prevT.indent+cx.unit;\n  }else if (wordAfter === "(" && currT.token === "fun") {\n    return  currT.column+3;\n  }else if (wordAfter === "catch" && (t = getToken(state,["try"]))) {\n    return t.column;\n  }else if (is_member(wordAfter,["end","after","of"])) {\n    t = getToken(state,["begin","case","fun","if","receive","try"]);\n    return t ? t.column : null;\n  }else if (is_member(wordAfter,closeParenWords)) {\n    t = getToken(state,openParenWords);\n    return t ? t.column : null;\n  }else if (is_member(currT.token,[",","|","||"]) ||\n            is_member(wordAfter,[",","|","||"])) {\n    t = postcommaToken(state);\n    return t ? t.column+t.token.length : cx.unit;\n  }else if (currT.token == "->") {\n    if (is_member(prevT.token, ["receive","case","if","try"])) {\n      return prevT.column+cx.unit+cx.unit;\n    }else{\n      return prevT.column+cx.unit;\n    }\n  }else if (is_member(currT.token,openParenWords)) {\n    return currT.column+currT.token.length;\n  }else{\n    t = defaultToken(state);\n    return truthy(t) ? t.column+cx.unit : 0;\n  }\n}\n\nfunction wordafter(str) {\n  var m = str.match(/,|[a-z]+|\\}|\\]|\\)|>>|\\|+|\\(/);\n\n  return truthy(m) && (m.index === 0) ? m[0] : "";\n}\n\nfunction postcommaToken(state) {\n  var objs = state.tokenStack.slice(0,-1);\n  var i = getTokenIndex(objs,"type",["open_paren"]);\n\n  return truthy(objs[i]) ? objs[i] : false;\n}\n\nfunction defaultToken(state) {\n  var objs = state.tokenStack;\n  var stop = getTokenIndex(objs,"type",["open_paren","separator","keyword"]);\n  var oper = getTokenIndex(objs,"type",["operator"]);\n\n  if (truthy(stop) && truthy(oper) && stop < oper) {\n    return objs[stop+1];\n  } else if (truthy(stop)) {\n    return objs[stop];\n  } else {\n    return false;\n  }\n}\n\nfunction getToken(state,tokens) {\n  var objs = state.tokenStack;\n  var i = getTokenIndex(objs,"token",tokens);\n\n  return truthy(objs[i]) ? objs[i] : false;\n}\n\nfunction getTokenIndex(objs,propname,propvals) {\n\n  for (var i = objs.length-1; -1 < i ; i--) {\n    if (is_member(objs[i][propname],propvals)) {\n      return i;\n    }\n  }\n  return false;\n}\n\nfunction truthy(x) {\n  return (x !== false) && (x != null);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// this object defines the mode\n\nconst erlang = {\n  startState() {\n    return {tokenStack: [],\n            in_string:  false,\n            in_atom:    false};\n  },\n\n  token: tokenizer,\n\n  indent: indenter,\n\n  languageData: {\n    commentTokens: {line: "%"}\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvZXJsYW5nLmpzP2Y4YmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBLGlCQUFpQjs7QUFFakIsK0JBQStCO0FBQy9CO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsSUFBSSx5Q0FBeUMsRUFBRSxHQUFHLGFBQWE7O0FBRTFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EiLCJmaWxlIjoiMzc5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGNvbnN0YW50c1xuXG52YXIgdHlwZVdvcmRzID0gW1xuICBcIi10eXBlXCIsIFwiLXNwZWNcIiwgXCItZXhwb3J0X3R5cGVcIiwgXCItb3BhcXVlXCJdO1xuXG52YXIga2V5d29yZFdvcmRzID0gW1xuICBcImFmdGVyXCIsXCJiZWdpblwiLFwiY2F0Y2hcIixcImNhc2VcIixcImNvbmRcIixcImVuZFwiLFwiZnVuXCIsXCJpZlwiLFxuICBcImxldFwiLFwib2ZcIixcInF1ZXJ5XCIsXCJyZWNlaXZlXCIsXCJ0cnlcIixcIndoZW5cIl07XG5cbnZhciBzZXBhcmF0b3JSRSAgICA9IC9bXFwtPiw7XS87XG52YXIgc2VwYXJhdG9yV29yZHMgPSBbXG4gIFwiLT5cIixcIjtcIixcIixcIl07XG5cbnZhciBvcGVyYXRvckF0b21Xb3JkcyA9IFtcbiAgXCJhbmRcIixcImFuZGFsc29cIixcImJhbmRcIixcImJub3RcIixcImJvclwiLFwiYnNsXCIsXCJic3JcIixcImJ4b3JcIixcbiAgXCJkaXZcIixcIm5vdFwiLFwib3JcIixcIm9yZWxzZVwiLFwicmVtXCIsXCJ4b3JcIl07XG5cbnZhciBvcGVyYXRvclN5bWJvbFJFICAgID0gL1tcXCtcXC1cXCpcXC88Pj1cXHw6IV0vO1xudmFyIG9wZXJhdG9yU3ltYm9sV29yZHMgPSBbXG4gIFwiPVwiLFwiK1wiLFwiLVwiLFwiKlwiLFwiL1wiLFwiPlwiLFwiPj1cIixcIjxcIixcIj08XCIsXCI9Oj1cIixcIj09XCIsXCI9Lz1cIixcIi89XCIsXCJ8fFwiLFwiPC1cIixcIiFcIl07XG5cbnZhciBvcGVuUGFyZW5SRSAgICA9IC9bPFxcKFxcW1xce10vO1xudmFyIG9wZW5QYXJlbldvcmRzID0gW1xuICBcIjw8XCIsXCIoXCIsXCJbXCIsXCJ7XCJdO1xuXG52YXIgY2xvc2VQYXJlblJFICAgID0gL1s+XFwpXFxdXFx9XS87XG52YXIgY2xvc2VQYXJlbldvcmRzID0gW1xuICBcIn1cIixcIl1cIixcIilcIixcIj4+XCJdO1xuXG52YXIgZ3VhcmRXb3JkcyA9IFtcbiAgXCJpc19hdG9tXCIsXCJpc19iaW5hcnlcIixcImlzX2JpdHN0cmluZ1wiLFwiaXNfYm9vbGVhblwiLFwiaXNfZmxvYXRcIixcbiAgXCJpc19mdW5jdGlvblwiLFwiaXNfaW50ZWdlclwiLFwiaXNfbGlzdFwiLFwiaXNfbnVtYmVyXCIsXCJpc19waWRcIixcbiAgXCJpc19wb3J0XCIsXCJpc19yZWNvcmRcIixcImlzX3JlZmVyZW5jZVwiLFwiaXNfdHVwbGVcIixcbiAgXCJhdG9tXCIsXCJiaW5hcnlcIixcImJpdHN0cmluZ1wiLFwiYm9vbGVhblwiLFwiZnVuY3Rpb25cIixcImludGVnZXJcIixcImxpc3RcIixcbiAgXCJudW1iZXJcIixcInBpZFwiLFwicG9ydFwiLFwicmVjb3JkXCIsXCJyZWZlcmVuY2VcIixcInR1cGxlXCJdO1xuXG52YXIgYmlmV29yZHMgPSBbXG4gIFwiYWJzXCIsXCJhZGxlcjMyXCIsXCJhZGxlcjMyX2NvbWJpbmVcIixcImFsaXZlXCIsXCJhcHBseVwiLFwiYXRvbV90b19iaW5hcnlcIixcbiAgXCJhdG9tX3RvX2xpc3RcIixcImJpbmFyeV90b19hdG9tXCIsXCJiaW5hcnlfdG9fZXhpc3RpbmdfYXRvbVwiLFxuICBcImJpbmFyeV90b19saXN0XCIsXCJiaW5hcnlfdG9fdGVybVwiLFwiYml0X3NpemVcIixcImJpdHN0cmluZ190b19saXN0XCIsXG4gIFwiYnl0ZV9zaXplXCIsXCJjaGVja19wcm9jZXNzX2NvZGVcIixcImNvbnRhY3RfYmluYXJ5XCIsXCJjcmMzMlwiLFxuICBcImNyYzMyX2NvbWJpbmVcIixcImRhdGVcIixcImRlY29kZV9wYWNrZXRcIixcImRlbGV0ZV9tb2R1bGVcIixcbiAgXCJkaXNjb25uZWN0X25vZGVcIixcImVsZW1lbnRcIixcImVyYXNlXCIsXCJleGl0XCIsXCJmbG9hdFwiLFwiZmxvYXRfdG9fbGlzdFwiLFxuICBcImdhcmJhZ2VfY29sbGVjdFwiLFwiZ2V0XCIsXCJnZXRfa2V5c1wiLFwiZ3JvdXBfbGVhZGVyXCIsXCJoYWx0XCIsXCJoZFwiLFxuICBcImludGVnZXJfdG9fbGlzdFwiLFwiaW50ZXJuYWxfYmlmXCIsXCJpb2xpc3Rfc2l6ZVwiLFwiaW9saXN0X3RvX2JpbmFyeVwiLFxuICBcImlzX2FsaXZlXCIsXCJpc19hdG9tXCIsXCJpc19iaW5hcnlcIixcImlzX2JpdHN0cmluZ1wiLFwiaXNfYm9vbGVhblwiLFxuICBcImlzX2Zsb2F0XCIsXCJpc19mdW5jdGlvblwiLFwiaXNfaW50ZWdlclwiLFwiaXNfbGlzdFwiLFwiaXNfbnVtYmVyXCIsXCJpc19waWRcIixcbiAgXCJpc19wb3J0XCIsXCJpc19wcm9jZXNzX2FsaXZlXCIsXCJpc19yZWNvcmRcIixcImlzX3JlZmVyZW5jZVwiLFwiaXNfdHVwbGVcIixcbiAgXCJsZW5ndGhcIixcImxpbmtcIixcImxpc3RfdG9fYXRvbVwiLFwibGlzdF90b19iaW5hcnlcIixcImxpc3RfdG9fYml0c3RyaW5nXCIsXG4gIFwibGlzdF90b19leGlzdGluZ19hdG9tXCIsXCJsaXN0X3RvX2Zsb2F0XCIsXCJsaXN0X3RvX2ludGVnZXJcIixcbiAgXCJsaXN0X3RvX3BpZFwiLFwibGlzdF90b190dXBsZVwiLFwibG9hZF9tb2R1bGVcIixcIm1ha2VfcmVmXCIsXCJtb2R1bGVfbG9hZGVkXCIsXG4gIFwibW9uaXRvcl9ub2RlXCIsXCJub2RlXCIsXCJub2RlX2xpbmtcIixcIm5vZGVfdW5saW5rXCIsXCJub2Rlc1wiLFwibm90YWxpdmVcIixcbiAgXCJub3dcIixcIm9wZW5fcG9ydFwiLFwicGlkX3RvX2xpc3RcIixcInBvcnRfY2xvc2VcIixcInBvcnRfY29tbWFuZFwiLFxuICBcInBvcnRfY29ubmVjdFwiLFwicG9ydF9jb250cm9sXCIsXCJwcmVfbG9hZGVkXCIsXCJwcm9jZXNzX2ZsYWdcIixcbiAgXCJwcm9jZXNzX2luZm9cIixcInByb2Nlc3Nlc1wiLFwicHVyZ2VfbW9kdWxlXCIsXCJwdXRcIixcInJlZ2lzdGVyXCIsXG4gIFwicmVnaXN0ZXJlZFwiLFwicm91bmRcIixcInNlbGZcIixcInNldGVsZW1lbnRcIixcInNpemVcIixcInNwYXduXCIsXCJzcGF3bl9saW5rXCIsXG4gIFwic3Bhd25fbW9uaXRvclwiLFwic3Bhd25fb3B0XCIsXCJzcGxpdF9iaW5hcnlcIixcInN0YXRpc3RpY3NcIixcbiAgXCJ0ZXJtX3RvX2JpbmFyeVwiLFwidGltZVwiLFwidGhyb3dcIixcInRsXCIsXCJ0cnVuY1wiLFwidHVwbGVfc2l6ZVwiLFxuICBcInR1cGxlX3RvX2xpc3RcIixcInVubGlua1wiLFwidW5yZWdpc3RlclwiLFwid2hlcmVpc1wiXTtcblxuLy8gdXBwZXIgY2FzZTogW0EtWl0gW8OYLcOeXSBbw4Atw5ZdXG4vLyBsb3dlciBjYXNlOiBbYS16XSBbw58tw7ZdIFvDuC3Dv11cbnZhciBhbnVtUkUgICAgICAgPSAvW1xcd0DDmC3DnsOALcOWw58tw7bDuC3Dv10vO1xudmFyIGVzY2FwZXNSRSAgICA9XG4gICAgL1swLTddezEsM318W2JkZWZucnN0dlxcXFxcIiddfFxcXlthLXpBLVpdfHhbMC05YS16QS1aXXsyfXx4e1swLTlhLXpBLVpdK30vO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gdG9rZW5pemVyXG5cbmZ1bmN0aW9uIHRva2VuaXplcihzdHJlYW0sc3RhdGUpIHtcbiAgLy8gaW4gbXVsdGktbGluZSBzdHJpbmdcbiAgaWYgKHN0YXRlLmluX3N0cmluZykge1xuICAgIHN0YXRlLmluX3N0cmluZyA9ICghZG91YmxlUXVvdGUoc3RyZWFtKSk7XG4gICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwic3RyaW5nXCIpO1xuICB9XG5cbiAgLy8gaW4gbXVsdGktbGluZSBhdG9tXG4gIGlmIChzdGF0ZS5pbl9hdG9tKSB7XG4gICAgc3RhdGUuaW5fYXRvbSA9ICghc2luZ2xlUXVvdGUoc3RyZWFtKSk7XG4gICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiYXRvbVwiKTtcbiAgfVxuXG4gIC8vIHdoaXRlc3BhY2VcbiAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSB7XG4gICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwid2hpdGVzcGFjZVwiKTtcbiAgfVxuXG4gIC8vIGF0dHJpYnV0ZXMgYW5kIHR5cGUgc3BlY3NcbiAgaWYgKCFwZWVrVG9rZW4oc3RhdGUpICYmXG4gICAgICBzdHJlYW0ubWF0Y2goLy1cXHMqW2EtesOfLcO2w7gtw79dW1xcd8OYLcOew4Atw5bDny3DtsO4LcO/XSovKSkge1xuICAgIGlmIChpc19tZW1iZXIoc3RyZWFtLmN1cnJlbnQoKSx0eXBlV29yZHMpKSB7XG4gICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJ0eXBlXCIpO1xuICAgIH1lbHNle1xuICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiYXR0cmlidXRlXCIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG5cbiAgLy8gY29tbWVudFxuICBpZiAoY2ggPT0gJyUnKSB7XG4gICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImNvbW1lbnRcIik7XG4gIH1cblxuICAvLyBjb2xvblxuICBpZiAoY2ggPT0gXCI6XCIpIHtcbiAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJjb2xvblwiKTtcbiAgfVxuXG4gIC8vIG1hY3JvXG4gIGlmIChjaCA9PSAnPycpIHtcbiAgICBzdHJlYW0uZWF0U3BhY2UoKTtcbiAgICBzdHJlYW0uZWF0V2hpbGUoYW51bVJFKTtcbiAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJtYWNyb1wiKTtcbiAgfVxuXG4gIC8vIHJlY29yZFxuICBpZiAoY2ggPT0gXCIjXCIpIHtcbiAgICBzdHJlYW0uZWF0U3BhY2UoKTtcbiAgICBzdHJlYW0uZWF0V2hpbGUoYW51bVJFKTtcbiAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJyZWNvcmRcIik7XG4gIH1cblxuICAvLyBkb2xsYXIgZXNjYXBlXG4gIGlmIChjaCA9PSBcIiRcIikge1xuICAgIGlmIChzdHJlYW0ubmV4dCgpID09IFwiXFxcXFwiICYmICFzdHJlYW0ubWF0Y2goZXNjYXBlc1JFKSkge1xuICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiZXJyb3JcIik7XG4gICAgfVxuICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcIm51bWJlclwiKTtcbiAgfVxuXG4gIC8vIGRvdFxuICBpZiAoY2ggPT0gXCIuXCIpIHtcbiAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJkb3RcIik7XG4gIH1cblxuICAvLyBxdW90ZWQgYXRvbVxuICBpZiAoY2ggPT0gJ1xcJycpIHtcbiAgICBpZiAoIShzdGF0ZS5pbl9hdG9tID0gKCFzaW5nbGVRdW90ZShzdHJlYW0pKSkpIHtcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL1xccypcXC9cXHMqWzAtOV0vLGZhbHNlKSkge1xuICAgICAgICBzdHJlYW0ubWF0Y2goL1xccypcXC9cXHMqWzAtOV0vLHRydWUpO1xuICAgICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJmdW5cIik7ICAgICAgLy8gJ2YnLzAgc3R5bGUgZnVuXG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9cXHMqXFwoLyxmYWxzZSkgfHwgc3RyZWFtLm1hdGNoKC9cXHMqOi8sZmFsc2UpKSB7XG4gICAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImZ1bmN0aW9uXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJhdG9tXCIpO1xuICB9XG5cbiAgLy8gc3RyaW5nXG4gIGlmIChjaCA9PSAnXCInKSB7XG4gICAgc3RhdGUuaW5fc3RyaW5nID0gKCFkb3VibGVRdW90ZShzdHJlYW0pKTtcbiAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJzdHJpbmdcIik7XG4gIH1cblxuICAvLyB2YXJpYWJsZVxuICBpZiAoL1tBLVpfw5gtw57DgC3Dll0vLnRlc3QoY2gpKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKGFudW1SRSk7XG4gICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwidmFyaWFibGVcIik7XG4gIH1cblxuICAvLyBhdG9tL2tleXdvcmQvQklGL2Z1bmN0aW9uXG4gIGlmICgvW2Etel/Dny3DtsO4LcO/XS8udGVzdChjaCkpIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoYW51bVJFKTtcblxuICAgIGlmIChzdHJlYW0ubWF0Y2goL1xccypcXC9cXHMqWzAtOV0vLGZhbHNlKSkge1xuICAgICAgc3RyZWFtLm1hdGNoKC9cXHMqXFwvXFxzKlswLTldLyx0cnVlKTtcbiAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImZ1blwiKTsgICAgICAvLyBmLzAgc3R5bGUgZnVuXG4gICAgfVxuXG4gICAgdmFyIHcgPSBzdHJlYW0uY3VycmVudCgpO1xuXG4gICAgaWYgKGlzX21lbWJlcih3LGtleXdvcmRXb3JkcykpIHtcbiAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImtleXdvcmRcIik7XG4gICAgfWVsc2UgaWYgKGlzX21lbWJlcih3LG9wZXJhdG9yQXRvbVdvcmRzKSkge1xuICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwib3BlcmF0b3JcIik7XG4gICAgfWVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXFxzKlxcKC8sZmFsc2UpKSB7XG4gICAgICAvLyAncHV0JyBhbmQgJ2VybGFuZzpwdXQnIGFyZSBiaWZzLCAnZm9vOnB1dCcgaXMgbm90XG4gICAgICBpZiAoaXNfbWVtYmVyKHcsYmlmV29yZHMpICYmXG4gICAgICAgICAgKChwZWVrVG9rZW4oc3RhdGUpLnRva2VuICE9IFwiOlwiKSB8fFxuICAgICAgICAgICAocGVla1Rva2VuKHN0YXRlLDIpLnRva2VuID09IFwiZXJsYW5nXCIpKSkge1xuICAgICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJidWlsdGluXCIpO1xuICAgICAgfWVsc2UgaWYgKGlzX21lbWJlcih3LGd1YXJkV29yZHMpKSB7XG4gICAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImd1YXJkXCIpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImZ1bmN0aW9uXCIpO1xuICAgICAgfVxuICAgIH1lbHNlIGlmIChsb29rYWhlYWQoc3RyZWFtKSA9PSBcIjpcIikge1xuICAgICAgaWYgKHcgPT0gXCJlcmxhbmdcIikge1xuICAgICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJidWlsdGluXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiZnVuY3Rpb25cIik7XG4gICAgICB9XG4gICAgfWVsc2UgaWYgKGlzX21lbWJlcih3LFtcInRydWVcIixcImZhbHNlXCJdKSkge1xuICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiYm9vbGVhblwiKTtcbiAgICB9ZWxzZXtcbiAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImF0b21cIik7XG4gICAgfVxuICB9XG5cbiAgLy8gbnVtYmVyXG4gIHZhciBkaWdpdFJFICAgICAgPSAvWzAtOV0vO1xuICB2YXIgcmFkaXhSRSAgICAgID0gL1swLTlhLXpBLVpdLzsgICAgICAgICAvLyAzNiN6WiBzdHlsZSBpbnRcbiAgaWYgKGRpZ2l0UkUudGVzdChjaCkpIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoZGlnaXRSRSk7XG4gICAgaWYgKHN0cmVhbS5lYXQoJyMnKSkgeyAgICAgICAgICAgICAgICAvLyAzNiNhWiAgc3R5bGUgaW50ZWdlclxuICAgICAgaWYgKCFzdHJlYW0uZWF0V2hpbGUocmFkaXhSRSkpIHtcbiAgICAgICAgc3RyZWFtLmJhY2tVcCgxKTsgICAgICAgICAgICAgICAgIC8vXCIzNiNcIiAtIHN5bnRheCBlcnJvclxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdCgnLicpKSB7ICAgICAgIC8vIGZsb2F0XG4gICAgICBpZiAoIXN0cmVhbS5lYXRXaGlsZShkaWdpdFJFKSkge1xuICAgICAgICBzdHJlYW0uYmFja1VwKDEpOyAgICAgICAgLy8gXCIzLlwiIC0gcHJvYmFibHkgZW5kIG9mIGZ1bmN0aW9uXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3RyZWFtLmVhdCgvW2VFXS8pKSB7ICAgICAgICAvLyBmbG9hdCB3aXRoIGV4cG9uZW50XG4gICAgICAgICAgaWYgKHN0cmVhbS5lYXQoL1stK10vKSkge1xuICAgICAgICAgICAgaWYgKCFzdHJlYW0uZWF0V2hpbGUoZGlnaXRSRSkpIHtcbiAgICAgICAgICAgICAgc3RyZWFtLmJhY2tVcCgyKTsgICAgICAgICAgICAvLyBcIjJlLVwiIC0gc3ludGF4IGVycm9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghc3RyZWFtLmVhdFdoaWxlKGRpZ2l0UkUpKSB7XG4gICAgICAgICAgICAgIHN0cmVhbS5iYWNrVXAoMSk7ICAgICAgICAgICAgLy8gXCIyZVwiIC0gc3ludGF4IGVycm9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcIm51bWJlclwiKTsgICAvLyBub3JtYWwgaW50ZWdlclxuICB9XG5cbiAgLy8gb3BlbiBwYXJlbnNcbiAgaWYgKG5vbmdyZWVkeShzdHJlYW0sb3BlblBhcmVuUkUsb3BlblBhcmVuV29yZHMpKSB7XG4gICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwib3Blbl9wYXJlblwiKTtcbiAgfVxuXG4gIC8vIGNsb3NlIHBhcmVuc1xuICBpZiAobm9uZ3JlZWR5KHN0cmVhbSxjbG9zZVBhcmVuUkUsY2xvc2VQYXJlbldvcmRzKSkge1xuICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImNsb3NlX3BhcmVuXCIpO1xuICB9XG5cbiAgLy8gc2VwYXJhdG9yc1xuICBpZiAoZ3JlZWR5KHN0cmVhbSxzZXBhcmF0b3JSRSxzZXBhcmF0b3JXb3JkcykpIHtcbiAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJzZXBhcmF0b3JcIik7XG4gIH1cblxuICAvLyBvcGVyYXRvcnNcbiAgaWYgKGdyZWVkeShzdHJlYW0sb3BlcmF0b3JTeW1ib2xSRSxvcGVyYXRvclN5bWJvbFdvcmRzKSkge1xuICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcIm9wZXJhdG9yXCIpO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLG51bGwpO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gdXRpbGl0aWVzXG5mdW5jdGlvbiBub25ncmVlZHkoc3RyZWFtLHJlLHdvcmRzKSB7XG4gIGlmIChzdHJlYW0uY3VycmVudCgpLmxlbmd0aCA9PSAxICYmIHJlLnRlc3Qoc3RyZWFtLmN1cnJlbnQoKSkpIHtcbiAgICBzdHJlYW0uYmFja1VwKDEpO1xuICAgIHdoaWxlIChyZS50ZXN0KHN0cmVhbS5wZWVrKCkpKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgaWYgKGlzX21lbWJlcihzdHJlYW0uY3VycmVudCgpLHdvcmRzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RyZWFtLmJhY2tVcChzdHJlYW0uY3VycmVudCgpLmxlbmd0aC0xKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdyZWVkeShzdHJlYW0scmUsd29yZHMpIHtcbiAgaWYgKHN0cmVhbS5jdXJyZW50KCkubGVuZ3RoID09IDEgJiYgcmUudGVzdChzdHJlYW0uY3VycmVudCgpKSkge1xuICAgIHdoaWxlIChyZS50ZXN0KHN0cmVhbS5wZWVrKCkpKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgIH1cbiAgICB3aGlsZSAoMCA8IHN0cmVhbS5jdXJyZW50KCkubGVuZ3RoKSB7XG4gICAgICBpZiAoaXNfbWVtYmVyKHN0cmVhbS5jdXJyZW50KCksd29yZHMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHN0cmVhbS5iYWNrVXAoMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHN0cmVhbS5uZXh0KCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBkb3VibGVRdW90ZShzdHJlYW0pIHtcbiAgcmV0dXJuIHF1b3RlKHN0cmVhbSwgJ1wiJywgJ1xcXFwnKTtcbn1cblxuZnVuY3Rpb24gc2luZ2xlUXVvdGUoc3RyZWFtKSB7XG4gIHJldHVybiBxdW90ZShzdHJlYW0sJ1xcJycsJ1xcXFwnKTtcbn1cblxuZnVuY3Rpb24gcXVvdGUoc3RyZWFtLHF1b3RlQ2hhcixlc2NhcGVDaGFyKSB7XG4gIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgICBpZiAoY2ggPT0gcXVvdGVDaGFyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9ZWxzZSBpZiAoY2ggPT0gZXNjYXBlQ2hhcikge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsb29rYWhlYWQoc3RyZWFtKSB7XG4gIHZhciBtID0gc3RyZWFtLm1hdGNoKC9eXFxzKihbXlxccyVdKS8sIGZhbHNlKVxuICByZXR1cm4gbSA/IG1bMV0gOiBcIlwiO1xufVxuXG5mdW5jdGlvbiBpc19tZW1iZXIoZWxlbWVudCxsaXN0KSB7XG4gIHJldHVybiAoLTEgPCBsaXN0LmluZGV4T2YoZWxlbWVudCkpO1xufVxuXG5mdW5jdGlvbiBydmFsKHN0YXRlLHN0cmVhbSx0eXBlKSB7XG5cbiAgLy8gcGFyc2Ugc3RhY2tcbiAgcHVzaFRva2VuKHN0YXRlLHJlYWxUb2tlbih0eXBlLHN0cmVhbSkpO1xuXG4gIC8vIG1hcCBlcmxhbmcgdG9rZW4gdHlwZSB0byBDb2RlTWlycm9yIHN0eWxlIGNsYXNzXG4gIC8vICAgICBlcmxhbmcgICAgICAgICAgICAgLT4gQ29kZU1pcnJvciB0YWdcbiAgc3dpdGNoICh0eXBlKSB7XG4gIGNhc2UgXCJhdG9tXCI6ICAgICAgICByZXR1cm4gXCJhdG9tXCI7XG4gIGNhc2UgXCJhdHRyaWJ1dGVcIjogICByZXR1cm4gXCJhdHRyaWJ1dGVcIjtcbiAgY2FzZSBcImJvb2xlYW5cIjogICAgIHJldHVybiBcImF0b21cIjtcbiAgY2FzZSBcImJ1aWx0aW5cIjogICAgIHJldHVybiBcImJ1aWx0aW5cIjtcbiAgY2FzZSBcImNsb3NlX3BhcmVuXCI6IHJldHVybiBudWxsO1xuICBjYXNlIFwiY29sb25cIjogICAgICAgcmV0dXJuIG51bGw7XG4gIGNhc2UgXCJjb21tZW50XCI6ICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIGNhc2UgXCJkb3RcIjogICAgICAgICByZXR1cm4gbnVsbDtcbiAgY2FzZSBcImVycm9yXCI6ICAgICAgIHJldHVybiBcImVycm9yXCI7XG4gIGNhc2UgXCJmdW5cIjogICAgICAgICByZXR1cm4gXCJtZXRhXCI7XG4gIGNhc2UgXCJmdW5jdGlvblwiOiAgICByZXR1cm4gXCJ0YWdcIjtcbiAgY2FzZSBcImd1YXJkXCI6ICAgICAgIHJldHVybiBcInByb3BlcnR5XCI7XG4gIGNhc2UgXCJrZXl3b3JkXCI6ICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gIGNhc2UgXCJtYWNyb1wiOiAgICAgICByZXR1cm4gXCJtYWNyb05hbWVcIjtcbiAgY2FzZSBcIm51bWJlclwiOiAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICBjYXNlIFwib3Blbl9wYXJlblwiOiAgcmV0dXJuIG51bGw7XG4gIGNhc2UgXCJvcGVyYXRvclwiOiAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICBjYXNlIFwicmVjb3JkXCI6ICAgICAgcmV0dXJuIFwiYnJhY2tldFwiO1xuICBjYXNlIFwic2VwYXJhdG9yXCI6ICAgcmV0dXJuIG51bGw7XG4gIGNhc2UgXCJzdHJpbmdcIjogICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgY2FzZSBcInR5cGVcIjogICAgICAgIHJldHVybiBcImRlZlwiO1xuICBjYXNlIFwidmFyaWFibGVcIjogICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgZGVmYXVsdDogICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBhVG9rZW4odG9rLGNvbCxpbmQsdHlwKSB7XG4gIHJldHVybiB7dG9rZW46ICB0b2ssXG4gICAgICAgICAgY29sdW1uOiBjb2wsXG4gICAgICAgICAgaW5kZW50OiBpbmQsXG4gICAgICAgICAgdHlwZTogICB0eXB9O1xufVxuXG5mdW5jdGlvbiByZWFsVG9rZW4odHlwZSxzdHJlYW0pIHtcbiAgcmV0dXJuIGFUb2tlbihzdHJlYW0uY3VycmVudCgpLFxuICAgICAgICAgICAgICAgIHN0cmVhbS5jb2x1bW4oKSxcbiAgICAgICAgICAgICAgICBzdHJlYW0uaW5kZW50YXRpb24oKSxcbiAgICAgICAgICAgICAgICB0eXBlKTtcbn1cblxuZnVuY3Rpb24gZmFrZVRva2VuKHR5cGUpIHtcbiAgcmV0dXJuIGFUb2tlbih0eXBlLDAsMCx0eXBlKTtcbn1cblxuZnVuY3Rpb24gcGVla1Rva2VuKHN0YXRlLGRlcHRoKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS50b2tlblN0YWNrLmxlbmd0aDtcbiAgdmFyIGRlcCA9IChkZXB0aCA/IGRlcHRoIDogMSk7XG5cbiAgaWYgKGxlbiA8IGRlcCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfWVsc2V7XG4gICAgcmV0dXJuIHN0YXRlLnRva2VuU3RhY2tbbGVuLWRlcF07XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaFRva2VuKHN0YXRlLHRva2VuKSB7XG5cbiAgaWYgKCEodG9rZW4udHlwZSA9PSBcImNvbW1lbnRcIiB8fCB0b2tlbi50eXBlID09IFwid2hpdGVzcGFjZVwiKSkge1xuICAgIHN0YXRlLnRva2VuU3RhY2sgPSBtYXliZV9kcm9wX3ByZShzdGF0ZS50b2tlblN0YWNrLHRva2VuKTtcbiAgICBzdGF0ZS50b2tlblN0YWNrID0gbWF5YmVfZHJvcF9wb3N0KHN0YXRlLnRva2VuU3RhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlX2Ryb3BfcHJlKHMsdG9rZW4pIHtcbiAgdmFyIGxhc3QgPSBzLmxlbmd0aC0xO1xuXG4gIGlmICgwIDwgbGFzdCAmJiBzW2xhc3RdLnR5cGUgPT09IFwicmVjb3JkXCIgJiYgdG9rZW4udHlwZSA9PT0gXCJkb3RcIikge1xuICAgIHMucG9wKCk7XG4gIH1lbHNlIGlmICgwIDwgbGFzdCAmJiBzW2xhc3RdLnR5cGUgPT09IFwiZ3JvdXBcIikge1xuICAgIHMucG9wKCk7XG4gICAgcy5wdXNoKHRva2VuKTtcbiAgfWVsc2V7XG4gICAgcy5wdXNoKHRva2VuKTtcbiAgfVxuICByZXR1cm4gcztcbn1cblxuZnVuY3Rpb24gbWF5YmVfZHJvcF9wb3N0KHMpIHtcbiAgaWYgKCFzLmxlbmd0aCkgcmV0dXJuIHNcbiAgdmFyIGxhc3QgPSBzLmxlbmd0aC0xO1xuXG4gIGlmIChzW2xhc3RdLnR5cGUgPT09IFwiZG90XCIpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKGxhc3QgPiAxICYmIHNbbGFzdF0udHlwZSA9PT0gXCJmdW5cIiAmJiBzW2xhc3QtMV0udG9rZW4gPT09IFwiZnVuXCIpIHtcbiAgICByZXR1cm4gcy5zbGljZSgwLGxhc3QtMSk7XG4gIH1cbiAgc3dpdGNoIChzW2xhc3RdLnRva2VuKSB7XG4gIGNhc2UgXCJ9XCI6ICAgIHJldHVybiBkKHMse2c6W1wie1wiXX0pO1xuICBjYXNlIFwiXVwiOiAgICByZXR1cm4gZChzLHtpOltcIltcIl19KTtcbiAgY2FzZSBcIilcIjogICAgcmV0dXJuIGQocyx7aTpbXCIoXCJdfSk7XG4gIGNhc2UgXCI+PlwiOiAgIHJldHVybiBkKHMse2k6W1wiPDxcIl19KTtcbiAgY2FzZSBcImVuZFwiOiAgcmV0dXJuIGQocyx7aTpbXCJiZWdpblwiLFwiY2FzZVwiLFwiZnVuXCIsXCJpZlwiLFwicmVjZWl2ZVwiLFwidHJ5XCJdfSk7XG4gIGNhc2UgXCIsXCI6ICAgIHJldHVybiBkKHMse2U6W1wiYmVnaW5cIixcInRyeVwiLFwid2hlblwiLFwiLT5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFwiLFwiKFwiLFwiW1wiLFwie1wiLFwiPDxcIl19KTtcbiAgY2FzZSBcIi0+XCI6ICAgcmV0dXJuIGQocyx7cjpbXCJ3aGVuXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbTpbXCJ0cnlcIixcImlmXCIsXCJjYXNlXCIsXCJyZWNlaXZlXCJdfSk7XG4gIGNhc2UgXCI7XCI6ICAgIHJldHVybiBkKHMse0U6W1wiY2FzZVwiLFwiZnVuXCIsXCJpZlwiLFwicmVjZWl2ZVwiLFwidHJ5XCIsXCJ3aGVuXCJdfSk7XG4gIGNhc2UgXCJjYXRjaFwiOnJldHVybiBkKHMse2U6W1widHJ5XCJdfSk7XG4gIGNhc2UgXCJvZlwiOiAgIHJldHVybiBkKHMse2U6W1wiY2FzZVwiXX0pO1xuICBjYXNlIFwiYWZ0ZXJcIjpyZXR1cm4gZChzLHtlOltcInJlY2VpdmVcIixcInRyeVwiXX0pO1xuICBkZWZhdWx0OiAgICAgcmV0dXJuIHM7XG4gIH1cbn1cblxuZnVuY3Rpb24gZChzdGFjayx0dCkge1xuICAvLyBzdGFjayBpcyBhIHN0YWNrIG9mIFRva2VuIG9iamVjdHMuXG4gIC8vIHR0IGlzIGFuIG9iamVjdDsge3R5cGU6dG9rZW5zfVxuICAvLyB0eXBlIGlzIGEgY2hhciwgdG9rZW5zIGlzIGEgbGlzdCBvZiB0b2tlbiBzdHJpbmdzLlxuICAvLyBUaGUgZnVuY3Rpb24gcmV0dXJucyAocG9zc2libHkgdHJ1bmNhdGVkKSBzdGFjay5cbiAgLy8gSXQgd2lsbCBkZXNjZW5kIHRoZSBzdGFjaywgbG9va2luZyBmb3IgYSBUb2tlbiBzdWNoIHRoYXQgVG9rZW4udG9rZW5cbiAgLy8gIGlzIGEgbWVtYmVyIG9mIHRva2Vucy4gSWYgaXQgZG9lcyBub3QgZmluZCB0aGF0LCBpdCB3aWxsIG5vcm1hbGx5IChidXRcbiAgLy8gIHNlZSBcIkVcIiBiZWxvdykgcmV0dXJuIHN0YWNrLiBJZiBpdCBkb2VzIGZpbmQgYSBtYXRjaCwgaXQgd2lsbCByZW1vdmVcbiAgLy8gIGFsbCB0aGUgVG9rZW5zIGJldHdlZW4gdGhlIHRvcCBhbmQgdGhlIG1hdGNoZWQgVG9rZW4uXG4gIC8vIElmIHR5cGUgaXMgXCJtXCIsIHRoYXQgaXMgYWxsIGl0IGRvZXMuXG4gIC8vIElmIHR5cGUgaXMgXCJpXCIsIGl0IHdpbGwgYWxzbyByZW1vdmUgdGhlIG1hdGNoZWQgVG9rZW4gYW5kIHRoZSB0b3AgVG9rZW4uXG4gIC8vIElmIHR5cGUgaXMgXCJnXCIsIGxpa2UgXCJpXCIsIGJ1dCBhZGQgYSBmYWtlIFwiZ3JvdXBcIiB0b2tlbiBhdCB0aGUgdG9wLlxuICAvLyBJZiB0eXBlIGlzIFwiclwiLCBpdCB3aWxsIHJlbW92ZSB0aGUgbWF0Y2hlZCBUb2tlbiwgYnV0IG5vdCB0aGUgdG9wIFRva2VuLlxuICAvLyBJZiB0eXBlIGlzIFwiZVwiLCBpdCB3aWxsIGtlZXAgdGhlIG1hdGNoZWQgVG9rZW4gYnV0IG5vdCB0aGUgdG9wIFRva2VuLlxuICAvLyBJZiB0eXBlIGlzIFwiRVwiLCBpdCBiZWhhdmVzIGFzIGZvciB0eXBlIFwiZVwiLCBleGNlcHQgaWYgdGhlcmUgaXMgbm8gbWF0Y2gsXG4gIC8vICBpbiB3aGljaCBjYXNlIGl0IHdpbGwgcmV0dXJuIGFuIGVtcHR5IHN0YWNrLlxuXG4gIGZvciAodmFyIHR5cGUgaW4gdHQpIHtcbiAgICB2YXIgbGVuID0gc3RhY2subGVuZ3RoLTE7XG4gICAgdmFyIHRva2VucyA9IHR0W3R5cGVdO1xuICAgIGZvciAodmFyIGkgPSBsZW4tMTsgLTEgPCBpIDsgaS0tKSB7XG4gICAgICBpZiAoaXNfbWVtYmVyKHN0YWNrW2ldLnRva2VuLHRva2VucykpIHtcbiAgICAgICAgdmFyIHNzID0gc3RhY2suc2xpY2UoMCxpKTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJtXCI6IHJldHVybiBzcy5jb25jYXQoc3RhY2tbaV0pLmNvbmNhdChzdGFja1tsZW5dKTtcbiAgICAgICAgY2FzZSBcInJcIjogcmV0dXJuIHNzLmNvbmNhdChzdGFja1tsZW5dKTtcbiAgICAgICAgY2FzZSBcImlcIjogcmV0dXJuIHNzO1xuICAgICAgICBjYXNlIFwiZ1wiOiByZXR1cm4gc3MuY29uY2F0KGZha2VUb2tlbihcImdyb3VwXCIpKTtcbiAgICAgICAgY2FzZSBcIkVcIjogcmV0dXJuIHNzLmNvbmNhdChzdGFja1tpXSk7XG4gICAgICAgIGNhc2UgXCJlXCI6IHJldHVybiBzcy5jb25jYXQoc3RhY2tbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAodHlwZSA9PSBcIkVcIiA/IFtdIDogc3RhY2spO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gaW5kZW50ZXJcblxuZnVuY3Rpb24gaW5kZW50ZXIoc3RhdGUsIHRleHRBZnRlciwgY3gpIHtcbiAgdmFyIHQ7XG4gIHZhciB3b3JkQWZ0ZXIgPSB3b3JkYWZ0ZXIodGV4dEFmdGVyKTtcbiAgdmFyIGN1cnJUID0gcGVla1Rva2VuKHN0YXRlLDEpO1xuICB2YXIgcHJldlQgPSBwZWVrVG9rZW4oc3RhdGUsMik7XG5cbiAgaWYgKHN0YXRlLmluX3N0cmluZyB8fCBzdGF0ZS5pbl9hdG9tKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1lbHNlIGlmICghcHJldlQpIHtcbiAgICByZXR1cm4gMDtcbiAgfWVsc2UgaWYgKGN1cnJULnRva2VuID09IFwid2hlblwiKSB7XG4gICAgcmV0dXJuIGN1cnJULmNvbHVtbiArIGN4LnVuaXQ7XG4gIH1lbHNlIGlmICh3b3JkQWZ0ZXIgPT09IFwid2hlblwiICYmIHByZXZULnR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBwcmV2VC5pbmRlbnQrY3gudW5pdDtcbiAgfWVsc2UgaWYgKHdvcmRBZnRlciA9PT0gXCIoXCIgJiYgY3VyclQudG9rZW4gPT09IFwiZnVuXCIpIHtcbiAgICByZXR1cm4gIGN1cnJULmNvbHVtbiszO1xuICB9ZWxzZSBpZiAod29yZEFmdGVyID09PSBcImNhdGNoXCIgJiYgKHQgPSBnZXRUb2tlbihzdGF0ZSxbXCJ0cnlcIl0pKSkge1xuICAgIHJldHVybiB0LmNvbHVtbjtcbiAgfWVsc2UgaWYgKGlzX21lbWJlcih3b3JkQWZ0ZXIsW1wiZW5kXCIsXCJhZnRlclwiLFwib2ZcIl0pKSB7XG4gICAgdCA9IGdldFRva2VuKHN0YXRlLFtcImJlZ2luXCIsXCJjYXNlXCIsXCJmdW5cIixcImlmXCIsXCJyZWNlaXZlXCIsXCJ0cnlcIl0pO1xuICAgIHJldHVybiB0ID8gdC5jb2x1bW4gOiBudWxsO1xuICB9ZWxzZSBpZiAoaXNfbWVtYmVyKHdvcmRBZnRlcixjbG9zZVBhcmVuV29yZHMpKSB7XG4gICAgdCA9IGdldFRva2VuKHN0YXRlLG9wZW5QYXJlbldvcmRzKTtcbiAgICByZXR1cm4gdCA/IHQuY29sdW1uIDogbnVsbDtcbiAgfWVsc2UgaWYgKGlzX21lbWJlcihjdXJyVC50b2tlbixbXCIsXCIsXCJ8XCIsXCJ8fFwiXSkgfHxcbiAgICAgICAgICAgIGlzX21lbWJlcih3b3JkQWZ0ZXIsW1wiLFwiLFwifFwiLFwifHxcIl0pKSB7XG4gICAgdCA9IHBvc3Rjb21tYVRva2VuKHN0YXRlKTtcbiAgICByZXR1cm4gdCA/IHQuY29sdW1uK3QudG9rZW4ubGVuZ3RoIDogY3gudW5pdDtcbiAgfWVsc2UgaWYgKGN1cnJULnRva2VuID09IFwiLT5cIikge1xuICAgIGlmIChpc19tZW1iZXIocHJldlQudG9rZW4sIFtcInJlY2VpdmVcIixcImNhc2VcIixcImlmXCIsXCJ0cnlcIl0pKSB7XG4gICAgICByZXR1cm4gcHJldlQuY29sdW1uK2N4LnVuaXQrY3gudW5pdDtcbiAgICB9ZWxzZXtcbiAgICAgIHJldHVybiBwcmV2VC5jb2x1bW4rY3gudW5pdDtcbiAgICB9XG4gIH1lbHNlIGlmIChpc19tZW1iZXIoY3VyclQudG9rZW4sb3BlblBhcmVuV29yZHMpKSB7XG4gICAgcmV0dXJuIGN1cnJULmNvbHVtbitjdXJyVC50b2tlbi5sZW5ndGg7XG4gIH1lbHNle1xuICAgIHQgPSBkZWZhdWx0VG9rZW4oc3RhdGUpO1xuICAgIHJldHVybiB0cnV0aHkodCkgPyB0LmNvbHVtbitjeC51bml0IDogMDtcbiAgfVxufVxuXG5mdW5jdGlvbiB3b3JkYWZ0ZXIoc3RyKSB7XG4gIHZhciBtID0gc3RyLm1hdGNoKC8sfFthLXpdK3xcXH18XFxdfFxcKXw+PnxcXHwrfFxcKC8pO1xuXG4gIHJldHVybiB0cnV0aHkobSkgJiYgKG0uaW5kZXggPT09IDApID8gbVswXSA6IFwiXCI7XG59XG5cbmZ1bmN0aW9uIHBvc3Rjb21tYVRva2VuKHN0YXRlKSB7XG4gIHZhciBvYmpzID0gc3RhdGUudG9rZW5TdGFjay5zbGljZSgwLC0xKTtcbiAgdmFyIGkgPSBnZXRUb2tlbkluZGV4KG9ianMsXCJ0eXBlXCIsW1wib3Blbl9wYXJlblwiXSk7XG5cbiAgcmV0dXJuIHRydXRoeShvYmpzW2ldKSA/IG9ianNbaV0gOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRva2VuKHN0YXRlKSB7XG4gIHZhciBvYmpzID0gc3RhdGUudG9rZW5TdGFjaztcbiAgdmFyIHN0b3AgPSBnZXRUb2tlbkluZGV4KG9ianMsXCJ0eXBlXCIsW1wib3Blbl9wYXJlblwiLFwic2VwYXJhdG9yXCIsXCJrZXl3b3JkXCJdKTtcbiAgdmFyIG9wZXIgPSBnZXRUb2tlbkluZGV4KG9ianMsXCJ0eXBlXCIsW1wib3BlcmF0b3JcIl0pO1xuXG4gIGlmICh0cnV0aHkoc3RvcCkgJiYgdHJ1dGh5KG9wZXIpICYmIHN0b3AgPCBvcGVyKSB7XG4gICAgcmV0dXJuIG9ianNbc3RvcCsxXTtcbiAgfSBlbHNlIGlmICh0cnV0aHkoc3RvcCkpIHtcbiAgICByZXR1cm4gb2Jqc1tzdG9wXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VG9rZW4oc3RhdGUsdG9rZW5zKSB7XG4gIHZhciBvYmpzID0gc3RhdGUudG9rZW5TdGFjaztcbiAgdmFyIGkgPSBnZXRUb2tlbkluZGV4KG9ianMsXCJ0b2tlblwiLHRva2Vucyk7XG5cbiAgcmV0dXJuIHRydXRoeShvYmpzW2ldKSA/IG9ianNbaV0gOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0VG9rZW5JbmRleChvYmpzLHByb3BuYW1lLHByb3B2YWxzKSB7XG5cbiAgZm9yICh2YXIgaSA9IG9ianMubGVuZ3RoLTE7IC0xIDwgaSA7IGktLSkge1xuICAgIGlmIChpc19tZW1iZXIob2Jqc1tpXVtwcm9wbmFtZV0scHJvcHZhbHMpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB0cnV0aHkoeCkge1xuICByZXR1cm4gKHggIT09IGZhbHNlKSAmJiAoeCAhPSBudWxsKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIHRoaXMgb2JqZWN0IGRlZmluZXMgdGhlIG1vZGVcblxuZXhwb3J0IGNvbnN0IGVybGFuZyA9IHtcbiAgc3RhcnRTdGF0ZSgpIHtcbiAgICByZXR1cm4ge3Rva2VuU3RhY2s6IFtdLFxuICAgICAgICAgICAgaW5fc3RyaW5nOiAgZmFsc2UsXG4gICAgICAgICAgICBpbl9hdG9tOiAgICBmYWxzZX07XG4gIH0sXG5cbiAgdG9rZW46IHRva2VuaXplcixcblxuICBpbmRlbnQ6IGluZGVudGVyLFxuXG4gIGxhbmd1YWdlRGF0YToge1xuICAgIGNvbW1lbnRUb2tlbnM6IHtsaW5lOiBcIiVcIn1cbiAgfVxufTtcblxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///379\n')}}]);