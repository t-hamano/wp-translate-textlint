(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{417:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sass", function() { return sass; });\n/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(144);\n\nconst propertyKeywords = new Set(_css_js__WEBPACK_IMPORTED_MODULE_0__["keywords"].properties)\nconst colorKeywords = new Set(_css_js__WEBPACK_IMPORTED_MODULE_0__["keywords"].colors)\nconst valueKeywords = new Set(_css_js__WEBPACK_IMPORTED_MODULE_0__["keywords"].values)\nconst fontProperties = new Set(_css_js__WEBPACK_IMPORTED_MODULE_0__["keywords"].fonts)\n\nfunction tokenRegexp(words) {\n  return new RegExp("^" + words.join("|"))\n}\n\nlet keywords = ["true", "false", "null", "auto"]\nlet keywordsRegexp = new RegExp("^" + keywords.join("|"))\n\nlet operators = ["\\\\(", "\\\\)", "=", ">", "<", "==", ">=", "<=", "\\\\+", "-",\n                 "\\\\!=", "/", "\\\\*", "%", "and", "or", "not", ";","\\\\{","\\\\}",":"]\nlet opRegexp = tokenRegexp(operators)\n\nlet pseudoElementsRegexp = /^::?[a-zA-Z_][\\w\\-]*/\n\nlet word\n\nfunction isEndLine(stream) {\n  return !stream.peek() || stream.match(/\\s+$/, false)\n}\n\nfunction urlTokens(stream, state) {\n  let ch = stream.peek()\n\n  if (ch === ")") {\n    stream.next()\n    state.tokenizer = tokenBase\n    return "operator"\n  } else if (ch === "(") {\n    stream.next()\n    stream.eatSpace()\n\n    return "operator"\n  } else if (ch === "\'" || ch === \'"\') {\n    state.tokenizer = buildStringTokenizer(stream.next())\n    return "string"\n  } else {\n    state.tokenizer = buildStringTokenizer(")", false)\n    return "string"\n  }\n}\nfunction comment(indentation, multiLine) {\n  return function(stream, state) {\n    if (stream.sol() && stream.indentation() <= indentation) {\n      state.tokenizer = tokenBase\n      return tokenBase(stream, state)\n    }\n\n    if (multiLine && stream.skipTo("*/")) {\n      stream.next()\n      stream.next()\n      state.tokenizer = tokenBase\n    } else {\n      stream.skipToEnd()\n    }\n\n    return "comment"\n  }\n}\n\nfunction buildStringTokenizer(quote, greedy) {\n  if (greedy == null) { greedy = true }\n\n  function stringTokenizer(stream, state) {\n    let nextChar = stream.next()\n    let peekChar = stream.peek()\n    let previousChar = stream.string.charAt(stream.pos-2)\n\n    let endingString = ((nextChar !== "\\\\" && peekChar === quote) || (nextChar === quote && previousChar !== "\\\\"))\n\n    if (endingString) {\n      if (nextChar !== quote && greedy) { stream.next() }\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0\n      }\n      state.tokenizer = tokenBase\n      return "string"\n    } else if (nextChar === "#" && peekChar === "{") {\n      state.tokenizer = buildInterpolationTokenizer(stringTokenizer)\n      stream.next()\n      return "operator"\n    } else {\n      return "string"\n    }\n  }\n\n  return stringTokenizer\n}\n\nfunction buildInterpolationTokenizer(currentTokenizer) {\n  return function(stream, state) {\n    if (stream.peek() === "}") {\n      stream.next()\n      state.tokenizer = currentTokenizer\n      return "operator"\n    } else {\n      return tokenBase(stream, state)\n    }\n  }\n}\n\nfunction indent(state, stream) {\n  if (state.indentCount == 0) {\n    state.indentCount++\n    let lastScopeOffset = state.scopes[0].offset\n    let currentOffset = lastScopeOffset + stream.indentUnit\n    state.scopes.unshift({ offset:currentOffset })\n  }\n}\n\nfunction dedent(state) {\n  if (state.scopes.length == 1) return\n\n  state.scopes.shift()\n}\n\nfunction tokenBase(stream, state) {\n  let ch = stream.peek()\n\n  // Comment\n  if (stream.match("/*")) {\n    state.tokenizer = comment(stream.indentation(), true)\n    return state.tokenizer(stream, state)\n  }\n  if (stream.match("//")) {\n    state.tokenizer = comment(stream.indentation(), false)\n    return state.tokenizer(stream, state)\n  }\n\n  // Interpolation\n  if (stream.match("#{")) {\n    state.tokenizer = buildInterpolationTokenizer(tokenBase)\n    return "operator"\n  }\n\n  // Strings\n  if (ch === \'"\' || ch === "\'") {\n    stream.next()\n    state.tokenizer = buildStringTokenizer(ch)\n    return "string"\n  }\n\n  if (!state.cursorHalf) {\n    // first half i.e. before : for key-value pairs\n    // including selectors\n    if (ch === "-") {\n      if (stream.match(/^-\\w+-/)) {\n        return "meta"\n      }\n    }\n\n    if (ch === ".") {\n      stream.next()\n      if (stream.match(/^[\\w-]+/)) {\n        indent(state, stream)\n        return "qualifier"\n      } else if (stream.peek() === "#") {\n        indent(state, stream)\n        return "tag"\n      }\n    }\n\n    if (ch === "#") {\n      stream.next()\n      // ID selectors\n      if (stream.match(/^[\\w-]+/)) {\n        indent(state, stream)\n        return "builtin"\n      }\n      if (stream.peek() === "#") {\n        indent(state, stream)\n        return "tag"\n      }\n    }\n\n    // Variables\n    if (ch === "$") {\n      stream.next()\n      stream.eatWhile(/[\\w-]/)\n      return "variable-2"\n    }\n\n    // Numbers\n    if (stream.match(/^-?[0-9\\.]+/))\n      return "number"\n\n    // Units\n    if (stream.match(/^(px|em|in)\\b/))\n      return "unit"\n\n    if (stream.match(keywordsRegexp))\n      return "keyword"\n\n    if (stream.match(/^url/) && stream.peek() === "(") {\n      state.tokenizer = urlTokens\n      return "atom"\n    }\n\n    if (ch === "=") {\n      // Match shortcut mixin definition\n      if (stream.match(/^=[\\w-]+/)) {\n        indent(state, stream)\n        return "meta"\n      }\n    }\n\n    if (ch === "+") {\n      // Match shortcut mixin definition\n      if (stream.match(/^\\+[\\w-]+/)) {\n        return "meta"\n      }\n    }\n\n    if (ch === "@") {\n      if (stream.match(\'@extend\')) {\n        if (!stream.match(/\\s*[\\w]/))\n          dedent(state)\n      }\n    }\n\n\n    // Indent Directives\n    if (stream.match(/^@(else if|if|media|else|for|each|while|mixin|function)/)) {\n      indent(state, stream)\n      return "def"\n    }\n\n    // Other Directives\n    if (ch === "@") {\n      stream.next()\n      stream.eatWhile(/[\\w-]/)\n      return "def"\n    }\n\n    if (stream.eatWhile(/[\\w-]/)) {\n      if (stream.match(/ *: *[\\w-\\+\\$#!\\("\']/,false)) {\n        word = stream.current().toLowerCase()\n        let prop = state.prevProp + "-" + word\n        if (propertyKeywords.has(prop)) {\n          return "property"\n        } else if (propertyKeywords.has(word)) {\n          state.prevProp = word\n          return "property"\n        } else if (fontProperties.has(word)) {\n          return "property"\n        }\n        return "tag"\n      } else if (stream.match(/ *:/,false)) {\n        indent(state, stream)\n        state.cursorHalf = 1\n        state.prevProp = stream.current().toLowerCase()\n        return "property"\n      } else if (stream.match(/ *,/,false)) {\n        return "tag"\n      } else {\n        indent(state, stream)\n        return "tag"\n      }\n    }\n\n    if (ch === ":") {\n      if (stream.match(pseudoElementsRegexp)) { // could be a pseudo-element\n        return "type"\n      }\n      stream.next()\n      state.cursorHalf=1\n      return "operator"\n    }\n  } else {\n    if (ch === "#") {\n      stream.next()\n      // Hex numbers\n      if (stream.match(/[0-9a-fA-F]{6}|[0-9a-fA-F]{3}/)) {\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0\n        }\n        return "number"\n      }\n    }\n\n    // Numbers\n    if (stream.match(/^-?[0-9\\.]+/)) {\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0\n      }\n      return "number"\n    }\n\n    // Units\n    if (stream.match(/^(px|em|in)\\b/)) {\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0\n      }\n      return "unit"\n    }\n\n    if (stream.match(keywordsRegexp)) {\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0\n      }\n      return "keyword"\n    }\n\n    if (stream.match(/^url/) && stream.peek() === "(") {\n      state.tokenizer = urlTokens\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0\n      }\n      return "atom"\n    }\n\n    // Variables\n    if (ch === "$") {\n      stream.next()\n      stream.eatWhile(/[\\w-]/)\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0\n      }\n      return "variable-2"\n    }\n\n    // bang character for !important, !default, etc.\n    if (ch === "!") {\n      stream.next()\n      state.cursorHalf = 0\n      return stream.match(/^[\\w]+/) ? "keyword": "operator"\n    }\n\n    if (stream.match(opRegexp)) {\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0\n      }\n      return "operator"\n    }\n\n    // attributes\n    if (stream.eatWhile(/[\\w-]/)) {\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0\n      }\n      word = stream.current().toLowerCase()\n      if (valueKeywords.has(word)) {\n        return "atom"\n      } else if (colorKeywords.has(word)) {\n        return "keyword"\n      } else if (propertyKeywords.has(word)) {\n        state.prevProp = stream.current().toLowerCase()\n        return "property"\n      } else {\n        return "tag"\n      }\n    }\n\n    if (isEndLine(stream)) {\n      state.cursorHalf = 0\n      return null\n    }\n  }\n\n  if (stream.match(opRegexp))\n    return "operator"\n\n  stream.next()\n  return null\n}\n\nfunction tokenLexer(stream, state) {\n  if (stream.sol()) state.indentCount = 0\n  let style = state.tokenizer(stream, state)\n  let current = stream.current()\n\n  if (current === "@return" || current === "}") {\n    dedent(state)\n  }\n\n  if (style !== null) {\n    let startOfToken = stream.pos - current.length\n\n    let withCurrentIndent = startOfToken + (stream.indentUnit * state.indentCount)\n\n    let newScopes = []\n\n    for (let i = 0; i < state.scopes.length; i++) {\n      let scope = state.scopes[i]\n\n      if (scope.offset <= withCurrentIndent)\n        newScopes.push(scope)\n    }\n\n    state.scopes = newScopes\n  }\n\n  return style\n}\n\nconst sass = {\n  startState: function() {\n    return {\n      tokenizer: tokenBase,\n      scopes: [{offset: 0, type: "sass"}],\n      indentCount: 0,\n      cursorHalf: 0,  // cursor half tells us if cursor lies after (1)\n      // or before (0) colon (well... more or less)\n      definedVars: [],\n      definedMixins: []\n    }\n  },\n  token: function(stream, state) {\n    let style = tokenLexer(stream, state)\n    state.lastToken = { style: style, content: stream.current() }\n    return style\n  },\n\n  indent: function(state) {\n    return state.scopes[0].offset\n  },\n\n  languageData: {\n    commentTokens: {line: "//", block: {open: "/*", close: "*/"}},\n    autocomplete: _css_js__WEBPACK_IMPORTED_MODULE_0__["keywords"].all\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvc2Fzcy5qcz8yZWY3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFnRDtBQUNoRCxpQ0FBaUMsZ0RBQVc7QUFDNUMsOEJBQThCLGdEQUFXO0FBQ3pDLDhCQUE4QixnREFBVztBQUN6QywrQkFBK0IsZ0RBQVc7O0FBRTFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0VBQWdFLE1BQU0sTUFBTTtBQUM1RTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDZDQUE2QztBQUNsRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsRUFBRSxhQUFhLEVBQUU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIseUJBQXlCO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLG9CQUFvQixvQkFBb0IseUJBQXlCO0FBQ2pFLGtCQUFrQixnREFBVztBQUM3QjtBQUNBIiwiZmlsZSI6IjQxNy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7a2V5d29yZHMgYXMgY3NzS2V5d29yZHN9IGZyb20gXCIuL2Nzcy5qc1wiXG5jb25zdCBwcm9wZXJ0eUtleXdvcmRzID0gbmV3IFNldChjc3NLZXl3b3Jkcy5wcm9wZXJ0aWVzKVxuY29uc3QgY29sb3JLZXl3b3JkcyA9IG5ldyBTZXQoY3NzS2V5d29yZHMuY29sb3JzKVxuY29uc3QgdmFsdWVLZXl3b3JkcyA9IG5ldyBTZXQoY3NzS2V5d29yZHMudmFsdWVzKVxuY29uc3QgZm9udFByb3BlcnRpZXMgPSBuZXcgU2V0KGNzc0tleXdvcmRzLmZvbnRzKVxuXG5mdW5jdGlvbiB0b2tlblJlZ2V4cCh3b3Jkcykge1xuICByZXR1cm4gbmV3IFJlZ0V4cChcIl5cIiArIHdvcmRzLmpvaW4oXCJ8XCIpKVxufVxuXG5sZXQga2V5d29yZHMgPSBbXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJudWxsXCIsIFwiYXV0b1wiXVxubGV0IGtleXdvcmRzUmVnZXhwID0gbmV3IFJlZ0V4cChcIl5cIiArIGtleXdvcmRzLmpvaW4oXCJ8XCIpKVxuXG5sZXQgb3BlcmF0b3JzID0gW1wiXFxcXChcIiwgXCJcXFxcKVwiLCBcIj1cIiwgXCI+XCIsIFwiPFwiLCBcIj09XCIsIFwiPj1cIiwgXCI8PVwiLCBcIlxcXFwrXCIsIFwiLVwiLFxuICAgICAgICAgICAgICAgICBcIlxcXFwhPVwiLCBcIi9cIiwgXCJcXFxcKlwiLCBcIiVcIiwgXCJhbmRcIiwgXCJvclwiLCBcIm5vdFwiLCBcIjtcIixcIlxcXFx7XCIsXCJcXFxcfVwiLFwiOlwiXVxubGV0IG9wUmVnZXhwID0gdG9rZW5SZWdleHAob3BlcmF0b3JzKVxuXG5sZXQgcHNldWRvRWxlbWVudHNSZWdleHAgPSAvXjo6P1thLXpBLVpfXVtcXHdcXC1dKi9cblxubGV0IHdvcmRcblxuZnVuY3Rpb24gaXNFbmRMaW5lKHN0cmVhbSkge1xuICByZXR1cm4gIXN0cmVhbS5wZWVrKCkgfHwgc3RyZWFtLm1hdGNoKC9cXHMrJC8sIGZhbHNlKVxufVxuXG5mdW5jdGlvbiB1cmxUb2tlbnMoc3RyZWFtLCBzdGF0ZSkge1xuICBsZXQgY2ggPSBzdHJlYW0ucGVlaygpXG5cbiAgaWYgKGNoID09PSBcIilcIikge1xuICAgIHN0cmVhbS5uZXh0KClcbiAgICBzdGF0ZS50b2tlbml6ZXIgPSB0b2tlbkJhc2VcbiAgICByZXR1cm4gXCJvcGVyYXRvclwiXG4gIH0gZWxzZSBpZiAoY2ggPT09IFwiKFwiKSB7XG4gICAgc3RyZWFtLm5leHQoKVxuICAgIHN0cmVhbS5lYXRTcGFjZSgpXG5cbiAgICByZXR1cm4gXCJvcGVyYXRvclwiXG4gIH0gZWxzZSBpZiAoY2ggPT09IFwiJ1wiIHx8IGNoID09PSAnXCInKSB7XG4gICAgc3RhdGUudG9rZW5pemVyID0gYnVpbGRTdHJpbmdUb2tlbml6ZXIoc3RyZWFtLm5leHQoKSlcbiAgICByZXR1cm4gXCJzdHJpbmdcIlxuICB9IGVsc2Uge1xuICAgIHN0YXRlLnRva2VuaXplciA9IGJ1aWxkU3RyaW5nVG9rZW5pemVyKFwiKVwiLCBmYWxzZSlcbiAgICByZXR1cm4gXCJzdHJpbmdcIlxuICB9XG59XG5mdW5jdGlvbiBjb21tZW50KGluZGVudGF0aW9uLCBtdWx0aUxpbmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLnNvbCgpICYmIHN0cmVhbS5pbmRlbnRhdGlvbigpIDw9IGluZGVudGF0aW9uKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZXIgPSB0b2tlbkJhc2VcbiAgICAgIHJldHVybiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSlcbiAgICB9XG5cbiAgICBpZiAobXVsdGlMaW5lICYmIHN0cmVhbS5za2lwVG8oXCIqL1wiKSkge1xuICAgICAgc3RyZWFtLm5leHQoKVxuICAgICAgc3RyZWFtLm5leHQoKVxuICAgICAgc3RhdGUudG9rZW5pemVyID0gdG9rZW5CYXNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKVxuICAgIH1cblxuICAgIHJldHVybiBcImNvbW1lbnRcIlxuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkU3RyaW5nVG9rZW5pemVyKHF1b3RlLCBncmVlZHkpIHtcbiAgaWYgKGdyZWVkeSA9PSBudWxsKSB7IGdyZWVkeSA9IHRydWUgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ1Rva2VuaXplcihzdHJlYW0sIHN0YXRlKSB7XG4gICAgbGV0IG5leHRDaGFyID0gc3RyZWFtLm5leHQoKVxuICAgIGxldCBwZWVrQ2hhciA9IHN0cmVhbS5wZWVrKClcbiAgICBsZXQgcHJldmlvdXNDaGFyID0gc3RyZWFtLnN0cmluZy5jaGFyQXQoc3RyZWFtLnBvcy0yKVxuXG4gICAgbGV0IGVuZGluZ1N0cmluZyA9ICgobmV4dENoYXIgIT09IFwiXFxcXFwiICYmIHBlZWtDaGFyID09PSBxdW90ZSkgfHwgKG5leHRDaGFyID09PSBxdW90ZSAmJiBwcmV2aW91c0NoYXIgIT09IFwiXFxcXFwiKSlcblxuICAgIGlmIChlbmRpbmdTdHJpbmcpIHtcbiAgICAgIGlmIChuZXh0Q2hhciAhPT0gcXVvdGUgJiYgZ3JlZWR5KSB7IHN0cmVhbS5uZXh0KCkgfVxuICAgICAgaWYgKGlzRW5kTGluZShzdHJlYW0pKSB7XG4gICAgICAgIHN0YXRlLmN1cnNvckhhbGYgPSAwXG4gICAgICB9XG4gICAgICBzdGF0ZS50b2tlbml6ZXIgPSB0b2tlbkJhc2VcbiAgICAgIHJldHVybiBcInN0cmluZ1wiXG4gICAgfSBlbHNlIGlmIChuZXh0Q2hhciA9PT0gXCIjXCIgJiYgcGVla0NoYXIgPT09IFwie1wiKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZXIgPSBidWlsZEludGVycG9sYXRpb25Ub2tlbml6ZXIoc3RyaW5nVG9rZW5pemVyKVxuICAgICAgc3RyZWFtLm5leHQoKVxuICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIlxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHJpbmdUb2tlbml6ZXJcbn1cblxuZnVuY3Rpb24gYnVpbGRJbnRlcnBvbGF0aW9uVG9rZW5pemVyKGN1cnJlbnRUb2tlbml6ZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PT0gXCJ9XCIpIHtcbiAgICAgIHN0cmVhbS5uZXh0KClcbiAgICAgIHN0YXRlLnRva2VuaXplciA9IGN1cnJlbnRUb2tlbml6ZXJcbiAgICAgIHJldHVybiBcIm9wZXJhdG9yXCJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRlbnQoc3RhdGUsIHN0cmVhbSkge1xuICBpZiAoc3RhdGUuaW5kZW50Q291bnQgPT0gMCkge1xuICAgIHN0YXRlLmluZGVudENvdW50KytcbiAgICBsZXQgbGFzdFNjb3BlT2Zmc2V0ID0gc3RhdGUuc2NvcGVzWzBdLm9mZnNldFxuICAgIGxldCBjdXJyZW50T2Zmc2V0ID0gbGFzdFNjb3BlT2Zmc2V0ICsgc3RyZWFtLmluZGVudFVuaXRcbiAgICBzdGF0ZS5zY29wZXMudW5zaGlmdCh7IG9mZnNldDpjdXJyZW50T2Zmc2V0IH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gZGVkZW50KHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5zY29wZXMubGVuZ3RoID09IDEpIHJldHVyblxuXG4gIHN0YXRlLnNjb3Blcy5zaGlmdCgpXG59XG5cbmZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gIGxldCBjaCA9IHN0cmVhbS5wZWVrKClcblxuICAvLyBDb21tZW50XG4gIGlmIChzdHJlYW0ubWF0Y2goXCIvKlwiKSkge1xuICAgIHN0YXRlLnRva2VuaXplciA9IGNvbW1lbnQoc3RyZWFtLmluZGVudGF0aW9uKCksIHRydWUpXG4gICAgcmV0dXJuIHN0YXRlLnRva2VuaXplcihzdHJlYW0sIHN0YXRlKVxuICB9XG4gIGlmIChzdHJlYW0ubWF0Y2goXCIvL1wiKSkge1xuICAgIHN0YXRlLnRva2VuaXplciA9IGNvbW1lbnQoc3RyZWFtLmluZGVudGF0aW9uKCksIGZhbHNlKVxuICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZXIoc3RyZWFtLCBzdGF0ZSlcbiAgfVxuXG4gIC8vIEludGVycG9sYXRpb25cbiAgaWYgKHN0cmVhbS5tYXRjaChcIiN7XCIpKSB7XG4gICAgc3RhdGUudG9rZW5pemVyID0gYnVpbGRJbnRlcnBvbGF0aW9uVG9rZW5pemVyKHRva2VuQmFzZSlcbiAgICByZXR1cm4gXCJvcGVyYXRvclwiXG4gIH1cblxuICAvLyBTdHJpbmdzXG4gIGlmIChjaCA9PT0gJ1wiJyB8fCBjaCA9PT0gXCInXCIpIHtcbiAgICBzdHJlYW0ubmV4dCgpXG4gICAgc3RhdGUudG9rZW5pemVyID0gYnVpbGRTdHJpbmdUb2tlbml6ZXIoY2gpXG4gICAgcmV0dXJuIFwic3RyaW5nXCJcbiAgfVxuXG4gIGlmICghc3RhdGUuY3Vyc29ySGFsZikge1xuICAgIC8vIGZpcnN0IGhhbGYgaS5lLiBiZWZvcmUgOiBmb3Iga2V5LXZhbHVlIHBhaXJzXG4gICAgLy8gaW5jbHVkaW5nIHNlbGVjdG9yc1xuICAgIGlmIChjaCA9PT0gXCItXCIpIHtcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL14tXFx3Ky0vKSkge1xuICAgICAgICByZXR1cm4gXCJtZXRhXCJcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2ggPT09IFwiLlwiKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eW1xcdy1dKy8pKSB7XG4gICAgICAgIGluZGVudChzdGF0ZSwgc3RyZWFtKVxuICAgICAgICByZXR1cm4gXCJxdWFsaWZpZXJcIlxuICAgICAgfSBlbHNlIGlmIChzdHJlYW0ucGVlaygpID09PSBcIiNcIikge1xuICAgICAgICBpbmRlbnQoc3RhdGUsIHN0cmVhbSlcbiAgICAgICAgcmV0dXJuIFwidGFnXCJcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2ggPT09IFwiI1wiKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpXG4gICAgICAvLyBJRCBzZWxlY3RvcnNcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15bXFx3LV0rLykpIHtcbiAgICAgICAgaW5kZW50KHN0YXRlLCBzdHJlYW0pXG4gICAgICAgIHJldHVybiBcImJ1aWx0aW5cIlxuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT09IFwiI1wiKSB7XG4gICAgICAgIGluZGVudChzdGF0ZSwgc3RyZWFtKVxuICAgICAgICByZXR1cm4gXCJ0YWdcIlxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZhcmlhYmxlc1xuICAgIGlmIChjaCA9PT0gXCIkXCIpIHtcbiAgICAgIHN0cmVhbS5uZXh0KClcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcdy1dLylcbiAgICAgIHJldHVybiBcInZhcmlhYmxlLTJcIlxuICAgIH1cblxuICAgIC8vIE51bWJlcnNcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eLT9bMC05XFwuXSsvKSlcbiAgICAgIHJldHVybiBcIm51bWJlclwiXG5cbiAgICAvLyBVbml0c1xuICAgIGlmIChzdHJlYW0ubWF0Y2goL14ocHh8ZW18aW4pXFxiLykpXG4gICAgICByZXR1cm4gXCJ1bml0XCJcblxuICAgIGlmIChzdHJlYW0ubWF0Y2goa2V5d29yZHNSZWdleHApKVxuICAgICAgcmV0dXJuIFwia2V5d29yZFwiXG5cbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9edXJsLykgJiYgc3RyZWFtLnBlZWsoKSA9PT0gXCIoXCIpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplciA9IHVybFRva2Vuc1xuICAgICAgcmV0dXJuIFwiYXRvbVwiXG4gICAgfVxuXG4gICAgaWYgKGNoID09PSBcIj1cIikge1xuICAgICAgLy8gTWF0Y2ggc2hvcnRjdXQgbWl4aW4gZGVmaW5pdGlvblxuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXj1bXFx3LV0rLykpIHtcbiAgICAgICAgaW5kZW50KHN0YXRlLCBzdHJlYW0pXG4gICAgICAgIHJldHVybiBcIm1ldGFcIlxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaCA9PT0gXCIrXCIpIHtcbiAgICAgIC8vIE1hdGNoIHNob3J0Y3V0IG1peGluIGRlZmluaXRpb25cbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15cXCtbXFx3LV0rLykpIHtcbiAgICAgICAgcmV0dXJuIFwibWV0YVwiXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSBcIkBcIikge1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgnQGV4dGVuZCcpKSB7XG4gICAgICAgIGlmICghc3RyZWFtLm1hdGNoKC9cXHMqW1xcd10vKSlcbiAgICAgICAgICBkZWRlbnQoc3RhdGUpXG4gICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBJbmRlbnQgRGlyZWN0aXZlc1xuICAgIGlmIChzdHJlYW0ubWF0Y2goL15AKGVsc2UgaWZ8aWZ8bWVkaWF8ZWxzZXxmb3J8ZWFjaHx3aGlsZXxtaXhpbnxmdW5jdGlvbikvKSkge1xuICAgICAgaW5kZW50KHN0YXRlLCBzdHJlYW0pXG4gICAgICByZXR1cm4gXCJkZWZcIlxuICAgIH1cblxuICAgIC8vIE90aGVyIERpcmVjdGl2ZXNcbiAgICBpZiAoY2ggPT09IFwiQFwiKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpXG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHctXS8pXG4gICAgICByZXR1cm4gXCJkZWZcIlxuICAgIH1cblxuICAgIGlmIChzdHJlYW0uZWF0V2hpbGUoL1tcXHctXS8pKSB7XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC8gKjogKltcXHctXFwrXFwkIyFcXChcIiddLyxmYWxzZSkpIHtcbiAgICAgICAgd29yZCA9IHN0cmVhbS5jdXJyZW50KCkudG9Mb3dlckNhc2UoKVxuICAgICAgICBsZXQgcHJvcCA9IHN0YXRlLnByZXZQcm9wICsgXCItXCIgKyB3b3JkXG4gICAgICAgIGlmIChwcm9wZXJ0eUtleXdvcmRzLmhhcyhwcm9wKSkge1xuICAgICAgICAgIHJldHVybiBcInByb3BlcnR5XCJcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUtleXdvcmRzLmhhcyh3b3JkKSkge1xuICAgICAgICAgIHN0YXRlLnByZXZQcm9wID0gd29yZFxuICAgICAgICAgIHJldHVybiBcInByb3BlcnR5XCJcbiAgICAgICAgfSBlbHNlIGlmIChmb250UHJvcGVydGllcy5oYXMod29yZCkpIHtcbiAgICAgICAgICByZXR1cm4gXCJwcm9wZXJ0eVwiXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwidGFnXCJcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC8gKjovLGZhbHNlKSkge1xuICAgICAgICBpbmRlbnQoc3RhdGUsIHN0cmVhbSlcbiAgICAgICAgc3RhdGUuY3Vyc29ySGFsZiA9IDFcbiAgICAgICAgc3RhdGUucHJldlByb3AgPSBzdHJlYW0uY3VycmVudCgpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgcmV0dXJuIFwicHJvcGVydHlcIlxuICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goLyAqLC8sZmFsc2UpKSB7XG4gICAgICAgIHJldHVybiBcInRhZ1wiXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRlbnQoc3RhdGUsIHN0cmVhbSlcbiAgICAgICAgcmV0dXJuIFwidGFnXCJcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2ggPT09IFwiOlwiKSB7XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKHBzZXVkb0VsZW1lbnRzUmVnZXhwKSkgeyAvLyBjb3VsZCBiZSBhIHBzZXVkby1lbGVtZW50XG4gICAgICAgIHJldHVybiBcInR5cGVcIlxuICAgICAgfVxuICAgICAgc3RyZWFtLm5leHQoKVxuICAgICAgc3RhdGUuY3Vyc29ySGFsZj0xXG4gICAgICByZXR1cm4gXCJvcGVyYXRvclwiXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChjaCA9PT0gXCIjXCIpIHtcbiAgICAgIHN0cmVhbS5uZXh0KClcbiAgICAgIC8vIEhleCBudW1iZXJzXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9bMC05YS1mQS1GXXs2fXxbMC05YS1mQS1GXXszfS8pKSB7XG4gICAgICAgIGlmIChpc0VuZExpbmUoc3RyZWFtKSkge1xuICAgICAgICAgIHN0YXRlLmN1cnNvckhhbGYgPSAwXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwibnVtYmVyXCJcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOdW1iZXJzXG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXi0/WzAtOVxcLl0rLykpIHtcbiAgICAgIGlmIChpc0VuZExpbmUoc3RyZWFtKSkge1xuICAgICAgICBzdGF0ZS5jdXJzb3JIYWxmID0gMFxuICAgICAgfVxuICAgICAgcmV0dXJuIFwibnVtYmVyXCJcbiAgICB9XG5cbiAgICAvLyBVbml0c1xuICAgIGlmIChzdHJlYW0ubWF0Y2goL14ocHh8ZW18aW4pXFxiLykpIHtcbiAgICAgIGlmIChpc0VuZExpbmUoc3RyZWFtKSkge1xuICAgICAgICBzdGF0ZS5jdXJzb3JIYWxmID0gMFxuICAgICAgfVxuICAgICAgcmV0dXJuIFwidW5pdFwiXG4gICAgfVxuXG4gICAgaWYgKHN0cmVhbS5tYXRjaChrZXl3b3Jkc1JlZ2V4cCkpIHtcbiAgICAgIGlmIChpc0VuZExpbmUoc3RyZWFtKSkge1xuICAgICAgICBzdGF0ZS5jdXJzb3JIYWxmID0gMFxuICAgICAgfVxuICAgICAgcmV0dXJuIFwia2V5d29yZFwiXG4gICAgfVxuXG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXnVybC8pICYmIHN0cmVhbS5wZWVrKCkgPT09IFwiKFwiKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZXIgPSB1cmxUb2tlbnNcbiAgICAgIGlmIChpc0VuZExpbmUoc3RyZWFtKSkge1xuICAgICAgICBzdGF0ZS5jdXJzb3JIYWxmID0gMFxuICAgICAgfVxuICAgICAgcmV0dXJuIFwiYXRvbVwiXG4gICAgfVxuXG4gICAgLy8gVmFyaWFibGVzXG4gICAgaWYgKGNoID09PSBcIiRcIikge1xuICAgICAgc3RyZWFtLm5leHQoKVxuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3LV0vKVxuICAgICAgaWYgKGlzRW5kTGluZShzdHJlYW0pKSB7XG4gICAgICAgIHN0YXRlLmN1cnNvckhhbGYgPSAwXG4gICAgICB9XG4gICAgICByZXR1cm4gXCJ2YXJpYWJsZS0yXCJcbiAgICB9XG5cbiAgICAvLyBiYW5nIGNoYXJhY3RlciBmb3IgIWltcG9ydGFudCwgIWRlZmF1bHQsIGV0Yy5cbiAgICBpZiAoY2ggPT09IFwiIVwiKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpXG4gICAgICBzdGF0ZS5jdXJzb3JIYWxmID0gMFxuICAgICAgcmV0dXJuIHN0cmVhbS5tYXRjaCgvXltcXHddKy8pID8gXCJrZXl3b3JkXCI6IFwib3BlcmF0b3JcIlxuICAgIH1cblxuICAgIGlmIChzdHJlYW0ubWF0Y2gob3BSZWdleHApKSB7XG4gICAgICBpZiAoaXNFbmRMaW5lKHN0cmVhbSkpIHtcbiAgICAgICAgc3RhdGUuY3Vyc29ySGFsZiA9IDBcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIm9wZXJhdG9yXCJcbiAgICB9XG5cbiAgICAvLyBhdHRyaWJ1dGVzXG4gICAgaWYgKHN0cmVhbS5lYXRXaGlsZSgvW1xcdy1dLykpIHtcbiAgICAgIGlmIChpc0VuZExpbmUoc3RyZWFtKSkge1xuICAgICAgICBzdGF0ZS5jdXJzb3JIYWxmID0gMFxuICAgICAgfVxuICAgICAgd29yZCA9IHN0cmVhbS5jdXJyZW50KCkudG9Mb3dlckNhc2UoKVxuICAgICAgaWYgKHZhbHVlS2V5d29yZHMuaGFzKHdvcmQpKSB7XG4gICAgICAgIHJldHVybiBcImF0b21cIlxuICAgICAgfSBlbHNlIGlmIChjb2xvcktleXdvcmRzLmhhcyh3b3JkKSkge1xuICAgICAgICByZXR1cm4gXCJrZXl3b3JkXCJcbiAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlLZXl3b3Jkcy5oYXMod29yZCkpIHtcbiAgICAgICAgc3RhdGUucHJldlByb3AgPSBzdHJlYW0uY3VycmVudCgpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgcmV0dXJuIFwicHJvcGVydHlcIlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwidGFnXCJcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNFbmRMaW5lKHN0cmVhbSkpIHtcbiAgICAgIHN0YXRlLmN1cnNvckhhbGYgPSAwXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGlmIChzdHJlYW0ubWF0Y2gob3BSZWdleHApKVxuICAgIHJldHVybiBcIm9wZXJhdG9yXCJcblxuICBzdHJlYW0ubmV4dCgpXG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIHRva2VuTGV4ZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RyZWFtLnNvbCgpKSBzdGF0ZS5pbmRlbnRDb3VudCA9IDBcbiAgbGV0IHN0eWxlID0gc3RhdGUudG9rZW5pemVyKHN0cmVhbSwgc3RhdGUpXG4gIGxldCBjdXJyZW50ID0gc3RyZWFtLmN1cnJlbnQoKVxuXG4gIGlmIChjdXJyZW50ID09PSBcIkByZXR1cm5cIiB8fCBjdXJyZW50ID09PSBcIn1cIikge1xuICAgIGRlZGVudChzdGF0ZSlcbiAgfVxuXG4gIGlmIChzdHlsZSAhPT0gbnVsbCkge1xuICAgIGxldCBzdGFydE9mVG9rZW4gPSBzdHJlYW0ucG9zIC0gY3VycmVudC5sZW5ndGhcblxuICAgIGxldCB3aXRoQ3VycmVudEluZGVudCA9IHN0YXJ0T2ZUb2tlbiArIChzdHJlYW0uaW5kZW50VW5pdCAqIHN0YXRlLmluZGVudENvdW50KVxuXG4gICAgbGV0IG5ld1Njb3BlcyA9IFtdXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLnNjb3Blcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHNjb3BlID0gc3RhdGUuc2NvcGVzW2ldXG5cbiAgICAgIGlmIChzY29wZS5vZmZzZXQgPD0gd2l0aEN1cnJlbnRJbmRlbnQpXG4gICAgICAgIG5ld1Njb3Blcy5wdXNoKHNjb3BlKVxuICAgIH1cblxuICAgIHN0YXRlLnNjb3BlcyA9IG5ld1Njb3Blc1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlXG59XG5cbmV4cG9ydCBjb25zdCBzYXNzID0ge1xuICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5pemVyOiB0b2tlbkJhc2UsXG4gICAgICBzY29wZXM6IFt7b2Zmc2V0OiAwLCB0eXBlOiBcInNhc3NcIn1dLFxuICAgICAgaW5kZW50Q291bnQ6IDAsXG4gICAgICBjdXJzb3JIYWxmOiAwLCAgLy8gY3Vyc29yIGhhbGYgdGVsbHMgdXMgaWYgY3Vyc29yIGxpZXMgYWZ0ZXIgKDEpXG4gICAgICAvLyBvciBiZWZvcmUgKDApIGNvbG9uICh3ZWxsLi4uIG1vcmUgb3IgbGVzcylcbiAgICAgIGRlZmluZWRWYXJzOiBbXSxcbiAgICAgIGRlZmluZWRNaXhpbnM6IFtdXG4gICAgfVxuICB9LFxuICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIGxldCBzdHlsZSA9IHRva2VuTGV4ZXIoc3RyZWFtLCBzdGF0ZSlcbiAgICBzdGF0ZS5sYXN0VG9rZW4gPSB7IHN0eWxlOiBzdHlsZSwgY29udGVudDogc3RyZWFtLmN1cnJlbnQoKSB9XG4gICAgcmV0dXJuIHN0eWxlXG4gIH0sXG5cbiAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5zY29wZXNbMF0ub2Zmc2V0XG4gIH0sXG5cbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgY29tbWVudFRva2Vuczoge2xpbmU6IFwiLy9cIiwgYmxvY2s6IHtvcGVuOiBcIi8qXCIsIGNsb3NlOiBcIiovXCJ9fSxcbiAgICBhdXRvY29tcGxldGU6IGNzc0tleXdvcmRzLmFsbFxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///417\n')}}]);