(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[48],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/haskell.js":
/*!***************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/haskell.js ***!
  \***************************************************************/
/*! exports provided: haskell */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"haskell\", function() { return haskell; });\nfunction switchState(source, setState, f) {\n  setState(f);\n  return f(source, setState);\n}\n\n// These should all be Unicode extended, as per the Haskell 2010 report\nvar smallRE = /[a-z_]/;\nvar largeRE = /[A-Z]/;\nvar digitRE = /\\d/;\nvar hexitRE = /[0-9A-Fa-f]/;\nvar octitRE = /[0-7]/;\nvar idRE = /[a-z_A-Z0-9'\\xa1-\\uffff]/;\nvar symbolRE = /[-!#$%&*+.\\/<=>?@\\\\^|~:]/;\nvar specialRE = /[(),;[\\]`{}]/;\nvar whiteCharRE = /[ \\t\\v\\f]/; // newlines are handled in tokenizer\n\nfunction normal(source, setState) {\n  if (source.eatWhile(whiteCharRE)) {\n    return null;\n  }\n\n  var ch = source.next();\n  if (specialRE.test(ch)) {\n    if (ch == '{' && source.eat('-')) {\n      var t = \"comment\";\n      if (source.eat('#')) {\n        t = \"meta\";\n      }\n      return switchState(source, setState, ncomment(t, 1));\n    }\n    return null;\n  }\n\n  if (ch == '\\'') {\n    if (source.eat('\\\\')) {\n      source.next();  // should handle other escapes here\n    }\n    else {\n      source.next();\n    }\n    if (source.eat('\\'')) {\n      return \"string\";\n    }\n    return \"error\";\n  }\n\n  if (ch == '\"') {\n    return switchState(source, setState, stringLiteral);\n  }\n\n  if (largeRE.test(ch)) {\n    source.eatWhile(idRE);\n    if (source.eat('.')) {\n      return \"qualifier\";\n    }\n    return \"type\";\n  }\n\n  if (smallRE.test(ch)) {\n    source.eatWhile(idRE);\n    return \"variable\";\n  }\n\n  if (digitRE.test(ch)) {\n    if (ch == '0') {\n      if (source.eat(/[xX]/)) {\n        source.eatWhile(hexitRE); // should require at least 1\n        return \"integer\";\n      }\n      if (source.eat(/[oO]/)) {\n        source.eatWhile(octitRE); // should require at least 1\n        return \"number\";\n      }\n    }\n    source.eatWhile(digitRE);\n    var t = \"number\";\n    if (source.match(/^\\.\\d+/)) {\n      t = \"number\";\n    }\n    if (source.eat(/[eE]/)) {\n      t = \"number\";\n      source.eat(/[-+]/);\n      source.eatWhile(digitRE); // should require at least 1\n    }\n    return t;\n  }\n\n  if (ch == \".\" && source.eat(\".\"))\n    return \"keyword\";\n\n  if (symbolRE.test(ch)) {\n    if (ch == '-' && source.eat(/-/)) {\n      source.eatWhile(/-/);\n      if (!source.eat(symbolRE)) {\n        source.skipToEnd();\n        return \"comment\";\n      }\n    }\n    source.eatWhile(symbolRE);\n    return \"variable\"\n  }\n\n  return \"error\";\n}\n\nfunction ncomment(type, nest) {\n  if (nest == 0) {\n    return normal;\n  }\n  return function(source, setState) {\n    var currNest = nest;\n    while (!source.eol()) {\n      var ch = source.next();\n      if (ch == '{' && source.eat('-')) {\n        ++currNest;\n      }\n      else if (ch == '-' && source.eat('}')) {\n        --currNest;\n        if (currNest == 0) {\n          setState(normal);\n          return type;\n        }\n      }\n    }\n    setState(ncomment(type, currNest));\n    return type;\n  };\n}\n\nfunction stringLiteral(source, setState) {\n  while (!source.eol()) {\n    var ch = source.next();\n    if (ch == '\"') {\n      setState(normal);\n      return \"string\";\n    }\n    if (ch == '\\\\') {\n      if (source.eol() || source.eat(whiteCharRE)) {\n        setState(stringGap);\n        return \"string\";\n      }\n      if (source.eat('&')) {\n      }\n      else {\n        source.next(); // should handle other escapes here\n      }\n    }\n  }\n  setState(normal);\n  return \"error\";\n}\n\nfunction stringGap(source, setState) {\n  if (source.eat('\\\\')) {\n    return switchState(source, setState, stringLiteral);\n  }\n  source.next();\n  setState(normal);\n  return \"error\";\n}\n\n\nvar wellKnownWords = (function() {\n  var wkw = {};\n  function setType(t) {\n    return function () {\n      for (var i = 0; i < arguments.length; i++)\n        wkw[arguments[i]] = t;\n    };\n  }\n\n  setType(\"keyword\")(\n    \"case\", \"class\", \"data\", \"default\", \"deriving\", \"do\", \"else\", \"foreign\",\n    \"if\", \"import\", \"in\", \"infix\", \"infixl\", \"infixr\", \"instance\", \"let\",\n    \"module\", \"newtype\", \"of\", \"then\", \"type\", \"where\", \"_\");\n\n  setType(\"keyword\")(\n    \"\\.\\.\", \":\", \"::\", \"=\", \"\\\\\", \"<-\", \"->\", \"@\", \"~\", \"=>\");\n\n  setType(\"builtin\")(\n    \"!!\", \"$!\", \"$\", \"&&\", \"+\", \"++\", \"-\", \".\", \"/\", \"/=\", \"<\", \"<*\", \"<=\",\n    \"<$>\", \"<*>\", \"=<<\", \"==\", \">\", \">=\", \">>\", \">>=\", \"^\", \"^^\", \"||\", \"*\",\n    \"*>\", \"**\");\n\n  setType(\"builtin\")(\n    \"Applicative\", \"Bool\", \"Bounded\", \"Char\", \"Double\", \"EQ\", \"Either\", \"Enum\",\n    \"Eq\", \"False\", \"FilePath\", \"Float\", \"Floating\", \"Fractional\", \"Functor\",\n    \"GT\", \"IO\", \"IOError\", \"Int\", \"Integer\", \"Integral\", \"Just\", \"LT\", \"Left\",\n    \"Maybe\", \"Monad\", \"Nothing\", \"Num\", \"Ord\", \"Ordering\", \"Rational\", \"Read\",\n    \"ReadS\", \"Real\", \"RealFloat\", \"RealFrac\", \"Right\", \"Show\", \"ShowS\",\n    \"String\", \"True\");\n\n  setType(\"builtin\")(\n    \"abs\", \"acos\", \"acosh\", \"all\", \"and\", \"any\", \"appendFile\", \"asTypeOf\",\n    \"asin\", \"asinh\", \"atan\", \"atan2\", \"atanh\", \"break\", \"catch\", \"ceiling\",\n    \"compare\", \"concat\", \"concatMap\", \"const\", \"cos\", \"cosh\", \"curry\",\n    \"cycle\", \"decodeFloat\", \"div\", \"divMod\", \"drop\", \"dropWhile\", \"either\",\n    \"elem\", \"encodeFloat\", \"enumFrom\", \"enumFromThen\", \"enumFromThenTo\",\n    \"enumFromTo\", \"error\", \"even\", \"exp\", \"exponent\", \"fail\", \"filter\",\n    \"flip\", \"floatDigits\", \"floatRadix\", \"floatRange\", \"floor\", \"fmap\",\n    \"foldl\", \"foldl1\", \"foldr\", \"foldr1\", \"fromEnum\", \"fromInteger\",\n    \"fromIntegral\", \"fromRational\", \"fst\", \"gcd\", \"getChar\", \"getContents\",\n    \"getLine\", \"head\", \"id\", \"init\", \"interact\", \"ioError\", \"isDenormalized\",\n    \"isIEEE\", \"isInfinite\", \"isNaN\", \"isNegativeZero\", \"iterate\", \"last\",\n    \"lcm\", \"length\", \"lex\", \"lines\", \"log\", \"logBase\", \"lookup\", \"map\",\n    \"mapM\", \"mapM_\", \"max\", \"maxBound\", \"maximum\", \"maybe\", \"min\", \"minBound\",\n    \"minimum\", \"mod\", \"negate\", \"not\", \"notElem\", \"null\", \"odd\", \"or\",\n    \"otherwise\", \"pi\", \"pred\", \"print\", \"product\", \"properFraction\", \"pure\",\n    \"putChar\", \"putStr\", \"putStrLn\", \"quot\", \"quotRem\", \"read\", \"readFile\",\n    \"readIO\", \"readList\", \"readLn\", \"readParen\", \"reads\", \"readsPrec\",\n    \"realToFrac\", \"recip\", \"rem\", \"repeat\", \"replicate\", \"return\", \"reverse\",\n    \"round\", \"scaleFloat\", \"scanl\", \"scanl1\", \"scanr\", \"scanr1\", \"seq\",\n    \"sequence\", \"sequence_\", \"show\", \"showChar\", \"showList\", \"showParen\",\n    \"showString\", \"shows\", \"showsPrec\", \"significand\", \"signum\", \"sin\",\n    \"sinh\", \"snd\", \"span\", \"splitAt\", \"sqrt\", \"subtract\", \"succ\", \"sum\",\n    \"tail\", \"take\", \"takeWhile\", \"tan\", \"tanh\", \"toEnum\", \"toInteger\",\n    \"toRational\", \"truncate\", \"uncurry\", \"undefined\", \"unlines\", \"until\",\n    \"unwords\", \"unzip\", \"unzip3\", \"userError\", \"words\", \"writeFile\", \"zip\",\n    \"zip3\", \"zipWith\", \"zipWith3\");\n\n  return wkw;\n})();\n\nconst haskell = {\n  startState: function ()  { return { f: normal }; },\n  copyState:  function (s) { return { f: s.f }; },\n\n  token: function(stream, state) {\n    var t = state.f(stream, function(s) { state.f = s; });\n    var w = stream.current();\n    return wellKnownWords.hasOwnProperty(w) ? wellKnownWords[w] : t;\n  },\n\n  languageData: {\n    commentTokens: {line: \"--\", block: {open: \"{-\", close: \"-}\"}}\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvaGFza2VsbC5qcz85ZjE1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU07QUFDNUIsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFTTtBQUNQLDRCQUE0QixTQUFTLGFBQWEsRUFBRTtBQUNwRCw0QkFBNEIsU0FBUyxVQUFVLEVBQUU7O0FBRWpEO0FBQ0EseUNBQXlDLGFBQWEsRUFBRTtBQUN4RDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLG9CQUFvQixvQkFBb0IsUUFBUSxjQUFjO0FBQzlEO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvaGFza2VsbC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHN3aXRjaFN0YXRlKHNvdXJjZSwgc2V0U3RhdGUsIGYpIHtcbiAgc2V0U3RhdGUoZik7XG4gIHJldHVybiBmKHNvdXJjZSwgc2V0U3RhdGUpO1xufVxuXG4vLyBUaGVzZSBzaG91bGQgYWxsIGJlIFVuaWNvZGUgZXh0ZW5kZWQsIGFzIHBlciB0aGUgSGFza2VsbCAyMDEwIHJlcG9ydFxudmFyIHNtYWxsUkUgPSAvW2Etel9dLztcbnZhciBsYXJnZVJFID0gL1tBLVpdLztcbnZhciBkaWdpdFJFID0gL1xcZC87XG52YXIgaGV4aXRSRSA9IC9bMC05QS1GYS1mXS87XG52YXIgb2N0aXRSRSA9IC9bMC03XS87XG52YXIgaWRSRSA9IC9bYS16X0EtWjAtOSdcXHhhMS1cXHVmZmZmXS87XG52YXIgc3ltYm9sUkUgPSAvWy0hIyQlJiorLlxcLzw9Pj9AXFxcXF58fjpdLztcbnZhciBzcGVjaWFsUkUgPSAvWygpLDtbXFxdYHt9XS87XG52YXIgd2hpdGVDaGFyUkUgPSAvWyBcXHRcXHZcXGZdLzsgLy8gbmV3bGluZXMgYXJlIGhhbmRsZWQgaW4gdG9rZW5pemVyXG5cbmZ1bmN0aW9uIG5vcm1hbChzb3VyY2UsIHNldFN0YXRlKSB7XG4gIGlmIChzb3VyY2UuZWF0V2hpbGUod2hpdGVDaGFyUkUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgY2ggPSBzb3VyY2UubmV4dCgpO1xuICBpZiAoc3BlY2lhbFJFLnRlc3QoY2gpKSB7XG4gICAgaWYgKGNoID09ICd7JyAmJiBzb3VyY2UuZWF0KCctJykpIHtcbiAgICAgIHZhciB0ID0gXCJjb21tZW50XCI7XG4gICAgICBpZiAoc291cmNlLmVhdCgnIycpKSB7XG4gICAgICAgIHQgPSBcIm1ldGFcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzd2l0Y2hTdGF0ZShzb3VyY2UsIHNldFN0YXRlLCBuY29tbWVudCh0LCAxKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNoID09ICdcXCcnKSB7XG4gICAgaWYgKHNvdXJjZS5lYXQoJ1xcXFwnKSkge1xuICAgICAgc291cmNlLm5leHQoKTsgIC8vIHNob3VsZCBoYW5kbGUgb3RoZXIgZXNjYXBlcyBoZXJlXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc291cmNlLm5leHQoKTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZS5lYXQoJ1xcJycpKSB7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiZXJyb3JcIjtcbiAgfVxuXG4gIGlmIChjaCA9PSAnXCInKSB7XG4gICAgcmV0dXJuIHN3aXRjaFN0YXRlKHNvdXJjZSwgc2V0U3RhdGUsIHN0cmluZ0xpdGVyYWwpO1xuICB9XG5cbiAgaWYgKGxhcmdlUkUudGVzdChjaCkpIHtcbiAgICBzb3VyY2UuZWF0V2hpbGUoaWRSRSk7XG4gICAgaWYgKHNvdXJjZS5lYXQoJy4nKSkge1xuICAgICAgcmV0dXJuIFwicXVhbGlmaWVyXCI7XG4gICAgfVxuICAgIHJldHVybiBcInR5cGVcIjtcbiAgfVxuXG4gIGlmIChzbWFsbFJFLnRlc3QoY2gpKSB7XG4gICAgc291cmNlLmVhdFdoaWxlKGlkUkUpO1xuICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gIH1cblxuICBpZiAoZGlnaXRSRS50ZXN0KGNoKSkge1xuICAgIGlmIChjaCA9PSAnMCcpIHtcbiAgICAgIGlmIChzb3VyY2UuZWF0KC9beFhdLykpIHtcbiAgICAgICAgc291cmNlLmVhdFdoaWxlKGhleGl0UkUpOyAvLyBzaG91bGQgcmVxdWlyZSBhdCBsZWFzdCAxXG4gICAgICAgIHJldHVybiBcImludGVnZXJcIjtcbiAgICAgIH1cbiAgICAgIGlmIChzb3VyY2UuZWF0KC9bb09dLykpIHtcbiAgICAgICAgc291cmNlLmVhdFdoaWxlKG9jdGl0UkUpOyAvLyBzaG91bGQgcmVxdWlyZSBhdCBsZWFzdCAxXG4gICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3VyY2UuZWF0V2hpbGUoZGlnaXRSRSk7XG4gICAgdmFyIHQgPSBcIm51bWJlclwiO1xuICAgIGlmIChzb3VyY2UubWF0Y2goL15cXC5cXGQrLykpIHtcbiAgICAgIHQgPSBcIm51bWJlclwiO1xuICAgIH1cbiAgICBpZiAoc291cmNlLmVhdCgvW2VFXS8pKSB7XG4gICAgICB0ID0gXCJudW1iZXJcIjtcbiAgICAgIHNvdXJjZS5lYXQoL1stK10vKTtcbiAgICAgIHNvdXJjZS5lYXRXaGlsZShkaWdpdFJFKTsgLy8gc2hvdWxkIHJlcXVpcmUgYXQgbGVhc3QgMVxuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfVxuXG4gIGlmIChjaCA9PSBcIi5cIiAmJiBzb3VyY2UuZWF0KFwiLlwiKSlcbiAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG5cbiAgaWYgKHN5bWJvbFJFLnRlc3QoY2gpKSB7XG4gICAgaWYgKGNoID09ICctJyAmJiBzb3VyY2UuZWF0KC8tLykpIHtcbiAgICAgIHNvdXJjZS5lYXRXaGlsZSgvLS8pO1xuICAgICAgaWYgKCFzb3VyY2UuZWF0KHN5bWJvbFJFKSkge1xuICAgICAgICBzb3VyY2Uuc2tpcFRvRW5kKCk7XG4gICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgc291cmNlLmVhdFdoaWxlKHN5bWJvbFJFKTtcbiAgICByZXR1cm4gXCJ2YXJpYWJsZVwiXG4gIH1cblxuICByZXR1cm4gXCJlcnJvclwiO1xufVxuXG5mdW5jdGlvbiBuY29tbWVudCh0eXBlLCBuZXN0KSB7XG4gIGlmIChuZXN0ID09IDApIHtcbiAgICByZXR1cm4gbm9ybWFsO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihzb3VyY2UsIHNldFN0YXRlKSB7XG4gICAgdmFyIGN1cnJOZXN0ID0gbmVzdDtcbiAgICB3aGlsZSAoIXNvdXJjZS5lb2woKSkge1xuICAgICAgdmFyIGNoID0gc291cmNlLm5leHQoKTtcbiAgICAgIGlmIChjaCA9PSAneycgJiYgc291cmNlLmVhdCgnLScpKSB7XG4gICAgICAgICsrY3Vyck5lc3Q7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjaCA9PSAnLScgJiYgc291cmNlLmVhdCgnfScpKSB7XG4gICAgICAgIC0tY3Vyck5lc3Q7XG4gICAgICAgIGlmIChjdXJyTmVzdCA9PSAwKSB7XG4gICAgICAgICAgc2V0U3RhdGUobm9ybWFsKTtcbiAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzZXRTdGF0ZShuY29tbWVudCh0eXBlLCBjdXJyTmVzdCkpO1xuICAgIHJldHVybiB0eXBlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHJpbmdMaXRlcmFsKHNvdXJjZSwgc2V0U3RhdGUpIHtcbiAgd2hpbGUgKCFzb3VyY2UuZW9sKCkpIHtcbiAgICB2YXIgY2ggPSBzb3VyY2UubmV4dCgpO1xuICAgIGlmIChjaCA9PSAnXCInKSB7XG4gICAgICBzZXRTdGF0ZShub3JtYWwpO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfVxuICAgIGlmIChjaCA9PSAnXFxcXCcpIHtcbiAgICAgIGlmIChzb3VyY2UuZW9sKCkgfHwgc291cmNlLmVhdCh3aGl0ZUNoYXJSRSkpIHtcbiAgICAgICAgc2V0U3RhdGUoc3RyaW5nR2FwKTtcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICB9XG4gICAgICBpZiAoc291cmNlLmVhdCgnJicpKSB7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc291cmNlLm5leHQoKTsgLy8gc2hvdWxkIGhhbmRsZSBvdGhlciBlc2NhcGVzIGhlcmVcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2V0U3RhdGUobm9ybWFsKTtcbiAgcmV0dXJuIFwiZXJyb3JcIjtcbn1cblxuZnVuY3Rpb24gc3RyaW5nR2FwKHNvdXJjZSwgc2V0U3RhdGUpIHtcbiAgaWYgKHNvdXJjZS5lYXQoJ1xcXFwnKSkge1xuICAgIHJldHVybiBzd2l0Y2hTdGF0ZShzb3VyY2UsIHNldFN0YXRlLCBzdHJpbmdMaXRlcmFsKTtcbiAgfVxuICBzb3VyY2UubmV4dCgpO1xuICBzZXRTdGF0ZShub3JtYWwpO1xuICByZXR1cm4gXCJlcnJvclwiO1xufVxuXG5cbnZhciB3ZWxsS25vd25Xb3JkcyA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHdrdyA9IHt9O1xuICBmdW5jdGlvbiBzZXRUeXBlKHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICAgIHdrd1thcmd1bWVudHNbaV1dID0gdDtcbiAgICB9O1xuICB9XG5cbiAgc2V0VHlwZShcImtleXdvcmRcIikoXG4gICAgXCJjYXNlXCIsIFwiY2xhc3NcIiwgXCJkYXRhXCIsIFwiZGVmYXVsdFwiLCBcImRlcml2aW5nXCIsIFwiZG9cIiwgXCJlbHNlXCIsIFwiZm9yZWlnblwiLFxuICAgIFwiaWZcIiwgXCJpbXBvcnRcIiwgXCJpblwiLCBcImluZml4XCIsIFwiaW5maXhsXCIsIFwiaW5maXhyXCIsIFwiaW5zdGFuY2VcIiwgXCJsZXRcIixcbiAgICBcIm1vZHVsZVwiLCBcIm5ld3R5cGVcIiwgXCJvZlwiLCBcInRoZW5cIiwgXCJ0eXBlXCIsIFwid2hlcmVcIiwgXCJfXCIpO1xuXG4gIHNldFR5cGUoXCJrZXl3b3JkXCIpKFxuICAgIFwiXFwuXFwuXCIsIFwiOlwiLCBcIjo6XCIsIFwiPVwiLCBcIlxcXFxcIiwgXCI8LVwiLCBcIi0+XCIsIFwiQFwiLCBcIn5cIiwgXCI9PlwiKTtcblxuICBzZXRUeXBlKFwiYnVpbHRpblwiKShcbiAgICBcIiEhXCIsIFwiJCFcIiwgXCIkXCIsIFwiJiZcIiwgXCIrXCIsIFwiKytcIiwgXCItXCIsIFwiLlwiLCBcIi9cIiwgXCIvPVwiLCBcIjxcIiwgXCI8KlwiLCBcIjw9XCIsXG4gICAgXCI8JD5cIiwgXCI8Kj5cIiwgXCI9PDxcIiwgXCI9PVwiLCBcIj5cIiwgXCI+PVwiLCBcIj4+XCIsIFwiPj49XCIsIFwiXlwiLCBcIl5eXCIsIFwifHxcIiwgXCIqXCIsXG4gICAgXCIqPlwiLCBcIioqXCIpO1xuXG4gIHNldFR5cGUoXCJidWlsdGluXCIpKFxuICAgIFwiQXBwbGljYXRpdmVcIiwgXCJCb29sXCIsIFwiQm91bmRlZFwiLCBcIkNoYXJcIiwgXCJEb3VibGVcIiwgXCJFUVwiLCBcIkVpdGhlclwiLCBcIkVudW1cIixcbiAgICBcIkVxXCIsIFwiRmFsc2VcIiwgXCJGaWxlUGF0aFwiLCBcIkZsb2F0XCIsIFwiRmxvYXRpbmdcIiwgXCJGcmFjdGlvbmFsXCIsIFwiRnVuY3RvclwiLFxuICAgIFwiR1RcIiwgXCJJT1wiLCBcIklPRXJyb3JcIiwgXCJJbnRcIiwgXCJJbnRlZ2VyXCIsIFwiSW50ZWdyYWxcIiwgXCJKdXN0XCIsIFwiTFRcIiwgXCJMZWZ0XCIsXG4gICAgXCJNYXliZVwiLCBcIk1vbmFkXCIsIFwiTm90aGluZ1wiLCBcIk51bVwiLCBcIk9yZFwiLCBcIk9yZGVyaW5nXCIsIFwiUmF0aW9uYWxcIiwgXCJSZWFkXCIsXG4gICAgXCJSZWFkU1wiLCBcIlJlYWxcIiwgXCJSZWFsRmxvYXRcIiwgXCJSZWFsRnJhY1wiLCBcIlJpZ2h0XCIsIFwiU2hvd1wiLCBcIlNob3dTXCIsXG4gICAgXCJTdHJpbmdcIiwgXCJUcnVlXCIpO1xuXG4gIHNldFR5cGUoXCJidWlsdGluXCIpKFxuICAgIFwiYWJzXCIsIFwiYWNvc1wiLCBcImFjb3NoXCIsIFwiYWxsXCIsIFwiYW5kXCIsIFwiYW55XCIsIFwiYXBwZW5kRmlsZVwiLCBcImFzVHlwZU9mXCIsXG4gICAgXCJhc2luXCIsIFwiYXNpbmhcIiwgXCJhdGFuXCIsIFwiYXRhbjJcIiwgXCJhdGFuaFwiLCBcImJyZWFrXCIsIFwiY2F0Y2hcIiwgXCJjZWlsaW5nXCIsXG4gICAgXCJjb21wYXJlXCIsIFwiY29uY2F0XCIsIFwiY29uY2F0TWFwXCIsIFwiY29uc3RcIiwgXCJjb3NcIiwgXCJjb3NoXCIsIFwiY3VycnlcIixcbiAgICBcImN5Y2xlXCIsIFwiZGVjb2RlRmxvYXRcIiwgXCJkaXZcIiwgXCJkaXZNb2RcIiwgXCJkcm9wXCIsIFwiZHJvcFdoaWxlXCIsIFwiZWl0aGVyXCIsXG4gICAgXCJlbGVtXCIsIFwiZW5jb2RlRmxvYXRcIiwgXCJlbnVtRnJvbVwiLCBcImVudW1Gcm9tVGhlblwiLCBcImVudW1Gcm9tVGhlblRvXCIsXG4gICAgXCJlbnVtRnJvbVRvXCIsIFwiZXJyb3JcIiwgXCJldmVuXCIsIFwiZXhwXCIsIFwiZXhwb25lbnRcIiwgXCJmYWlsXCIsIFwiZmlsdGVyXCIsXG4gICAgXCJmbGlwXCIsIFwiZmxvYXREaWdpdHNcIiwgXCJmbG9hdFJhZGl4XCIsIFwiZmxvYXRSYW5nZVwiLCBcImZsb29yXCIsIFwiZm1hcFwiLFxuICAgIFwiZm9sZGxcIiwgXCJmb2xkbDFcIiwgXCJmb2xkclwiLCBcImZvbGRyMVwiLCBcImZyb21FbnVtXCIsIFwiZnJvbUludGVnZXJcIixcbiAgICBcImZyb21JbnRlZ3JhbFwiLCBcImZyb21SYXRpb25hbFwiLCBcImZzdFwiLCBcImdjZFwiLCBcImdldENoYXJcIiwgXCJnZXRDb250ZW50c1wiLFxuICAgIFwiZ2V0TGluZVwiLCBcImhlYWRcIiwgXCJpZFwiLCBcImluaXRcIiwgXCJpbnRlcmFjdFwiLCBcImlvRXJyb3JcIiwgXCJpc0Rlbm9ybWFsaXplZFwiLFxuICAgIFwiaXNJRUVFXCIsIFwiaXNJbmZpbml0ZVwiLCBcImlzTmFOXCIsIFwiaXNOZWdhdGl2ZVplcm9cIiwgXCJpdGVyYXRlXCIsIFwibGFzdFwiLFxuICAgIFwibGNtXCIsIFwibGVuZ3RoXCIsIFwibGV4XCIsIFwibGluZXNcIiwgXCJsb2dcIiwgXCJsb2dCYXNlXCIsIFwibG9va3VwXCIsIFwibWFwXCIsXG4gICAgXCJtYXBNXCIsIFwibWFwTV9cIiwgXCJtYXhcIiwgXCJtYXhCb3VuZFwiLCBcIm1heGltdW1cIiwgXCJtYXliZVwiLCBcIm1pblwiLCBcIm1pbkJvdW5kXCIsXG4gICAgXCJtaW5pbXVtXCIsIFwibW9kXCIsIFwibmVnYXRlXCIsIFwibm90XCIsIFwibm90RWxlbVwiLCBcIm51bGxcIiwgXCJvZGRcIiwgXCJvclwiLFxuICAgIFwib3RoZXJ3aXNlXCIsIFwicGlcIiwgXCJwcmVkXCIsIFwicHJpbnRcIiwgXCJwcm9kdWN0XCIsIFwicHJvcGVyRnJhY3Rpb25cIiwgXCJwdXJlXCIsXG4gICAgXCJwdXRDaGFyXCIsIFwicHV0U3RyXCIsIFwicHV0U3RyTG5cIiwgXCJxdW90XCIsIFwicXVvdFJlbVwiLCBcInJlYWRcIiwgXCJyZWFkRmlsZVwiLFxuICAgIFwicmVhZElPXCIsIFwicmVhZExpc3RcIiwgXCJyZWFkTG5cIiwgXCJyZWFkUGFyZW5cIiwgXCJyZWFkc1wiLCBcInJlYWRzUHJlY1wiLFxuICAgIFwicmVhbFRvRnJhY1wiLCBcInJlY2lwXCIsIFwicmVtXCIsIFwicmVwZWF0XCIsIFwicmVwbGljYXRlXCIsIFwicmV0dXJuXCIsIFwicmV2ZXJzZVwiLFxuICAgIFwicm91bmRcIiwgXCJzY2FsZUZsb2F0XCIsIFwic2NhbmxcIiwgXCJzY2FubDFcIiwgXCJzY2FuclwiLCBcInNjYW5yMVwiLCBcInNlcVwiLFxuICAgIFwic2VxdWVuY2VcIiwgXCJzZXF1ZW5jZV9cIiwgXCJzaG93XCIsIFwic2hvd0NoYXJcIiwgXCJzaG93TGlzdFwiLCBcInNob3dQYXJlblwiLFxuICAgIFwic2hvd1N0cmluZ1wiLCBcInNob3dzXCIsIFwic2hvd3NQcmVjXCIsIFwic2lnbmlmaWNhbmRcIiwgXCJzaWdudW1cIiwgXCJzaW5cIixcbiAgICBcInNpbmhcIiwgXCJzbmRcIiwgXCJzcGFuXCIsIFwic3BsaXRBdFwiLCBcInNxcnRcIiwgXCJzdWJ0cmFjdFwiLCBcInN1Y2NcIiwgXCJzdW1cIixcbiAgICBcInRhaWxcIiwgXCJ0YWtlXCIsIFwidGFrZVdoaWxlXCIsIFwidGFuXCIsIFwidGFuaFwiLCBcInRvRW51bVwiLCBcInRvSW50ZWdlclwiLFxuICAgIFwidG9SYXRpb25hbFwiLCBcInRydW5jYXRlXCIsIFwidW5jdXJyeVwiLCBcInVuZGVmaW5lZFwiLCBcInVubGluZXNcIiwgXCJ1bnRpbFwiLFxuICAgIFwidW53b3Jkc1wiLCBcInVuemlwXCIsIFwidW56aXAzXCIsIFwidXNlckVycm9yXCIsIFwid29yZHNcIiwgXCJ3cml0ZUZpbGVcIiwgXCJ6aXBcIixcbiAgICBcInppcDNcIiwgXCJ6aXBXaXRoXCIsIFwiemlwV2l0aDNcIik7XG5cbiAgcmV0dXJuIHdrdztcbn0pKCk7XG5cbmV4cG9ydCBjb25zdCBoYXNrZWxsID0ge1xuICBzdGFydFN0YXRlOiBmdW5jdGlvbiAoKSAgeyByZXR1cm4geyBmOiBub3JtYWwgfTsgfSxcbiAgY29weVN0YXRlOiAgZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHsgZjogcy5mIH07IH0sXG5cbiAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgdCA9IHN0YXRlLmYoc3RyZWFtLCBmdW5jdGlvbihzKSB7IHN0YXRlLmYgPSBzOyB9KTtcbiAgICB2YXIgdyA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgcmV0dXJuIHdlbGxLbm93bldvcmRzLmhhc093blByb3BlcnR5KHcpID8gd2VsbEtub3duV29yZHNbd10gOiB0O1xuICB9LFxuXG4gIGxhbmd1YWdlRGF0YToge1xuICAgIGNvbW1lbnRUb2tlbnM6IHtsaW5lOiBcIi0tXCIsIGJsb2NrOiB7b3BlbjogXCJ7LVwiLCBjbG9zZTogXCItfVwifX1cbiAgfVxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/legacy-modes/mode/haskell.js\n");

/***/ })

}]);