(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{69:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clike", function() { return clike; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return c; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cpp", function() { return cpp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "java", function() { return java; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csharp", function() { return csharp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scala", function() { return scala; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "kotlin", function() { return kotlin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shader", function() { return shader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nesC", function() { return nesC; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "objectiveC", function() { return objectiveC; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "objectiveCpp", function() { return objectiveCpp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squirrel", function() { return squirrel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceylon", function() { return ceylon; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dart", function() { return dart; });\nfunction Context(indented, column, type, info, align, prev) {\n  this.indented = indented;\n  this.column = column;\n  this.type = type;\n  this.info = info;\n  this.align = align;\n  this.prev = prev;\n}\nfunction pushContext(state, col, type, info) {\n  var indent = state.indented;\n  if (state.context && state.context.type == "statement" && type != "statement")\n    indent = state.context.indented;\n  return state.context = new Context(indent, col, type, info, null, state.context);\n}\nfunction popContext(state) {\n  var t = state.context.type;\n  if (t == ")" || t == "]" || t == "}")\n    state.indented = state.context.indented;\n  return state.context = state.context.prev;\n}\n\nfunction typeBefore(stream, state, pos) {\n  if (state.prevToken == "variable" || state.prevToken == "type") return true;\n  if (/\\S(?:[^- ]>|[*\\]])\\s*$|\\*$/.test(stream.string.slice(0, pos))) return true;\n  if (state.typeAtEndOfLine && stream.column() == stream.indentation()) return true;\n}\n\nfunction isTopScope(context) {\n  for (;;) {\n    if (!context || context.type == "top") return true;\n    if (context.type == "}" && context.prev.info != "namespace") return false;\n    context = context.prev;\n  }\n}\n\nfunction clike(parserConfig) {\n  var statementIndentUnit = parserConfig.statementIndentUnit,\n      dontAlignCalls = parserConfig.dontAlignCalls,\n      keywords = parserConfig.keywords || {},\n      types = parserConfig.types || {},\n      builtin = parserConfig.builtin || {},\n      blockKeywords = parserConfig.blockKeywords || {},\n      defKeywords = parserConfig.defKeywords || {},\n      atoms = parserConfig.atoms || {},\n      hooks = parserConfig.hooks || {},\n      multiLineStrings = parserConfig.multiLineStrings,\n      indentStatements = parserConfig.indentStatements !== false,\n      indentSwitch = parserConfig.indentSwitch !== false,\n      namespaceSeparator = parserConfig.namespaceSeparator,\n      isPunctuationChar = parserConfig.isPunctuationChar || /[\\[\\]{}\\(\\),;\\:\\.]/,\n      numberStart = parserConfig.numberStart || /[\\d\\.]/,\n      number = parserConfig.number || /^(?:0x[a-f\\d]+|0b[01]+|(?:\\d+\\.?\\d*|\\.\\d+)(?:e[-+]?\\d+)?)(u|ll?|l|f)?/i,\n      isOperatorChar = parserConfig.isOperatorChar || /[+\\-*&%=<>!?|\\/]/,\n      isIdentifierChar = parserConfig.isIdentifierChar || /[\\w\\$_\\xa1-\\uffff]/,\n      // An optional function that takes a {string} token and returns true if it\n      // should be treated as a builtin.\n      isReservedIdentifier = parserConfig.isReservedIdentifier || false;\n\n  var curPunc, isDefKeyword;\n\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (hooks[ch]) {\n      var result = hooks[ch](stream, state);\n      if (result !== false) return result;\n    }\n    if (ch == \'"\' || ch == "\'") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    }\n    if (numberStart.test(ch)) {\n      stream.backUp(1)\n      if (stream.match(number)) return "number"\n      stream.next()\n    }\n    if (isPunctuationChar.test(ch)) {\n      curPunc = ch;\n      return null;\n    }\n    if (ch == "/") {\n      if (stream.eat("*")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      }\n      if (stream.eat("/")) {\n        stream.skipToEnd();\n        return "comment";\n      }\n    }\n    if (isOperatorChar.test(ch)) {\n      while (!stream.match(/^\\/[\\/*]/, false) && stream.eat(isOperatorChar)) {}\n      return "operator";\n    }\n    stream.eatWhile(isIdentifierChar);\n    if (namespaceSeparator) while (stream.match(namespaceSeparator))\n      stream.eatWhile(isIdentifierChar);\n\n    var cur = stream.current();\n    if (contains(keywords, cur)) {\n      if (contains(blockKeywords, cur)) curPunc = "newstatement";\n      if (contains(defKeywords, cur)) isDefKeyword = true;\n      return "keyword";\n    }\n    if (contains(types, cur)) return "type";\n    if (contains(builtin, cur)\n        || (isReservedIdentifier && isReservedIdentifier(cur))) {\n      if (contains(blockKeywords, cur)) curPunc = "newstatement";\n      return "builtin";\n    }\n    if (contains(atoms, cur)) return "atom";\n    return "variable";\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next, end = false;\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) {end = true; break;}\n        escaped = !escaped && next == "\\\\";\n      }\n      if (end || !(escaped || multiLineStrings))\n        state.tokenize = null;\n      return "string";\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == "/" && maybeEnd) {\n        state.tokenize = null;\n        break;\n      }\n      maybeEnd = (ch == "*");\n    }\n    return "comment";\n  }\n\n  function maybeEOL(stream, state) {\n    if (parserConfig.typeFirstDefinitions && stream.eol() && isTopScope(state.context))\n      state.typeAtEndOfLine = typeBefore(stream, state, stream.pos)\n  }\n\n  // Interface\n\n  return {\n    startState: function(indentUnit) {\n      return {\n        tokenize: null,\n        context: new Context(-indentUnit, 0, "top", null, false),\n        indented: 0,\n        startOfLine: true,\n        prevToken: null\n      };\n    },\n\n    token: function(stream, state) {\n      var ctx = state.context;\n      if (stream.sol()) {\n        if (ctx.align == null) ctx.align = false;\n        state.indented = stream.indentation();\n        state.startOfLine = true;\n      }\n      if (stream.eatSpace()) { maybeEOL(stream, state); return null; }\n      curPunc = isDefKeyword = null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style == "comment" || style == "meta") return style;\n      if (ctx.align == null) ctx.align = true;\n\n      if (curPunc == ";" || curPunc == ":" || (curPunc == "," && stream.match(/^\\s*(?:\\/\\/.*)?$/, false)))\n        while (state.context.type == "statement") popContext(state);\n      else if (curPunc == "{") pushContext(state, stream.column(), "}");\n      else if (curPunc == "[") pushContext(state, stream.column(), "]");\n      else if (curPunc == "(") pushContext(state, stream.column(), ")");\n      else if (curPunc == "}") {\n        while (ctx.type == "statement") ctx = popContext(state);\n        if (ctx.type == "}") ctx = popContext(state);\n        while (ctx.type == "statement") ctx = popContext(state);\n      }\n      else if (curPunc == ctx.type) popContext(state);\n      else if (indentStatements &&\n               (((ctx.type == "}" || ctx.type == "top") && curPunc != ";") ||\n                (ctx.type == "statement" && curPunc == "newstatement"))) {\n        pushContext(state, stream.column(), "statement", stream.current());\n      }\n\n      if (style == "variable" &&\n          ((state.prevToken == "def" ||\n            (parserConfig.typeFirstDefinitions && typeBefore(stream, state, stream.start) &&\n             isTopScope(state.context) && stream.match(/^\\s*\\(/, false)))))\n        style = "def";\n\n      if (hooks.token) {\n        var result = hooks.token(stream, state, style);\n        if (result !== undefined) style = result;\n      }\n\n      if (style == "def" && parserConfig.styleDefs === false) style = "variable";\n\n      state.startOfLine = false;\n      state.prevToken = isDefKeyword ? "def" : style || curPunc;\n      maybeEOL(stream, state);\n      return style;\n    },\n\n    indent: function(state, textAfter, context) {\n      if (state.tokenize != tokenBase && state.tokenize != null || state.typeAtEndOfLine) return null;\n      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);\n      var closing = firstChar == ctx.type;\n      if (ctx.type == "statement" && firstChar == "}") ctx = ctx.prev;\n      if (parserConfig.dontIndentStatements)\n        while (ctx.type == "statement" && parserConfig.dontIndentStatements.test(ctx.info))\n          ctx = ctx.prev\n      if (hooks.indent) {\n        var hook = hooks.indent(state, ctx, textAfter, context.unit);\n        if (typeof hook == "number") return hook\n      }\n      var switchBlock = ctx.prev && ctx.prev.info == "switch";\n      if (parserConfig.allmanIndentation && /[{(]/.test(firstChar)) {\n        while (ctx.type != "top" && ctx.type != "}") ctx = ctx.prev\n        return ctx.indented\n      }\n      if (ctx.type == "statement")\n        return ctx.indented + (firstChar == "{" ? 0 : statementIndentUnit || context.unit);\n      if (ctx.align && (!dontAlignCalls || ctx.type != ")"))\n        return ctx.column + (closing ? 0 : 1);\n      if (ctx.type == ")" && !closing)\n        return ctx.indented + (statementIndentUnit || context.unit);\n\n      return ctx.indented + (closing ? 0 : context.unit) +\n        (!closing && switchBlock && !/^(?:case|default)\\b/.test(textAfter) ? context.unit : 0);\n    },\n\n    languageData: {\n      indentOnInput: indentSwitch ? /^\\s*(?:case .*?:|default:|\\{\\}?|\\})$/ : /^\\s*[{}]$/,\n      commentTokens: {line: "//", block: {open: "/*", close: "*/"}},\n      autocomplete: Object.keys(keywords).concat(Object.keys(types)).concat(Object.keys(builtin)).concat(Object.keys(atoms)),\n      ...parserConfig.languageData\n    }\n  };\n};\n\nfunction words(str) {\n  var obj = {}, words = str.split(" ");\n  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n  return obj;\n}\nfunction contains(words, word) {\n  if (typeof words === "function") {\n    return words(word);\n  } else {\n    return words.propertyIsEnumerable(word);\n  }\n}\nvar cKeywords = "auto if break case register continue return default do sizeof " +\n    "static else struct switch extern typedef union for goto while enum const " +\n    "volatile inline restrict asm fortran";\n\n// Keywords from https://en.cppreference.com/w/cpp/keyword includes C++20.\nvar cppKeywords = "alignas alignof and and_eq audit axiom bitand bitor catch " +\n    "class compl concept constexpr const_cast decltype delete dynamic_cast " +\n    "explicit export final friend import module mutable namespace new noexcept " +\n    "not not_eq operator or or_eq override private protected public " +\n    "reinterpret_cast requires static_assert static_cast template this " +\n    "thread_local throw try typeid typename using virtual xor xor_eq";\n\nvar objCKeywords = "bycopy byref in inout oneway out self super atomic nonatomic retain copy " +\n    "readwrite readonly strong weak assign typeof nullable nonnull null_resettable _cmd " +\n    "@interface @implementation @end @protocol @encode @property @synthesize @dynamic @class " +\n    "@public @package @private @protected @required @optional @try @catch @finally @import " +\n    "@selector @encode @defs @synchronized @autoreleasepool @compatibility_alias @available";\n\nvar objCBuiltins = "FOUNDATION_EXPORT FOUNDATION_EXTERN NS_INLINE NS_FORMAT_FUNCTION " +\n    " NS_RETURNS_RETAINEDNS_ERROR_ENUM NS_RETURNS_NOT_RETAINED NS_RETURNS_INNER_POINTER " +\n    "NS_DESIGNATED_INITIALIZER NS_ENUM NS_OPTIONS NS_REQUIRES_NIL_TERMINATION " +\n    "NS_ASSUME_NONNULL_BEGIN NS_ASSUME_NONNULL_END NS_SWIFT_NAME NS_REFINED_FOR_SWIFT"\n\n// Do not use this. Use the cTypes function below. This is global just to avoid\n// excessive calls when cTypes is being called multiple times during a parse.\nvar basicCTypes = words("int long char short double float unsigned signed " +\n                        "void bool");\n\n// Do not use this. Use the objCTypes function below. This is global just to avoid\n// excessive calls when objCTypes is being called multiple times during a parse.\nvar basicObjCTypes = words("SEL instancetype id Class Protocol BOOL");\n\n// Returns true if identifier is a "C" type.\n// C type is defined as those that are reserved by the compiler (basicTypes),\n// and those that end in _t (Reserved by POSIX for types)\n// http://www.gnu.org/software/libc/manual/html_node/Reserved-Names.html\nfunction cTypes(identifier) {\n  return contains(basicCTypes, identifier) || /.+_t$/.test(identifier);\n}\n\n// Returns true if identifier is a "Objective C" type.\nfunction objCTypes(identifier) {\n  return cTypes(identifier) || contains(basicObjCTypes, identifier);\n}\n\nvar cBlockKeywords = "case do else for if switch while struct enum union";\nvar cDefKeywords = "struct enum union";\n\nfunction cppHook(stream, state) {\n  if (!state.startOfLine) return false\n  for (var ch, next = null; ch = stream.peek();) {\n    if (ch == "\\\\" && stream.match(/^.$/)) {\n      next = cppHook\n      break\n    } else if (ch == "/" && stream.match(/^\\/[\\/\\*]/, false)) {\n      break\n    }\n    stream.next()\n  }\n  state.tokenize = next\n  return "meta"\n}\n\nfunction pointerHook(_stream, state) {\n  if (state.prevToken == "type") return "type";\n  return false;\n}\n\n// For C and C++ (and ObjC): identifiers starting with __\n// or _ followed by a capital letter are reserved for the compiler.\nfunction cIsReservedIdentifier(token) {\n  if (!token || token.length < 2) return false;\n  if (token[0] != \'_\') return false;\n  return (token[1] == \'_\') || (token[1] !== token[1].toLowerCase());\n}\n\nfunction cpp14Literal(stream) {\n  stream.eatWhile(/[\\w\\.\']/);\n  return "number";\n}\n\nfunction cpp11StringHook(stream, state) {\n  stream.backUp(1);\n  // Raw strings.\n  if (stream.match(/^(?:R|u8R|uR|UR|LR)/)) {\n    var match = stream.match(/^"([^\\s\\\\()]{0,16})\\(/);\n    if (!match) {\n      return false;\n    }\n    state.cpp11RawStringDelim = match[1];\n    state.tokenize = tokenRawString;\n    return tokenRawString(stream, state);\n  }\n  // Unicode strings/chars.\n  if (stream.match(/^(?:u8|u|U|L)/)) {\n    if (stream.match(/^["\']/, /* eat */ false)) {\n      return "string";\n    }\n    return false;\n  }\n  // Ignore this hook.\n  stream.next();\n  return false;\n}\n\nfunction cppLooksLikeConstructor(word) {\n  var lastTwo = /(\\w+)::~?(\\w+)$/.exec(word);\n  return lastTwo && lastTwo[1] == lastTwo[2];\n}\n\n// C#-style strings where "" escapes a quote.\nfunction tokenAtString(stream, state) {\n  var next;\n  while ((next = stream.next()) != null) {\n    if (next == \'"\' && !stream.eat(\'"\')) {\n      state.tokenize = null;\n      break;\n    }\n  }\n  return "string";\n}\n\n// C++11 raw string literal is <prefix>"<delim>( anything )<delim>", where\n// <delim> can be a string up to 16 characters long.\nfunction tokenRawString(stream, state) {\n  // Escape characters that have special regex meanings.\n  var delim = state.cpp11RawStringDelim.replace(/[^\\w\\s]/g, \'\\\\$&\');\n  var match = stream.match(new RegExp(".*?\\\\)" + delim + \'"\'));\n  if (match)\n    state.tokenize = null;\n  else\n    stream.skipToEnd();\n  return "string";\n}\n\nconst c = clike({\n  keywords: words(cKeywords),\n  types: cTypes,\n  blockKeywords: words(cBlockKeywords),\n  defKeywords: words(cDefKeywords),\n  typeFirstDefinitions: true,\n  atoms: words("NULL true false"),\n  isReservedIdentifier: cIsReservedIdentifier,\n  hooks: {\n    "#": cppHook,\n    "*": pointerHook,\n  }\n})\n\nconst cpp = clike({\n  keywords: words(cKeywords + " " + cppKeywords),\n  types: cTypes,\n  blockKeywords: words(cBlockKeywords + " class try catch"),\n  defKeywords: words(cDefKeywords + " class namespace"),\n  typeFirstDefinitions: true,\n  atoms: words("true false NULL nullptr"),\n  dontIndentStatements: /^template$/,\n  isIdentifierChar: /[\\w\\$_~\\xa1-\\uffff]/,\n  isReservedIdentifier: cIsReservedIdentifier,\n  hooks: {\n    "#": cppHook,\n    "*": pointerHook,\n    "u": cpp11StringHook,\n    "U": cpp11StringHook,\n    "L": cpp11StringHook,\n    "R": cpp11StringHook,\n    "0": cpp14Literal,\n    "1": cpp14Literal,\n    "2": cpp14Literal,\n    "3": cpp14Literal,\n    "4": cpp14Literal,\n    "5": cpp14Literal,\n    "6": cpp14Literal,\n    "7": cpp14Literal,\n    "8": cpp14Literal,\n    "9": cpp14Literal,\n    token: function(stream, state, style) {\n      if (style == "variable" && stream.peek() == "(" &&\n          (state.prevToken == ";" || state.prevToken == null ||\n           state.prevToken == "}") &&\n          cppLooksLikeConstructor(stream.current()))\n        return "def";\n    }\n  },\n  namespaceSeparator: "::"\n});\n\nconst java = clike({\n  keywords: words("abstract assert break case catch class const continue default " +\n                  "do else enum extends final finally for goto if implements import " +\n                  "instanceof interface native new package private protected public " +\n                  "return static strictfp super switch synchronized this throw throws transient " +\n                  "try volatile while @interface"),\n  types: words("var byte short int long float double boolean char void Boolean Byte Character Double Float " +\n               "Integer Long Number Object Short String StringBuffer StringBuilder Void"),\n  blockKeywords: words("catch class do else finally for if switch try while"),\n  defKeywords: words("class interface enum @interface"),\n  typeFirstDefinitions: true,\n  atoms: words("true false null"),\n  number: /^(?:0x[a-f\\d_]+|0b[01_]+|(?:[\\d_]+\\.?\\d*|\\.\\d+)(?:e[-+]?[\\d_]+)?)(u|ll?|l|f)?/i,\n  hooks: {\n    "@": function(stream) {\n      // Don\'t match the @interface keyword.\n      if (stream.match(\'interface\', false)) return false;\n\n      stream.eatWhile(/[\\w\\$_]/);\n      return "meta";\n    },\n    \'"\': function(stream, state) {\n      if (!stream.match(/""$/)) return false;\n      state.tokenize = tokenTripleString;\n      return state.tokenize(stream, state);\n    }\n  }\n})\n\nconst csharp = clike({\n  keywords: words("abstract as async await base break case catch checked class const continue" +\n                  " default delegate do else enum event explicit extern finally fixed for" +\n                  " foreach goto if implicit in interface internal is lock namespace new" +\n                  " operator out override params private protected public readonly ref return sealed" +\n                  " sizeof stackalloc static struct switch this throw try typeof unchecked" +\n                  " unsafe using virtual void volatile while add alias ascending descending dynamic from get" +\n                  " global group into join let orderby partial remove select set value var yield"),\n  types: words("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func" +\n               " Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32" +\n               " UInt64 bool byte char decimal double short int long object"  +\n               " sbyte float string ushort uint ulong"),\n  blockKeywords: words("catch class do else finally for foreach if struct switch try while"),\n  defKeywords: words("class interface namespace struct var"),\n  typeFirstDefinitions: true,\n  atoms: words("true false null"),\n  hooks: {\n    "@": function(stream, state) {\n      if (stream.eat(\'"\')) {\n        state.tokenize = tokenAtString;\n        return tokenAtString(stream, state);\n      }\n      stream.eatWhile(/[\\w\\$_]/);\n      return "meta";\n    }\n  }\n});\n\nfunction tokenTripleString(stream, state) {\n  var escaped = false;\n  while (!stream.eol()) {\n    if (!escaped && stream.match(\'"""\')) {\n      state.tokenize = null;\n      break;\n    }\n    escaped = stream.next() == "\\\\" && !escaped;\n  }\n  return "string";\n}\n\nfunction tokenNestedComment(depth) {\n  return function (stream, state) {\n    var ch\n    while (ch = stream.next()) {\n      if (ch == "*" && stream.eat("/")) {\n        if (depth == 1) {\n          state.tokenize = null\n          break\n        } else {\n          state.tokenize = tokenNestedComment(depth - 1)\n          return state.tokenize(stream, state)\n        }\n      } else if (ch == "/" && stream.eat("*")) {\n        state.tokenize = tokenNestedComment(depth + 1)\n        return state.tokenize(stream, state)\n      }\n    }\n    return "comment"\n  }\n}\n\nconst scala = clike({\n  keywords: words(\n    /* scala */\n    "abstract case catch class def do else extends final finally for forSome if " +\n      "implicit import lazy match new null object override package private protected return " +\n      "sealed super this throw trait try type val var while with yield _ " +\n\n    /* package scala */\n    "assert assume require print println printf readLine readBoolean readByte readShort " +\n      "readChar readInt readLong readFloat readDouble"\n  ),\n  types: words(\n    "AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either " +\n      "Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable " +\n      "Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering " +\n      "Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder " +\n      "StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector " +\n\n    /* package java.lang */\n    "Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable " +\n      "Compiler Double Exception Float Integer Long Math Number Object Package Pair Process " +\n      "Runtime Runnable SecurityManager Short StackTraceElement StrictMath String " +\n      "StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"\n  ),\n  multiLineStrings: true,\n  blockKeywords: words("catch class enum do else finally for forSome if match switch try while"),\n  defKeywords: words("class enum def object package trait type val var"),\n  atoms: words("true false null"),\n  indentStatements: false,\n  indentSwitch: false,\n  isOperatorChar: /[+\\-*&%=<>!?|\\/#:@]/,\n  hooks: {\n    "@": function(stream) {\n      stream.eatWhile(/[\\w\\$_]/);\n      return "meta";\n    },\n    \'"\': function(stream, state) {\n      if (!stream.match(\'""\')) return false;\n      state.tokenize = tokenTripleString;\n      return state.tokenize(stream, state);\n    },\n    "\'": function(stream) {\n      stream.eatWhile(/[\\w\\$_\\xa1-\\uffff]/);\n      return "atom";\n    },\n    "=": function(stream, state) {\n      var cx = state.context\n      if (cx.type == "}" && cx.align && stream.eat(">")) {\n        state.context = new Context(cx.indented, cx.column, cx.type, cx.info, null, cx.prev)\n        return "operator"\n      } else {\n        return false\n      }\n    },\n\n    "/": function(stream, state) {\n      if (!stream.eat("*")) return false\n      state.tokenize = tokenNestedComment(1)\n      return state.tokenize(stream, state)\n    }\n  },\n  languageData: {\n    closeBrackets: {brackets: ["(", "[", "{", "\'", \'"\', \'"""\']}\n  }\n});\n\nfunction tokenKotlinString(tripleString){\n  return function (stream, state) {\n    var escaped = false, next, end = false;\n    while (!stream.eol()) {\n      if (!tripleString && !escaped && stream.match(\'"\') ) {end = true; break;}\n      if (tripleString && stream.match(\'"""\')) {end = true; break;}\n      next = stream.next();\n      if(!escaped && next == "$" && stream.match(\'{\'))\n        stream.skipTo("}");\n      escaped = !escaped && next == "\\\\" && !tripleString;\n    }\n    if (end || !tripleString)\n      state.tokenize = null;\n    return "string";\n  }\n}\n\nconst kotlin = clike({\n  keywords: words(\n    /*keywords*/\n    "package as typealias class interface this super val operator " +\n      "var fun for is in This throw return annotation " +\n      "break continue object if else while do try when !in !is as? " +\n\n    /*soft keywords*/\n    "file import where by get set abstract enum open inner override private public internal " +\n      "protected catch finally out final vararg reified dynamic companion constructor init " +\n      "sealed field property receiver param sparam lateinit data inline noinline tailrec " +\n      "external annotation crossinline const operator infix suspend actual expect setparam"\n  ),\n  types: words(\n    /* package java.lang */\n    "Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable " +\n      "Compiler Double Exception Float Integer Long Math Number Object Package Pair Process " +\n      "Runtime Runnable SecurityManager Short StackTraceElement StrictMath String " +\n      "StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void Annotation Any BooleanArray " +\n      "ByteArray Char CharArray DeprecationLevel DoubleArray Enum FloatArray Function Int IntArray Lazy " +\n      "LazyThreadSafetyMode LongArray Nothing ShortArray Unit"\n  ),\n  intendSwitch: false,\n  indentStatements: false,\n  multiLineStrings: true,\n  number: /^(?:0x[a-f\\d_]+|0b[01_]+|(?:[\\d_]+(\\.\\d+)?|\\.\\d+)(?:e[-+]?[\\d_]+)?)(u|ll?|l|f)?/i,\n  blockKeywords: words("catch class do else finally for if where try while enum"),\n  defKeywords: words("class val var object interface fun"),\n  atoms: words("true false null this"),\n  hooks: {\n    "@": function(stream) {\n      stream.eatWhile(/[\\w\\$_]/);\n      return "meta";\n    },\n    \'*\': function(_stream, state) {\n      return state.prevToken == \'.\' ? \'variable\' : \'operator\';\n    },\n    \'"\': function(stream, state) {\n      state.tokenize = tokenKotlinString(stream.match(\'""\'));\n      return state.tokenize(stream, state);\n    },\n    "/": function(stream, state) {\n      if (!stream.eat("*")) return false;\n      state.tokenize = tokenNestedComment(1);\n      return state.tokenize(stream, state)\n    },\n    indent: function(state, ctx, textAfter, indentUnit) {\n      var firstChar = textAfter && textAfter.charAt(0);\n      if ((state.prevToken == "}" || state.prevToken == ")") && textAfter == "")\n        return state.indented;\n      if ((state.prevToken == "operator" && textAfter != "}" && state.context.type != "}") ||\n          state.prevToken == "variable" && firstChar == "." ||\n          (state.prevToken == "}" || state.prevToken == ")") && firstChar == ".")\n        return indentUnit * 2 + ctx.indented;\n      if (ctx.align && ctx.type == "}")\n        return ctx.indented + (state.context.type == (textAfter || "").charAt(0) ? 0 : indentUnit);\n    }\n  },\n  languageData: {\n    closeBrackets: {brackets: ["(", "[", "{", "\'", \'"\', \'"""\']}\n  }\n});\n\nconst shader = clike({\n  keywords: words("sampler1D sampler2D sampler3D samplerCube " +\n                  "sampler1DShadow sampler2DShadow " +\n                  "const attribute uniform varying " +\n                  "break continue discard return " +\n                  "for while do if else struct " +\n                  "in out inout"),\n  types: words("float int bool void " +\n               "vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 " +\n               "mat2 mat3 mat4"),\n  blockKeywords: words("for while do if else struct"),\n  builtin: words("radians degrees sin cos tan asin acos atan " +\n                 "pow exp log exp2 sqrt inversesqrt " +\n                 "abs sign floor ceil fract mod min max clamp mix step smoothstep " +\n                 "length distance dot cross normalize ftransform faceforward " +\n                 "reflect refract matrixCompMult " +\n                 "lessThan lessThanEqual greaterThan greaterThanEqual " +\n                 "equal notEqual any all not " +\n                 "texture1D texture1DProj texture1DLod texture1DProjLod " +\n                 "texture2D texture2DProj texture2DLod texture2DProjLod " +\n                 "texture3D texture3DProj texture3DLod texture3DProjLod " +\n                 "textureCube textureCubeLod " +\n                 "shadow1D shadow2D shadow1DProj shadow2DProj " +\n                 "shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod " +\n                 "dFdx dFdy fwidth " +\n                 "noise1 noise2 noise3 noise4"),\n  atoms: words("true false " +\n               "gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex " +\n               "gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 " +\n               "gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 " +\n               "gl_FogCoord gl_PointCoord " +\n               "gl_Position gl_PointSize gl_ClipVertex " +\n               "gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor " +\n               "gl_TexCoord gl_FogFragCoord " +\n               "gl_FragCoord gl_FrontFacing " +\n               "gl_FragData gl_FragDepth " +\n               "gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix " +\n               "gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse " +\n               "gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse " +\n               "gl_TextureMatrixTranspose gl_ModelViewMatrixInverseTranspose " +\n               "gl_ProjectionMatrixInverseTranspose " +\n               "gl_ModelViewProjectionMatrixInverseTranspose " +\n               "gl_TextureMatrixInverseTranspose " +\n               "gl_NormalScale gl_DepthRange gl_ClipPlane " +\n               "gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel " +\n               "gl_FrontLightModelProduct gl_BackLightModelProduct " +\n               "gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ " +\n               "gl_FogParameters " +\n               "gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords " +\n               "gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats " +\n               "gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits " +\n               "gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits " +\n               "gl_MaxDrawBuffers"),\n  indentSwitch: false,\n  hooks: {"#": cppHook}\n})\n\nconst nesC = clike({\n  keywords: words(cKeywords + " as atomic async call command component components configuration event generic " +\n                  "implementation includes interface module new norace nx_struct nx_union post provides " +\n                  "signal task uses abstract extends"),\n  types: cTypes,\n  blockKeywords: words(cBlockKeywords),\n  atoms: words("null true false"),\n  hooks: {"#": cppHook}\n})\n\nconst objectiveC = clike({\n  keywords: words(cKeywords + " " + objCKeywords),\n  types: objCTypes,\n  builtin: words(objCBuiltins),\n  blockKeywords: words(cBlockKeywords + " @synthesize @try @catch @finally @autoreleasepool @synchronized"),\n  defKeywords: words(cDefKeywords + " @interface @implementation @protocol @class"),\n  dontIndentStatements: /^@.*$/,\n  typeFirstDefinitions: true,\n  atoms: words("YES NO NULL Nil nil true false nullptr"),\n  isReservedIdentifier: cIsReservedIdentifier,\n  hooks: {\n    "#": cppHook,\n    "*": pointerHook,\n  }\n})\n\nconst objectiveCpp = clike({\n  keywords: words(cKeywords + " " + objCKeywords + " " + cppKeywords),\n  types: objCTypes,\n  builtin: words(objCBuiltins),\n  blockKeywords: words(cBlockKeywords + " @synthesize @try @catch @finally @autoreleasepool @synchronized class try catch"),\n  defKeywords: words(cDefKeywords + " @interface @implementation @protocol @class class namespace"),\n  dontIndentStatements: /^@.*$|^template$/,\n  typeFirstDefinitions: true,\n  atoms: words("YES NO NULL Nil nil true false nullptr"),\n  isReservedIdentifier: cIsReservedIdentifier,\n  hooks: {\n    "#": cppHook,\n    "*": pointerHook,\n    "u": cpp11StringHook,\n    "U": cpp11StringHook,\n    "L": cpp11StringHook,\n    "R": cpp11StringHook,\n    "0": cpp14Literal,\n    "1": cpp14Literal,\n    "2": cpp14Literal,\n    "3": cpp14Literal,\n    "4": cpp14Literal,\n    "5": cpp14Literal,\n    "6": cpp14Literal,\n    "7": cpp14Literal,\n    "8": cpp14Literal,\n    "9": cpp14Literal,\n    token: function(stream, state, style) {\n      if (style == "variable" && stream.peek() == "(" &&\n          (state.prevToken == ";" || state.prevToken == null ||\n           state.prevToken == "}") &&\n          cppLooksLikeConstructor(stream.current()))\n        return "def";\n    }\n  },\n  namespaceSeparator: "::"\n})\n\nconst squirrel = clike({\n  keywords: words("base break clone continue const default delete enum extends function in class" +\n                  " foreach local resume return this throw typeof yield constructor instanceof static"),\n  types: cTypes,\n  blockKeywords: words("case catch class else for foreach if switch try while"),\n  defKeywords: words("function local class"),\n  typeFirstDefinitions: true,\n  atoms: words("true false null"),\n  hooks: {"#": cppHook}\n})\n\n// Ceylon Strings need to deal with interpolation\nvar stringTokenizer = null;\nfunction tokenCeylonString(type) {\n  return function(stream, state) {\n    var escaped = false, next, end = false;\n    while (!stream.eol()) {\n      if (!escaped && stream.match(\'"\') &&\n          (type == "single" || stream.match(\'""\'))) {\n        end = true;\n        break;\n      }\n      if (!escaped && stream.match(\'``\')) {\n        stringTokenizer = tokenCeylonString(type);\n        end = true;\n        break;\n      }\n      next = stream.next();\n      escaped = type == "single" && !escaped && next == "\\\\";\n    }\n    if (end)\n      state.tokenize = null;\n    return "string";\n  }\n}\n\nconst ceylon = clike({\n  keywords: words("abstracts alias assembly assert assign break case catch class continue dynamic else" +\n                  " exists extends finally for function given if import in interface is let module new" +\n                  " nonempty object of out outer package return satisfies super switch then this throw" +\n                  " try value void while"),\n  types: function(word) {\n    // In Ceylon all identifiers that start with an uppercase are types\n    var first = word.charAt(0);\n    return (first === first.toUpperCase() && first !== first.toLowerCase());\n  },\n  blockKeywords: words("case catch class dynamic else finally for function if interface module new object switch try while"),\n  defKeywords: words("class dynamic function interface module object package value"),\n  builtin: words("abstract actual aliased annotation by default deprecated doc final formal late license" +\n                 " native optional sealed see serializable shared suppressWarnings tagged throws variable"),\n  isPunctuationChar: /[\\[\\]{}\\(\\),;\\:\\.`]/,\n  isOperatorChar: /[+\\-*&%=<>!?|^~:\\/]/,\n  numberStart: /[\\d#$]/,\n  number: /^(?:#[\\da-fA-F_]+|\\$[01_]+|[\\d_]+[kMGTPmunpf]?|[\\d_]+\\.[\\d_]+(?:[eE][-+]?\\d+|[kMGTPmunpf]|)|)/i,\n  multiLineStrings: true,\n  typeFirstDefinitions: true,\n  atoms: words("true false null larger smaller equal empty finished"),\n  indentSwitch: false,\n  styleDefs: false,\n  hooks: {\n    "@": function(stream) {\n      stream.eatWhile(/[\\w\\$_]/);\n      return "meta";\n    },\n    \'"\': function(stream, state) {\n      state.tokenize = tokenCeylonString(stream.match(\'""\') ? "triple" : "single");\n      return state.tokenize(stream, state);\n    },\n    \'`\': function(stream, state) {\n      if (!stringTokenizer || !stream.match(\'`\')) return false;\n      state.tokenize = stringTokenizer;\n      stringTokenizer = null;\n      return state.tokenize(stream, state);\n    },\n    "\'": function(stream) {\n      stream.eatWhile(/[\\w\\$_\\xa1-\\uffff]/);\n      return "atom";\n    },\n    token: function(_stream, state, style) {\n      if ((style == "variable" || style == "type") &&\n          state.prevToken == ".") {\n        return "variableName.special";\n      }\n    }\n  },\n  languageData: {\n    closeBrackets: {brackets: ["(", "[", "{", "\'", \'"\', \'"""\']}\n  }\n})\n\nfunction pushInterpolationStack(state) {\n  (state.interpolationStack || (state.interpolationStack = [])).push(state.tokenize);\n}\n\nfunction popInterpolationStack(state) {\n  return (state.interpolationStack || (state.interpolationStack = [])).pop();\n}\n\nfunction sizeInterpolationStack(state) {\n  return state.interpolationStack ? state.interpolationStack.length : 0;\n}\n\nfunction tokenDartString(quote, stream, state, raw) {\n  var tripleQuoted = false;\n  if (stream.eat(quote)) {\n    if (stream.eat(quote)) tripleQuoted = true;\n    else return "string"; //empty string\n  }\n  function tokenStringHelper(stream, state) {\n    var escaped = false;\n    while (!stream.eol()) {\n      if (!raw && !escaped && stream.peek() == "$") {\n        pushInterpolationStack(state);\n        state.tokenize = tokenInterpolation;\n        return "string";\n      }\n      var next = stream.next();\n      if (next == quote && !escaped && (!tripleQuoted || stream.match(quote + quote))) {\n        state.tokenize = null;\n        break;\n      }\n      escaped = !raw && !escaped && next == "\\\\";\n    }\n    return "string";\n  }\n  state.tokenize = tokenStringHelper;\n  return tokenStringHelper(stream, state);\n}\n\nfunction tokenInterpolation(stream, state) {\n  stream.eat("$");\n  if (stream.eat("{")) {\n    // let clike handle the content of ${...},\n    // we take over again when "}" appears (see hooks).\n    state.tokenize = null;\n  } else {\n    state.tokenize = tokenInterpolationIdentifier;\n  }\n  return null;\n}\n\nfunction tokenInterpolationIdentifier(stream, state) {\n  stream.eatWhile(/[\\w_]/);\n  state.tokenize = popInterpolationStack(state);\n  return "variable";\n}\n\nconst dart = clike({\n  keywords: words("this super static final const abstract class extends external factory " +\n                  "implements mixin get native set typedef with enum throw rethrow " +\n                  "assert break case continue default in return new deferred async await covariant " +\n                  "try catch finally do else for if switch while import library export " +\n                  "part of show hide is as extension on yield late required"),\n  blockKeywords: words("try catch finally do else for if switch while"),\n  builtin: words("void bool num int double dynamic var String Null Never"),\n  atoms: words("true false null"),\n  hooks: {\n    "@": function(stream) {\n      stream.eatWhile(/[\\w\\$_\\.]/);\n      return "meta";\n    },\n\n    // custom string handling to deal with triple-quoted strings and string interpolation\n    "\'": function(stream, state) {\n      return tokenDartString("\'", stream, state, false);\n    },\n    "\\"": function(stream, state) {\n      return tokenDartString("\\"", stream, state, false);\n    },\n    "r": function(stream, state) {\n      var peek = stream.peek();\n      if (peek == "\'" || peek == "\\"") {\n        return tokenDartString(stream.next(), stream, state, true);\n      }\n      return false;\n    },\n\n    "}": function(_stream, state) {\n      // "}" is end of interpolation, if interpolation stack is non-empty\n      if (sizeInterpolationStack(state) > 0) {\n        state.tokenize = popInterpolationStack(state);\n        return null;\n      }\n      return false;\n    },\n\n    "/": function(stream, state) {\n      if (!stream.eat("*")) return false\n      state.tokenize = tokenNestedComment(1)\n      return state.tokenize(stream, state)\n    },\n    token: function(stream, _, style) {\n      if (style == "variable") {\n        // Assume uppercase symbols are classes\n        var isUpper = RegExp(\'^[_$]*[A-Z][a-zA-Z0-9_$]*$\',\'g\');\n        if (isUpper.test(stream.current())) {\n          return \'type\';\n        }\n      }\n    }\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvY2xpa2UuanM/NDkxZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLHNDQUFzQztBQUN0QywwQ0FBMEM7QUFDMUMsc0RBQXNEO0FBQ3RELGtEQUFrRDtBQUNsRCxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLE1BQU07QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIseUJBQXlCLGFBQWE7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCO0FBQ0EsNEJBQTRCLHlDQUF5QztBQUNyRTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdDQUF3QztBQUN4RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsaUVBQWlFLEVBQUUsSUFBSSxjQUFjO0FBQ3JGLHNCQUFzQixvQkFBb0IseUJBQXlCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2QsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxLQUFLO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0EsbURBQW1EO0FBQ25ELHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsMkRBQTJELDZCQUE2QjtBQUN4RjtBQUNBLGdDQUFnQztBQUNoQztBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsQ0FBQzs7QUFFTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQix5Q0FBeUMsSUFBSTtBQUM3QyxpQ0FBaUM7QUFDakM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxNQUFNO0FBQ04sV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiI2OS5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIENvbnRleHQoaW5kZW50ZWQsIGNvbHVtbiwgdHlwZSwgaW5mbywgYWxpZ24sIHByZXYpIHtcbiAgdGhpcy5pbmRlbnRlZCA9IGluZGVudGVkO1xuICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5pbmZvID0gaW5mbztcbiAgdGhpcy5hbGlnbiA9IGFsaWduO1xuICB0aGlzLnByZXYgPSBwcmV2O1xufVxuZnVuY3Rpb24gcHVzaENvbnRleHQoc3RhdGUsIGNvbCwgdHlwZSwgaW5mbykge1xuICB2YXIgaW5kZW50ID0gc3RhdGUuaW5kZW50ZWQ7XG4gIGlmIChzdGF0ZS5jb250ZXh0ICYmIHN0YXRlLmNvbnRleHQudHlwZSA9PSBcInN0YXRlbWVudFwiICYmIHR5cGUgIT0gXCJzdGF0ZW1lbnRcIilcbiAgICBpbmRlbnQgPSBzdGF0ZS5jb250ZXh0LmluZGVudGVkO1xuICByZXR1cm4gc3RhdGUuY29udGV4dCA9IG5ldyBDb250ZXh0KGluZGVudCwgY29sLCB0eXBlLCBpbmZvLCBudWxsLCBzdGF0ZS5jb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHBvcENvbnRleHQoc3RhdGUpIHtcbiAgdmFyIHQgPSBzdGF0ZS5jb250ZXh0LnR5cGU7XG4gIGlmICh0ID09IFwiKVwiIHx8IHQgPT0gXCJdXCIgfHwgdCA9PSBcIn1cIilcbiAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0YXRlLmNvbnRleHQuaW5kZW50ZWQ7XG4gIHJldHVybiBzdGF0ZS5jb250ZXh0ID0gc3RhdGUuY29udGV4dC5wcmV2O1xufVxuXG5mdW5jdGlvbiB0eXBlQmVmb3JlKHN0cmVhbSwgc3RhdGUsIHBvcykge1xuICBpZiAoc3RhdGUucHJldlRva2VuID09IFwidmFyaWFibGVcIiB8fCBzdGF0ZS5wcmV2VG9rZW4gPT0gXCJ0eXBlXCIpIHJldHVybiB0cnVlO1xuICBpZiAoL1xcUyg/OlteLSBdPnxbKlxcXV0pXFxzKiR8XFwqJC8udGVzdChzdHJlYW0uc3RyaW5nLnNsaWNlKDAsIHBvcykpKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKHN0YXRlLnR5cGVBdEVuZE9mTGluZSAmJiBzdHJlYW0uY29sdW1uKCkgPT0gc3RyZWFtLmluZGVudGF0aW9uKCkpIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1RvcFNjb3BlKGNvbnRleHQpIHtcbiAgZm9yICg7Oykge1xuICAgIGlmICghY29udGV4dCB8fCBjb250ZXh0LnR5cGUgPT0gXCJ0b3BcIikgcmV0dXJuIHRydWU7XG4gICAgaWYgKGNvbnRleHQudHlwZSA9PSBcIn1cIiAmJiBjb250ZXh0LnByZXYuaW5mbyAhPSBcIm5hbWVzcGFjZVwiKSByZXR1cm4gZmFsc2U7XG4gICAgY29udGV4dCA9IGNvbnRleHQucHJldjtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xpa2UocGFyc2VyQ29uZmlnKSB7XG4gIHZhciBzdGF0ZW1lbnRJbmRlbnRVbml0ID0gcGFyc2VyQ29uZmlnLnN0YXRlbWVudEluZGVudFVuaXQsXG4gICAgICBkb250QWxpZ25DYWxscyA9IHBhcnNlckNvbmZpZy5kb250QWxpZ25DYWxscyxcbiAgICAgIGtleXdvcmRzID0gcGFyc2VyQ29uZmlnLmtleXdvcmRzIHx8IHt9LFxuICAgICAgdHlwZXMgPSBwYXJzZXJDb25maWcudHlwZXMgfHwge30sXG4gICAgICBidWlsdGluID0gcGFyc2VyQ29uZmlnLmJ1aWx0aW4gfHwge30sXG4gICAgICBibG9ja0tleXdvcmRzID0gcGFyc2VyQ29uZmlnLmJsb2NrS2V5d29yZHMgfHwge30sXG4gICAgICBkZWZLZXl3b3JkcyA9IHBhcnNlckNvbmZpZy5kZWZLZXl3b3JkcyB8fCB7fSxcbiAgICAgIGF0b21zID0gcGFyc2VyQ29uZmlnLmF0b21zIHx8IHt9LFxuICAgICAgaG9va3MgPSBwYXJzZXJDb25maWcuaG9va3MgfHwge30sXG4gICAgICBtdWx0aUxpbmVTdHJpbmdzID0gcGFyc2VyQ29uZmlnLm11bHRpTGluZVN0cmluZ3MsXG4gICAgICBpbmRlbnRTdGF0ZW1lbnRzID0gcGFyc2VyQ29uZmlnLmluZGVudFN0YXRlbWVudHMgIT09IGZhbHNlLFxuICAgICAgaW5kZW50U3dpdGNoID0gcGFyc2VyQ29uZmlnLmluZGVudFN3aXRjaCAhPT0gZmFsc2UsXG4gICAgICBuYW1lc3BhY2VTZXBhcmF0b3IgPSBwYXJzZXJDb25maWcubmFtZXNwYWNlU2VwYXJhdG9yLFxuICAgICAgaXNQdW5jdHVhdGlvbkNoYXIgPSBwYXJzZXJDb25maWcuaXNQdW5jdHVhdGlvbkNoYXIgfHwgL1tcXFtcXF17fVxcKFxcKSw7XFw6XFwuXS8sXG4gICAgICBudW1iZXJTdGFydCA9IHBhcnNlckNvbmZpZy5udW1iZXJTdGFydCB8fCAvW1xcZFxcLl0vLFxuICAgICAgbnVtYmVyID0gcGFyc2VyQ29uZmlnLm51bWJlciB8fCAvXig/OjB4W2EtZlxcZF0rfDBiWzAxXSt8KD86XFxkK1xcLj9cXGQqfFxcLlxcZCspKD86ZVstK10/XFxkKyk/KSh1fGxsP3xsfGYpPy9pLFxuICAgICAgaXNPcGVyYXRvckNoYXIgPSBwYXJzZXJDb25maWcuaXNPcGVyYXRvckNoYXIgfHwgL1srXFwtKiYlPTw+IT98XFwvXS8sXG4gICAgICBpc0lkZW50aWZpZXJDaGFyID0gcGFyc2VyQ29uZmlnLmlzSWRlbnRpZmllckNoYXIgfHwgL1tcXHdcXCRfXFx4YTEtXFx1ZmZmZl0vLFxuICAgICAgLy8gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHtzdHJpbmd9IHRva2VuIGFuZCByZXR1cm5zIHRydWUgaWYgaXRcbiAgICAgIC8vIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgYnVpbHRpbi5cbiAgICAgIGlzUmVzZXJ2ZWRJZGVudGlmaWVyID0gcGFyc2VyQ29uZmlnLmlzUmVzZXJ2ZWRJZGVudGlmaWVyIHx8IGZhbHNlO1xuXG4gIHZhciBjdXJQdW5jLCBpc0RlZktleXdvcmQ7XG5cbiAgZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgIGlmIChob29rc1tjaF0pIHtcbiAgICAgIHZhciByZXN1bHQgPSBob29rc1tjaF0oc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBpZiAocmVzdWx0ICE9PSBmYWxzZSkgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKGNoID09ICdcIicgfHwgY2ggPT0gXCInXCIpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmcoY2gpO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgICBpZiAobnVtYmVyU3RhcnQudGVzdChjaCkpIHtcbiAgICAgIHN0cmVhbS5iYWNrVXAoMSlcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2gobnVtYmVyKSkgcmV0dXJuIFwibnVtYmVyXCJcbiAgICAgIHN0cmVhbS5uZXh0KClcbiAgICB9XG4gICAgaWYgKGlzUHVuY3R1YXRpb25DaGFyLnRlc3QoY2gpKSB7XG4gICAgICBjdXJQdW5jID0gY2g7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGNoID09IFwiL1wiKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNvbW1lbnQ7XG4gICAgICAgIHJldHVybiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIi9cIikpIHtcbiAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc09wZXJhdG9yQ2hhci50ZXN0KGNoKSkge1xuICAgICAgd2hpbGUgKCFzdHJlYW0ubWF0Y2goL15cXC9bXFwvKl0vLCBmYWxzZSkgJiYgc3RyZWFtLmVhdChpc09wZXJhdG9yQ2hhcikpIHt9XG4gICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgIH1cbiAgICBzdHJlYW0uZWF0V2hpbGUoaXNJZGVudGlmaWVyQ2hhcik7XG4gICAgaWYgKG5hbWVzcGFjZVNlcGFyYXRvcikgd2hpbGUgKHN0cmVhbS5tYXRjaChuYW1lc3BhY2VTZXBhcmF0b3IpKVxuICAgICAgc3RyZWFtLmVhdFdoaWxlKGlzSWRlbnRpZmllckNoYXIpO1xuXG4gICAgdmFyIGN1ciA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgaWYgKGNvbnRhaW5zKGtleXdvcmRzLCBjdXIpKSB7XG4gICAgICBpZiAoY29udGFpbnMoYmxvY2tLZXl3b3JkcywgY3VyKSkgY3VyUHVuYyA9IFwibmV3c3RhdGVtZW50XCI7XG4gICAgICBpZiAoY29udGFpbnMoZGVmS2V5d29yZHMsIGN1cikpIGlzRGVmS2V5d29yZCA9IHRydWU7XG4gICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgfVxuICAgIGlmIChjb250YWlucyh0eXBlcywgY3VyKSkgcmV0dXJuIFwidHlwZVwiO1xuICAgIGlmIChjb250YWlucyhidWlsdGluLCBjdXIpXG4gICAgICAgIHx8IChpc1Jlc2VydmVkSWRlbnRpZmllciAmJiBpc1Jlc2VydmVkSWRlbnRpZmllcihjdXIpKSkge1xuICAgICAgaWYgKGNvbnRhaW5zKGJsb2NrS2V5d29yZHMsIGN1cikpIGN1clB1bmMgPSBcIm5ld3N0YXRlbWVudFwiO1xuICAgICAgcmV0dXJuIFwiYnVpbHRpblwiO1xuICAgIH1cbiAgICBpZiAoY29udGFpbnMoYXRvbXMsIGN1cikpIHJldHVybiBcImF0b21cIjtcbiAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5TdHJpbmcocXVvdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgbmV4dCwgZW5kID0gZmFsc2U7XG4gICAgICB3aGlsZSAoKG5leHQgPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChuZXh0ID09IHF1b3RlICYmICFlc2NhcGVkKSB7ZW5kID0gdHJ1ZTsgYnJlYWs7fVxuICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIjtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgfHwgIShlc2NhcGVkIHx8IG11bHRpTGluZVN0cmluZ3MpKVxuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgbWF5YmVFbmQgPSBmYWxzZSwgY2g7XG4gICAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgICAgaWYgKGNoID09IFwiL1wiICYmIG1heWJlRW5kKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBtYXliZUVuZCA9IChjaCA9PSBcIipcIik7XG4gICAgfVxuICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlRU9MKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAocGFyc2VyQ29uZmlnLnR5cGVGaXJzdERlZmluaXRpb25zICYmIHN0cmVhbS5lb2woKSAmJiBpc1RvcFNjb3BlKHN0YXRlLmNvbnRleHQpKVxuICAgICAgc3RhdGUudHlwZUF0RW5kT2ZMaW5lID0gdHlwZUJlZm9yZShzdHJlYW0sIHN0YXRlLCBzdHJlYW0ucG9zKVxuICB9XG5cbiAgLy8gSW50ZXJmYWNlXG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbihpbmRlbnRVbml0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbml6ZTogbnVsbCxcbiAgICAgICAgY29udGV4dDogbmV3IENvbnRleHQoLWluZGVudFVuaXQsIDAsIFwidG9wXCIsIG51bGwsIGZhbHNlKSxcbiAgICAgICAgaW5kZW50ZWQ6IDAsXG4gICAgICAgIHN0YXJ0T2ZMaW5lOiB0cnVlLFxuICAgICAgICBwcmV2VG9rZW46IG51bGxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgY3R4ID0gc3RhdGUuY29udGV4dDtcbiAgICAgIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgaWYgKGN0eC5hbGlnbiA9PSBudWxsKSBjdHguYWxpZ24gPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcbiAgICAgICAgc3RhdGUuc3RhcnRPZkxpbmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSB7IG1heWJlRU9MKHN0cmVhbSwgc3RhdGUpOyByZXR1cm4gbnVsbDsgfVxuICAgICAgY3VyUHVuYyA9IGlzRGVmS2V5d29yZCA9IG51bGw7XG4gICAgICB2YXIgc3R5bGUgPSAoc3RhdGUudG9rZW5pemUgfHwgdG9rZW5CYXNlKShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIGlmIChzdHlsZSA9PSBcImNvbW1lbnRcIiB8fCBzdHlsZSA9PSBcIm1ldGFcIikgcmV0dXJuIHN0eWxlO1xuICAgICAgaWYgKGN0eC5hbGlnbiA9PSBudWxsKSBjdHguYWxpZ24gPSB0cnVlO1xuXG4gICAgICBpZiAoY3VyUHVuYyA9PSBcIjtcIiB8fCBjdXJQdW5jID09IFwiOlwiIHx8IChjdXJQdW5jID09IFwiLFwiICYmIHN0cmVhbS5tYXRjaCgvXlxccyooPzpcXC9cXC8uKik/JC8sIGZhbHNlKSkpXG4gICAgICAgIHdoaWxlIChzdGF0ZS5jb250ZXh0LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIikgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICBlbHNlIGlmIChjdXJQdW5jID09IFwie1wiKSBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcIn1cIik7XG4gICAgICBlbHNlIGlmIChjdXJQdW5jID09IFwiW1wiKSBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcIl1cIik7XG4gICAgICBlbHNlIGlmIChjdXJQdW5jID09IFwiKFwiKSBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcIilcIik7XG4gICAgICBlbHNlIGlmIChjdXJQdW5jID09IFwifVwiKSB7XG4gICAgICAgIHdoaWxlIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiKSBjdHggPSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgICAgaWYgKGN0eC50eXBlID09IFwifVwiKSBjdHggPSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgICAgd2hpbGUgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIpIGN0eCA9IHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBjdHgudHlwZSkgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICBlbHNlIGlmIChpbmRlbnRTdGF0ZW1lbnRzICYmXG4gICAgICAgICAgICAgICAoKChjdHgudHlwZSA9PSBcIn1cIiB8fCBjdHgudHlwZSA9PSBcInRvcFwiKSAmJiBjdXJQdW5jICE9IFwiO1wiKSB8fFxuICAgICAgICAgICAgICAgIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiICYmIGN1clB1bmMgPT0gXCJuZXdzdGF0ZW1lbnRcIikpKSB7XG4gICAgICAgIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwic3RhdGVtZW50XCIsIHN0cmVhbS5jdXJyZW50KCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3R5bGUgPT0gXCJ2YXJpYWJsZVwiICYmXG4gICAgICAgICAgKChzdGF0ZS5wcmV2VG9rZW4gPT0gXCJkZWZcIiB8fFxuICAgICAgICAgICAgKHBhcnNlckNvbmZpZy50eXBlRmlyc3REZWZpbml0aW9ucyAmJiB0eXBlQmVmb3JlKHN0cmVhbSwgc3RhdGUsIHN0cmVhbS5zdGFydCkgJiZcbiAgICAgICAgICAgICBpc1RvcFNjb3BlKHN0YXRlLmNvbnRleHQpICYmIHN0cmVhbS5tYXRjaCgvXlxccypcXCgvLCBmYWxzZSkpKSkpXG4gICAgICAgIHN0eWxlID0gXCJkZWZcIjtcblxuICAgICAgaWYgKGhvb2tzLnRva2VuKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBob29rcy50b2tlbihzdHJlYW0sIHN0YXRlLCBzdHlsZSk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkgc3R5bGUgPSByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZSA9PSBcImRlZlwiICYmIHBhcnNlckNvbmZpZy5zdHlsZURlZnMgPT09IGZhbHNlKSBzdHlsZSA9IFwidmFyaWFibGVcIjtcblxuICAgICAgc3RhdGUuc3RhcnRPZkxpbmUgPSBmYWxzZTtcbiAgICAgIHN0YXRlLnByZXZUb2tlbiA9IGlzRGVmS2V5d29yZCA/IFwiZGVmXCIgOiBzdHlsZSB8fCBjdXJQdW5jO1xuICAgICAgbWF5YmVFT0woc3RyZWFtLCBzdGF0ZSk7XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfSxcblxuICAgIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIHRleHRBZnRlciwgY29udGV4dCkge1xuICAgICAgaWYgKHN0YXRlLnRva2VuaXplICE9IHRva2VuQmFzZSAmJiBzdGF0ZS50b2tlbml6ZSAhPSBudWxsIHx8IHN0YXRlLnR5cGVBdEVuZE9mTGluZSkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgY3R4ID0gc3RhdGUuY29udGV4dCwgZmlyc3RDaGFyID0gdGV4dEFmdGVyICYmIHRleHRBZnRlci5jaGFyQXQoMCk7XG4gICAgICB2YXIgY2xvc2luZyA9IGZpcnN0Q2hhciA9PSBjdHgudHlwZTtcbiAgICAgIGlmIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiICYmIGZpcnN0Q2hhciA9PSBcIn1cIikgY3R4ID0gY3R4LnByZXY7XG4gICAgICBpZiAocGFyc2VyQ29uZmlnLmRvbnRJbmRlbnRTdGF0ZW1lbnRzKVxuICAgICAgICB3aGlsZSAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIiAmJiBwYXJzZXJDb25maWcuZG9udEluZGVudFN0YXRlbWVudHMudGVzdChjdHguaW5mbykpXG4gICAgICAgICAgY3R4ID0gY3R4LnByZXZcbiAgICAgIGlmIChob29rcy5pbmRlbnQpIHtcbiAgICAgICAgdmFyIGhvb2sgPSBob29rcy5pbmRlbnQoc3RhdGUsIGN0eCwgdGV4dEFmdGVyLCBjb250ZXh0LnVuaXQpO1xuICAgICAgICBpZiAodHlwZW9mIGhvb2sgPT0gXCJudW1iZXJcIikgcmV0dXJuIGhvb2tcbiAgICAgIH1cbiAgICAgIHZhciBzd2l0Y2hCbG9jayA9IGN0eC5wcmV2ICYmIGN0eC5wcmV2LmluZm8gPT0gXCJzd2l0Y2hcIjtcbiAgICAgIGlmIChwYXJzZXJDb25maWcuYWxsbWFuSW5kZW50YXRpb24gJiYgL1t7KF0vLnRlc3QoZmlyc3RDaGFyKSkge1xuICAgICAgICB3aGlsZSAoY3R4LnR5cGUgIT0gXCJ0b3BcIiAmJiBjdHgudHlwZSAhPSBcIn1cIikgY3R4ID0gY3R4LnByZXZcbiAgICAgICAgcmV0dXJuIGN0eC5pbmRlbnRlZFxuICAgICAgfVxuICAgICAgaWYgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIpXG4gICAgICAgIHJldHVybiBjdHguaW5kZW50ZWQgKyAoZmlyc3RDaGFyID09IFwie1wiID8gMCA6IHN0YXRlbWVudEluZGVudFVuaXQgfHwgY29udGV4dC51bml0KTtcbiAgICAgIGlmIChjdHguYWxpZ24gJiYgKCFkb250QWxpZ25DYWxscyB8fCBjdHgudHlwZSAhPSBcIilcIikpXG4gICAgICAgIHJldHVybiBjdHguY29sdW1uICsgKGNsb3NpbmcgPyAwIDogMSk7XG4gICAgICBpZiAoY3R4LnR5cGUgPT0gXCIpXCIgJiYgIWNsb3NpbmcpXG4gICAgICAgIHJldHVybiBjdHguaW5kZW50ZWQgKyAoc3RhdGVtZW50SW5kZW50VW5pdCB8fCBjb250ZXh0LnVuaXQpO1xuXG4gICAgICByZXR1cm4gY3R4LmluZGVudGVkICsgKGNsb3NpbmcgPyAwIDogY29udGV4dC51bml0KSArXG4gICAgICAgICghY2xvc2luZyAmJiBzd2l0Y2hCbG9jayAmJiAhL14oPzpjYXNlfGRlZmF1bHQpXFxiLy50ZXN0KHRleHRBZnRlcikgPyBjb250ZXh0LnVuaXQgOiAwKTtcbiAgICB9LFxuXG4gICAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgICBpbmRlbnRPbklucHV0OiBpbmRlbnRTd2l0Y2ggPyAvXlxccyooPzpjYXNlIC4qPzp8ZGVmYXVsdDp8XFx7XFx9P3xcXH0pJC8gOiAvXlxccypbe31dJC8sXG4gICAgICBjb21tZW50VG9rZW5zOiB7bGluZTogXCIvL1wiLCBibG9jazoge29wZW46IFwiLypcIiwgY2xvc2U6IFwiKi9cIn19LFxuICAgICAgYXV0b2NvbXBsZXRlOiBPYmplY3Qua2V5cyhrZXl3b3JkcykuY29uY2F0KE9iamVjdC5rZXlzKHR5cGVzKSkuY29uY2F0KE9iamVjdC5rZXlzKGJ1aWx0aW4pKS5jb25jYXQoT2JqZWN0LmtleXMoYXRvbXMpKSxcbiAgICAgIC4uLnBhcnNlckNvbmZpZy5sYW5ndWFnZURhdGFcbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiB3b3JkcyhzdHIpIHtcbiAgdmFyIG9iaiA9IHt9LCB3b3JkcyA9IHN0ci5zcGxpdChcIiBcIik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIG9ialt3b3Jkc1tpXV0gPSB0cnVlO1xuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gY29udGFpbnMod29yZHMsIHdvcmQpIHtcbiAgaWYgKHR5cGVvZiB3b3JkcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHdvcmRzKHdvcmQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZSh3b3JkKTtcbiAgfVxufVxudmFyIGNLZXl3b3JkcyA9IFwiYXV0byBpZiBicmVhayBjYXNlIHJlZ2lzdGVyIGNvbnRpbnVlIHJldHVybiBkZWZhdWx0IGRvIHNpemVvZiBcIiArXG4gICAgXCJzdGF0aWMgZWxzZSBzdHJ1Y3Qgc3dpdGNoIGV4dGVybiB0eXBlZGVmIHVuaW9uIGZvciBnb3RvIHdoaWxlIGVudW0gY29uc3QgXCIgK1xuICAgIFwidm9sYXRpbGUgaW5saW5lIHJlc3RyaWN0IGFzbSBmb3J0cmFuXCI7XG5cbi8vIEtleXdvcmRzIGZyb20gaHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2tleXdvcmQgaW5jbHVkZXMgQysrMjAuXG52YXIgY3BwS2V5d29yZHMgPSBcImFsaWduYXMgYWxpZ25vZiBhbmQgYW5kX2VxIGF1ZGl0IGF4aW9tIGJpdGFuZCBiaXRvciBjYXRjaCBcIiArXG4gICAgXCJjbGFzcyBjb21wbCBjb25jZXB0IGNvbnN0ZXhwciBjb25zdF9jYXN0IGRlY2x0eXBlIGRlbGV0ZSBkeW5hbWljX2Nhc3QgXCIgK1xuICAgIFwiZXhwbGljaXQgZXhwb3J0IGZpbmFsIGZyaWVuZCBpbXBvcnQgbW9kdWxlIG11dGFibGUgbmFtZXNwYWNlIG5ldyBub2V4Y2VwdCBcIiArXG4gICAgXCJub3Qgbm90X2VxIG9wZXJhdG9yIG9yIG9yX2VxIG92ZXJyaWRlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBcIiArXG4gICAgXCJyZWludGVycHJldF9jYXN0IHJlcXVpcmVzIHN0YXRpY19hc3NlcnQgc3RhdGljX2Nhc3QgdGVtcGxhdGUgdGhpcyBcIiArXG4gICAgXCJ0aHJlYWRfbG9jYWwgdGhyb3cgdHJ5IHR5cGVpZCB0eXBlbmFtZSB1c2luZyB2aXJ0dWFsIHhvciB4b3JfZXFcIjtcblxudmFyIG9iakNLZXl3b3JkcyA9IFwiYnljb3B5IGJ5cmVmIGluIGlub3V0IG9uZXdheSBvdXQgc2VsZiBzdXBlciBhdG9taWMgbm9uYXRvbWljIHJldGFpbiBjb3B5IFwiICtcbiAgICBcInJlYWR3cml0ZSByZWFkb25seSBzdHJvbmcgd2VhayBhc3NpZ24gdHlwZW9mIG51bGxhYmxlIG5vbm51bGwgbnVsbF9yZXNldHRhYmxlIF9jbWQgXCIgK1xuICAgIFwiQGludGVyZmFjZSBAaW1wbGVtZW50YXRpb24gQGVuZCBAcHJvdG9jb2wgQGVuY29kZSBAcHJvcGVydHkgQHN5bnRoZXNpemUgQGR5bmFtaWMgQGNsYXNzIFwiICtcbiAgICBcIkBwdWJsaWMgQHBhY2thZ2UgQHByaXZhdGUgQHByb3RlY3RlZCBAcmVxdWlyZWQgQG9wdGlvbmFsIEB0cnkgQGNhdGNoIEBmaW5hbGx5IEBpbXBvcnQgXCIgK1xuICAgIFwiQHNlbGVjdG9yIEBlbmNvZGUgQGRlZnMgQHN5bmNocm9uaXplZCBAYXV0b3JlbGVhc2Vwb29sIEBjb21wYXRpYmlsaXR5X2FsaWFzIEBhdmFpbGFibGVcIjtcblxudmFyIG9iakNCdWlsdGlucyA9IFwiRk9VTkRBVElPTl9FWFBPUlQgRk9VTkRBVElPTl9FWFRFUk4gTlNfSU5MSU5FIE5TX0ZPUk1BVF9GVU5DVElPTiBcIiArXG4gICAgXCIgTlNfUkVUVVJOU19SRVRBSU5FRE5TX0VSUk9SX0VOVU0gTlNfUkVUVVJOU19OT1RfUkVUQUlORUQgTlNfUkVUVVJOU19JTk5FUl9QT0lOVEVSIFwiICtcbiAgICBcIk5TX0RFU0lHTkFURURfSU5JVElBTElaRVIgTlNfRU5VTSBOU19PUFRJT05TIE5TX1JFUVVJUkVTX05JTF9URVJNSU5BVElPTiBcIiArXG4gICAgXCJOU19BU1NVTUVfTk9OTlVMTF9CRUdJTiBOU19BU1NVTUVfTk9OTlVMTF9FTkQgTlNfU1dJRlRfTkFNRSBOU19SRUZJTkVEX0ZPUl9TV0lGVFwiXG5cbi8vIERvIG5vdCB1c2UgdGhpcy4gVXNlIHRoZSBjVHlwZXMgZnVuY3Rpb24gYmVsb3cuIFRoaXMgaXMgZ2xvYmFsIGp1c3QgdG8gYXZvaWRcbi8vIGV4Y2Vzc2l2ZSBjYWxscyB3aGVuIGNUeXBlcyBpcyBiZWluZyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIGEgcGFyc2UuXG52YXIgYmFzaWNDVHlwZXMgPSB3b3JkcyhcImludCBsb25nIGNoYXIgc2hvcnQgZG91YmxlIGZsb2F0IHVuc2lnbmVkIHNpZ25lZCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcInZvaWQgYm9vbFwiKTtcblxuLy8gRG8gbm90IHVzZSB0aGlzLiBVc2UgdGhlIG9iakNUeXBlcyBmdW5jdGlvbiBiZWxvdy4gVGhpcyBpcyBnbG9iYWwganVzdCB0byBhdm9pZFxuLy8gZXhjZXNzaXZlIGNhbGxzIHdoZW4gb2JqQ1R5cGVzIGlzIGJlaW5nIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBkdXJpbmcgYSBwYXJzZS5cbnZhciBiYXNpY09iakNUeXBlcyA9IHdvcmRzKFwiU0VMIGluc3RhbmNldHlwZSBpZCBDbGFzcyBQcm90b2NvbCBCT09MXCIpO1xuXG4vLyBSZXR1cm5zIHRydWUgaWYgaWRlbnRpZmllciBpcyBhIFwiQ1wiIHR5cGUuXG4vLyBDIHR5cGUgaXMgZGVmaW5lZCBhcyB0aG9zZSB0aGF0IGFyZSByZXNlcnZlZCBieSB0aGUgY29tcGlsZXIgKGJhc2ljVHlwZXMpLFxuLy8gYW5kIHRob3NlIHRoYXQgZW5kIGluIF90IChSZXNlcnZlZCBieSBQT1NJWCBmb3IgdHlwZXMpXG4vLyBodHRwOi8vd3d3LmdudS5vcmcvc29mdHdhcmUvbGliYy9tYW51YWwvaHRtbF9ub2RlL1Jlc2VydmVkLU5hbWVzLmh0bWxcbmZ1bmN0aW9uIGNUeXBlcyhpZGVudGlmaWVyKSB7XG4gIHJldHVybiBjb250YWlucyhiYXNpY0NUeXBlcywgaWRlbnRpZmllcikgfHwgLy4rX3QkLy50ZXN0KGlkZW50aWZpZXIpO1xufVxuXG4vLyBSZXR1cm5zIHRydWUgaWYgaWRlbnRpZmllciBpcyBhIFwiT2JqZWN0aXZlIENcIiB0eXBlLlxuZnVuY3Rpb24gb2JqQ1R5cGVzKGlkZW50aWZpZXIpIHtcbiAgcmV0dXJuIGNUeXBlcyhpZGVudGlmaWVyKSB8fCBjb250YWlucyhiYXNpY09iakNUeXBlcywgaWRlbnRpZmllcik7XG59XG5cbnZhciBjQmxvY2tLZXl3b3JkcyA9IFwiY2FzZSBkbyBlbHNlIGZvciBpZiBzd2l0Y2ggd2hpbGUgc3RydWN0IGVudW0gdW5pb25cIjtcbnZhciBjRGVmS2V5d29yZHMgPSBcInN0cnVjdCBlbnVtIHVuaW9uXCI7XG5cbmZ1bmN0aW9uIGNwcEhvb2soc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnN0YXJ0T2ZMaW5lKSByZXR1cm4gZmFsc2VcbiAgZm9yICh2YXIgY2gsIG5leHQgPSBudWxsOyBjaCA9IHN0cmVhbS5wZWVrKCk7KSB7XG4gICAgaWYgKGNoID09IFwiXFxcXFwiICYmIHN0cmVhbS5tYXRjaCgvXi4kLykpIHtcbiAgICAgIG5leHQgPSBjcHBIb29rXG4gICAgICBicmVha1xuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIvXCIgJiYgc3RyZWFtLm1hdGNoKC9eXFwvW1xcL1xcKl0vLCBmYWxzZSkpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIHN0cmVhbS5uZXh0KClcbiAgfVxuICBzdGF0ZS50b2tlbml6ZSA9IG5leHRcbiAgcmV0dXJuIFwibWV0YVwiXG59XG5cbmZ1bmN0aW9uIHBvaW50ZXJIb29rKF9zdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5wcmV2VG9rZW4gPT0gXCJ0eXBlXCIpIHJldHVybiBcInR5cGVcIjtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBGb3IgQyBhbmQgQysrIChhbmQgT2JqQyk6IGlkZW50aWZpZXJzIHN0YXJ0aW5nIHdpdGggX19cbi8vIG9yIF8gZm9sbG93ZWQgYnkgYSBjYXBpdGFsIGxldHRlciBhcmUgcmVzZXJ2ZWQgZm9yIHRoZSBjb21waWxlci5cbmZ1bmN0aW9uIGNJc1Jlc2VydmVkSWRlbnRpZmllcih0b2tlbikge1xuICBpZiAoIXRva2VuIHx8IHRva2VuLmxlbmd0aCA8IDIpIHJldHVybiBmYWxzZTtcbiAgaWYgKHRva2VuWzBdICE9ICdfJykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gKHRva2VuWzFdID09ICdfJykgfHwgKHRva2VuWzFdICE9PSB0b2tlblsxXS50b0xvd2VyQ2FzZSgpKTtcbn1cblxuZnVuY3Rpb24gY3BwMTRMaXRlcmFsKHN0cmVhbSkge1xuICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXC4nXS8pO1xuICByZXR1cm4gXCJudW1iZXJcIjtcbn1cblxuZnVuY3Rpb24gY3BwMTFTdHJpbmdIb29rKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLmJhY2tVcCgxKTtcbiAgLy8gUmF3IHN0cmluZ3MuXG4gIGlmIChzdHJlYW0ubWF0Y2goL14oPzpSfHU4Unx1UnxVUnxMUikvKSkge1xuICAgIHZhciBtYXRjaCA9IHN0cmVhbS5tYXRjaCgvXlwiKFteXFxzXFxcXCgpXXswLDE2fSlcXCgvKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN0YXRlLmNwcDExUmF3U3RyaW5nRGVsaW0gPSBtYXRjaFsxXTtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuUmF3U3RyaW5nO1xuICAgIHJldHVybiB0b2tlblJhd1N0cmluZyhzdHJlYW0sIHN0YXRlKTtcbiAgfVxuICAvLyBVbmljb2RlIHN0cmluZ3MvY2hhcnMuXG4gIGlmIChzdHJlYW0ubWF0Y2goL14oPzp1OHx1fFV8TCkvKSkge1xuICAgIGlmIChzdHJlYW0ubWF0Y2goL15bXCInXS8sIC8qIGVhdCAqLyBmYWxzZSkpIHtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gSWdub3JlIHRoaXMgaG9vay5cbiAgc3RyZWFtLm5leHQoKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjcHBMb29rc0xpa2VDb25zdHJ1Y3Rvcih3b3JkKSB7XG4gIHZhciBsYXN0VHdvID0gLyhcXHcrKTo6fj8oXFx3KykkLy5leGVjKHdvcmQpO1xuICByZXR1cm4gbGFzdFR3byAmJiBsYXN0VHdvWzFdID09IGxhc3RUd29bMl07XG59XG5cbi8vIEMjLXN0eWxlIHN0cmluZ3Mgd2hlcmUgXCJcIiBlc2NhcGVzIGEgcXVvdGUuXG5mdW5jdGlvbiB0b2tlbkF0U3RyaW5nKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5leHQ7XG4gIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICBpZiAobmV4dCA9PSAnXCInICYmICFzdHJlYW0uZWF0KCdcIicpKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFwic3RyaW5nXCI7XG59XG5cbi8vIEMrKzExIHJhdyBzdHJpbmcgbGl0ZXJhbCBpcyA8cHJlZml4PlwiPGRlbGltPiggYW55dGhpbmcgKTxkZWxpbT5cIiwgd2hlcmVcbi8vIDxkZWxpbT4gY2FuIGJlIGEgc3RyaW5nIHVwIHRvIDE2IGNoYXJhY3RlcnMgbG9uZy5cbmZ1bmN0aW9uIHRva2VuUmF3U3RyaW5nKHN0cmVhbSwgc3RhdGUpIHtcbiAgLy8gRXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIHNwZWNpYWwgcmVnZXggbWVhbmluZ3MuXG4gIHZhciBkZWxpbSA9IHN0YXRlLmNwcDExUmF3U3RyaW5nRGVsaW0ucmVwbGFjZSgvW15cXHdcXHNdL2csICdcXFxcJCYnKTtcbiAgdmFyIG1hdGNoID0gc3RyZWFtLm1hdGNoKG5ldyBSZWdFeHAoXCIuKj9cXFxcKVwiICsgZGVsaW0gKyAnXCInKSk7XG4gIGlmIChtYXRjaClcbiAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gIGVsc2VcbiAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gIHJldHVybiBcInN0cmluZ1wiO1xufVxuXG5leHBvcnQgY29uc3QgYyA9IGNsaWtlKHtcbiAga2V5d29yZHM6IHdvcmRzKGNLZXl3b3JkcyksXG4gIHR5cGVzOiBjVHlwZXMsXG4gIGJsb2NrS2V5d29yZHM6IHdvcmRzKGNCbG9ja0tleXdvcmRzKSxcbiAgZGVmS2V5d29yZHM6IHdvcmRzKGNEZWZLZXl3b3JkcyksXG4gIHR5cGVGaXJzdERlZmluaXRpb25zOiB0cnVlLFxuICBhdG9tczogd29yZHMoXCJOVUxMIHRydWUgZmFsc2VcIiksXG4gIGlzUmVzZXJ2ZWRJZGVudGlmaWVyOiBjSXNSZXNlcnZlZElkZW50aWZpZXIsXG4gIGhvb2tzOiB7XG4gICAgXCIjXCI6IGNwcEhvb2ssXG4gICAgXCIqXCI6IHBvaW50ZXJIb29rLFxuICB9XG59KVxuXG5leHBvcnQgY29uc3QgY3BwID0gY2xpa2Uoe1xuICBrZXl3b3Jkczogd29yZHMoY0tleXdvcmRzICsgXCIgXCIgKyBjcHBLZXl3b3JkcyksXG4gIHR5cGVzOiBjVHlwZXMsXG4gIGJsb2NrS2V5d29yZHM6IHdvcmRzKGNCbG9ja0tleXdvcmRzICsgXCIgY2xhc3MgdHJ5IGNhdGNoXCIpLFxuICBkZWZLZXl3b3Jkczogd29yZHMoY0RlZktleXdvcmRzICsgXCIgY2xhc3MgbmFtZXNwYWNlXCIpLFxuICB0eXBlRmlyc3REZWZpbml0aW9uczogdHJ1ZSxcbiAgYXRvbXM6IHdvcmRzKFwidHJ1ZSBmYWxzZSBOVUxMIG51bGxwdHJcIiksXG4gIGRvbnRJbmRlbnRTdGF0ZW1lbnRzOiAvXnRlbXBsYXRlJC8sXG4gIGlzSWRlbnRpZmllckNoYXI6IC9bXFx3XFwkX35cXHhhMS1cXHVmZmZmXS8sXG4gIGlzUmVzZXJ2ZWRJZGVudGlmaWVyOiBjSXNSZXNlcnZlZElkZW50aWZpZXIsXG4gIGhvb2tzOiB7XG4gICAgXCIjXCI6IGNwcEhvb2ssXG4gICAgXCIqXCI6IHBvaW50ZXJIb29rLFxuICAgIFwidVwiOiBjcHAxMVN0cmluZ0hvb2ssXG4gICAgXCJVXCI6IGNwcDExU3RyaW5nSG9vayxcbiAgICBcIkxcIjogY3BwMTFTdHJpbmdIb29rLFxuICAgIFwiUlwiOiBjcHAxMVN0cmluZ0hvb2ssXG4gICAgXCIwXCI6IGNwcDE0TGl0ZXJhbCxcbiAgICBcIjFcIjogY3BwMTRMaXRlcmFsLFxuICAgIFwiMlwiOiBjcHAxNExpdGVyYWwsXG4gICAgXCIzXCI6IGNwcDE0TGl0ZXJhbCxcbiAgICBcIjRcIjogY3BwMTRMaXRlcmFsLFxuICAgIFwiNVwiOiBjcHAxNExpdGVyYWwsXG4gICAgXCI2XCI6IGNwcDE0TGl0ZXJhbCxcbiAgICBcIjdcIjogY3BwMTRMaXRlcmFsLFxuICAgIFwiOFwiOiBjcHAxNExpdGVyYWwsXG4gICAgXCI5XCI6IGNwcDE0TGl0ZXJhbCxcbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSwgc3R5bGUpIHtcbiAgICAgIGlmIChzdHlsZSA9PSBcInZhcmlhYmxlXCIgJiYgc3RyZWFtLnBlZWsoKSA9PSBcIihcIiAmJlxuICAgICAgICAgIChzdGF0ZS5wcmV2VG9rZW4gPT0gXCI7XCIgfHwgc3RhdGUucHJldlRva2VuID09IG51bGwgfHxcbiAgICAgICAgICAgc3RhdGUucHJldlRva2VuID09IFwifVwiKSAmJlxuICAgICAgICAgIGNwcExvb2tzTGlrZUNvbnN0cnVjdG9yKHN0cmVhbS5jdXJyZW50KCkpKVxuICAgICAgICByZXR1cm4gXCJkZWZcIjtcbiAgICB9XG4gIH0sXG4gIG5hbWVzcGFjZVNlcGFyYXRvcjogXCI6OlwiXG59KTtcblxuZXhwb3J0IGNvbnN0IGphdmEgPSBjbGlrZSh7XG4gIGtleXdvcmRzOiB3b3JkcyhcImFic3RyYWN0IGFzc2VydCBicmVhayBjYXNlIGNhdGNoIGNsYXNzIGNvbnN0IGNvbnRpbnVlIGRlZmF1bHQgXCIgK1xuICAgICAgICAgICAgICAgICAgXCJkbyBlbHNlIGVudW0gZXh0ZW5kcyBmaW5hbCBmaW5hbGx5IGZvciBnb3RvIGlmIGltcGxlbWVudHMgaW1wb3J0IFwiICtcbiAgICAgICAgICAgICAgICAgIFwiaW5zdGFuY2VvZiBpbnRlcmZhY2UgbmF0aXZlIG5ldyBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBcIiArXG4gICAgICAgICAgICAgICAgICBcInJldHVybiBzdGF0aWMgc3RyaWN0ZnAgc3VwZXIgc3dpdGNoIHN5bmNocm9uaXplZCB0aGlzIHRocm93IHRocm93cyB0cmFuc2llbnQgXCIgK1xuICAgICAgICAgICAgICAgICAgXCJ0cnkgdm9sYXRpbGUgd2hpbGUgQGludGVyZmFjZVwiKSxcbiAgdHlwZXM6IHdvcmRzKFwidmFyIGJ5dGUgc2hvcnQgaW50IGxvbmcgZmxvYXQgZG91YmxlIGJvb2xlYW4gY2hhciB2b2lkIEJvb2xlYW4gQnl0ZSBDaGFyYWN0ZXIgRG91YmxlIEZsb2F0IFwiICtcbiAgICAgICAgICAgICAgIFwiSW50ZWdlciBMb25nIE51bWJlciBPYmplY3QgU2hvcnQgU3RyaW5nIFN0cmluZ0J1ZmZlciBTdHJpbmdCdWlsZGVyIFZvaWRcIiksXG4gIGJsb2NrS2V5d29yZHM6IHdvcmRzKFwiY2F0Y2ggY2xhc3MgZG8gZWxzZSBmaW5hbGx5IGZvciBpZiBzd2l0Y2ggdHJ5IHdoaWxlXCIpLFxuICBkZWZLZXl3b3Jkczogd29yZHMoXCJjbGFzcyBpbnRlcmZhY2UgZW51bSBAaW50ZXJmYWNlXCIpLFxuICB0eXBlRmlyc3REZWZpbml0aW9uczogdHJ1ZSxcbiAgYXRvbXM6IHdvcmRzKFwidHJ1ZSBmYWxzZSBudWxsXCIpLFxuICBudW1iZXI6IC9eKD86MHhbYS1mXFxkX10rfDBiWzAxX10rfCg/OltcXGRfXStcXC4/XFxkKnxcXC5cXGQrKSg/OmVbLStdP1tcXGRfXSspPykodXxsbD98bHxmKT8vaSxcbiAgaG9va3M6IHtcbiAgICBcIkBcIjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAvLyBEb24ndCBtYXRjaCB0aGUgQGludGVyZmFjZSBrZXl3b3JkLlxuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgnaW50ZXJmYWNlJywgZmFsc2UpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9dLyk7XG4gICAgICByZXR1cm4gXCJtZXRhXCI7XG4gICAgfSxcbiAgICAnXCInOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoIXN0cmVhbS5tYXRjaCgvXCJcIiQvKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblRyaXBsZVN0cmluZztcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH1cbn0pXG5cbmV4cG9ydCBjb25zdCBjc2hhcnAgPSBjbGlrZSh7XG4gIGtleXdvcmRzOiB3b3JkcyhcImFic3RyYWN0IGFzIGFzeW5jIGF3YWl0IGJhc2UgYnJlYWsgY2FzZSBjYXRjaCBjaGVja2VkIGNsYXNzIGNvbnN0IGNvbnRpbnVlXCIgK1xuICAgICAgICAgICAgICAgICAgXCIgZGVmYXVsdCBkZWxlZ2F0ZSBkbyBlbHNlIGVudW0gZXZlbnQgZXhwbGljaXQgZXh0ZXJuIGZpbmFsbHkgZml4ZWQgZm9yXCIgK1xuICAgICAgICAgICAgICAgICAgXCIgZm9yZWFjaCBnb3RvIGlmIGltcGxpY2l0IGluIGludGVyZmFjZSBpbnRlcm5hbCBpcyBsb2NrIG5hbWVzcGFjZSBuZXdcIiArXG4gICAgICAgICAgICAgICAgICBcIiBvcGVyYXRvciBvdXQgb3ZlcnJpZGUgcGFyYW1zIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyByZWFkb25seSByZWYgcmV0dXJuIHNlYWxlZFwiICtcbiAgICAgICAgICAgICAgICAgIFwiIHNpemVvZiBzdGFja2FsbG9jIHN0YXRpYyBzdHJ1Y3Qgc3dpdGNoIHRoaXMgdGhyb3cgdHJ5IHR5cGVvZiB1bmNoZWNrZWRcIiArXG4gICAgICAgICAgICAgICAgICBcIiB1bnNhZmUgdXNpbmcgdmlydHVhbCB2b2lkIHZvbGF0aWxlIHdoaWxlIGFkZCBhbGlhcyBhc2NlbmRpbmcgZGVzY2VuZGluZyBkeW5hbWljIGZyb20gZ2V0XCIgK1xuICAgICAgICAgICAgICAgICAgXCIgZ2xvYmFsIGdyb3VwIGludG8gam9pbiBsZXQgb3JkZXJieSBwYXJ0aWFsIHJlbW92ZSBzZWxlY3Qgc2V0IHZhbHVlIHZhciB5aWVsZFwiKSxcbiAgdHlwZXM6IHdvcmRzKFwiQWN0aW9uIEJvb2xlYW4gQnl0ZSBDaGFyIERhdGVUaW1lIERhdGVUaW1lT2Zmc2V0IERlY2ltYWwgRG91YmxlIEZ1bmNcIiArXG4gICAgICAgICAgICAgICBcIiBHdWlkIEludDE2IEludDMyIEludDY0IE9iamVjdCBTQnl0ZSBTaW5nbGUgU3RyaW5nIFRhc2sgVGltZVNwYW4gVUludDE2IFVJbnQzMlwiICtcbiAgICAgICAgICAgICAgIFwiIFVJbnQ2NCBib29sIGJ5dGUgY2hhciBkZWNpbWFsIGRvdWJsZSBzaG9ydCBpbnQgbG9uZyBvYmplY3RcIiAgK1xuICAgICAgICAgICAgICAgXCIgc2J5dGUgZmxvYXQgc3RyaW5nIHVzaG9ydCB1aW50IHVsb25nXCIpLFxuICBibG9ja0tleXdvcmRzOiB3b3JkcyhcImNhdGNoIGNsYXNzIGRvIGVsc2UgZmluYWxseSBmb3IgZm9yZWFjaCBpZiBzdHJ1Y3Qgc3dpdGNoIHRyeSB3aGlsZVwiKSxcbiAgZGVmS2V5d29yZHM6IHdvcmRzKFwiY2xhc3MgaW50ZXJmYWNlIG5hbWVzcGFjZSBzdHJ1Y3QgdmFyXCIpLFxuICB0eXBlRmlyc3REZWZpbml0aW9uczogdHJ1ZSxcbiAgYXRvbXM6IHdvcmRzKFwidHJ1ZSBmYWxzZSBudWxsXCIpLFxuICBob29rczoge1xuICAgIFwiQFwiOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdCgnXCInKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQXRTdHJpbmc7XG4gICAgICAgIHJldHVybiB0b2tlbkF0U3RyaW5nKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfVxuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX10vKTtcbiAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB0b2tlblRyaXBsZVN0cmluZyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBlc2NhcGVkID0gZmFsc2U7XG4gIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgaWYgKCFlc2NhcGVkICYmIHN0cmVhbS5tYXRjaCgnXCJcIlwiJykpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBlc2NhcGVkID0gc3RyZWFtLm5leHQoKSA9PSBcIlxcXFxcIiAmJiAhZXNjYXBlZDtcbiAgfVxuICByZXR1cm4gXCJzdHJpbmdcIjtcbn1cblxuZnVuY3Rpb24gdG9rZW5OZXN0ZWRDb21tZW50KGRlcHRoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaFxuICAgIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICAgIGlmIChjaCA9PSBcIipcIiAmJiBzdHJlYW0uZWF0KFwiL1wiKSkge1xuICAgICAgICBpZiAoZGVwdGggPT0gMSkge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbk5lc3RlZENvbW1lbnQoZGVwdGggLSAxKVxuICAgICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoID09IFwiL1wiICYmIHN0cmVhbS5lYXQoXCIqXCIpKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5OZXN0ZWRDb21tZW50KGRlcHRoICsgMSlcbiAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcImNvbW1lbnRcIlxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzY2FsYSA9IGNsaWtlKHtcbiAga2V5d29yZHM6IHdvcmRzKFxuICAgIC8qIHNjYWxhICovXG4gICAgXCJhYnN0cmFjdCBjYXNlIGNhdGNoIGNsYXNzIGRlZiBkbyBlbHNlIGV4dGVuZHMgZmluYWwgZmluYWxseSBmb3IgZm9yU29tZSBpZiBcIiArXG4gICAgICBcImltcGxpY2l0IGltcG9ydCBsYXp5IG1hdGNoIG5ldyBudWxsIG9iamVjdCBvdmVycmlkZSBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHJldHVybiBcIiArXG4gICAgICBcInNlYWxlZCBzdXBlciB0aGlzIHRocm93IHRyYWl0IHRyeSB0eXBlIHZhbCB2YXIgd2hpbGUgd2l0aCB5aWVsZCBfIFwiICtcblxuICAgIC8qIHBhY2thZ2Ugc2NhbGEgKi9cbiAgICBcImFzc2VydCBhc3N1bWUgcmVxdWlyZSBwcmludCBwcmludGxuIHByaW50ZiByZWFkTGluZSByZWFkQm9vbGVhbiByZWFkQnl0ZSByZWFkU2hvcnQgXCIgK1xuICAgICAgXCJyZWFkQ2hhciByZWFkSW50IHJlYWRMb25nIHJlYWRGbG9hdCByZWFkRG91YmxlXCJcbiAgKSxcbiAgdHlwZXM6IHdvcmRzKFxuICAgIFwiQW55VmFsIEFwcCBBcHBsaWNhdGlvbiBBcnJheSBCdWZmZXJlZEl0ZXJhdG9yIEJpZ0RlY2ltYWwgQmlnSW50IENoYXIgQ29uc29sZSBFaXRoZXIgXCIgK1xuICAgICAgXCJFbnVtZXJhdGlvbiBFcXVpdiBFcnJvciBFeGNlcHRpb24gRnJhY3Rpb25hbCBGdW5jdGlvbiBJbmRleGVkU2VxIEludCBJbnRlZ3JhbCBJdGVyYWJsZSBcIiArXG4gICAgICBcIkl0ZXJhdG9yIExpc3QgTWFwIE51bWVyaWMgTmlsIE5vdE51bGwgT3B0aW9uIE9yZGVyZWQgT3JkZXJpbmcgUGFydGlhbEZ1bmN0aW9uIFBhcnRpYWxPcmRlcmluZyBcIiArXG4gICAgICBcIlByb2R1Y3QgUHJveHkgUmFuZ2UgUmVzcG9uZGVyIFNlcSBTZXJpYWxpemFibGUgU2V0IFNwZWNpYWxpemFibGUgU3RyZWFtIFN0cmluZ0J1aWxkZXIgXCIgK1xuICAgICAgXCJTdHJpbmdDb250ZXh0IFN5bWJvbCBUaHJvd2FibGUgVHJhdmVyc2FibGUgVHJhdmVyc2FibGVPbmNlIFR1cGxlIFVuaXQgVmVjdG9yIFwiICtcblxuICAgIC8qIHBhY2thZ2UgamF2YS5sYW5nICovXG4gICAgXCJCb29sZWFuIEJ5dGUgQ2hhcmFjdGVyIENoYXJTZXF1ZW5jZSBDbGFzcyBDbGFzc0xvYWRlciBDbG9uZWFibGUgQ29tcGFyYWJsZSBcIiArXG4gICAgICBcIkNvbXBpbGVyIERvdWJsZSBFeGNlcHRpb24gRmxvYXQgSW50ZWdlciBMb25nIE1hdGggTnVtYmVyIE9iamVjdCBQYWNrYWdlIFBhaXIgUHJvY2VzcyBcIiArXG4gICAgICBcIlJ1bnRpbWUgUnVubmFibGUgU2VjdXJpdHlNYW5hZ2VyIFNob3J0IFN0YWNrVHJhY2VFbGVtZW50IFN0cmljdE1hdGggU3RyaW5nIFwiICtcbiAgICAgIFwiU3RyaW5nQnVmZmVyIFN5c3RlbSBUaHJlYWQgVGhyZWFkR3JvdXAgVGhyZWFkTG9jYWwgVGhyb3dhYmxlIFRyaXBsZSBWb2lkXCJcbiAgKSxcbiAgbXVsdGlMaW5lU3RyaW5nczogdHJ1ZSxcbiAgYmxvY2tLZXl3b3Jkczogd29yZHMoXCJjYXRjaCBjbGFzcyBlbnVtIGRvIGVsc2UgZmluYWxseSBmb3IgZm9yU29tZSBpZiBtYXRjaCBzd2l0Y2ggdHJ5IHdoaWxlXCIpLFxuICBkZWZLZXl3b3Jkczogd29yZHMoXCJjbGFzcyBlbnVtIGRlZiBvYmplY3QgcGFja2FnZSB0cmFpdCB0eXBlIHZhbCB2YXJcIiksXG4gIGF0b21zOiB3b3JkcyhcInRydWUgZmFsc2UgbnVsbFwiKSxcbiAgaW5kZW50U3RhdGVtZW50czogZmFsc2UsXG4gIGluZGVudFN3aXRjaDogZmFsc2UsXG4gIGlzT3BlcmF0b3JDaGFyOiAvWytcXC0qJiU9PD4hP3xcXC8jOkBdLyxcbiAgaG9va3M6IHtcbiAgICBcIkBcIjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXS8pO1xuICAgICAgcmV0dXJuIFwibWV0YVwiO1xuICAgIH0sXG4gICAgJ1wiJzogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKCFzdHJlYW0ubWF0Y2goJ1wiXCInKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblRyaXBsZVN0cmluZztcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9LFxuICAgIFwiJ1wiOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9cXHhhMS1cXHVmZmZmXS8pO1xuICAgICAgcmV0dXJuIFwiYXRvbVwiO1xuICAgIH0sXG4gICAgXCI9XCI6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBjeCA9IHN0YXRlLmNvbnRleHRcbiAgICAgIGlmIChjeC50eXBlID09IFwifVwiICYmIGN4LmFsaWduICYmIHN0cmVhbS5lYXQoXCI+XCIpKSB7XG4gICAgICAgIHN0YXRlLmNvbnRleHQgPSBuZXcgQ29udGV4dChjeC5pbmRlbnRlZCwgY3guY29sdW1uLCBjeC50eXBlLCBjeC5pbmZvLCBudWxsLCBjeC5wcmV2KVxuICAgICAgICByZXR1cm4gXCJvcGVyYXRvclwiXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCIvXCI6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmICghc3RyZWFtLmVhdChcIipcIikpIHJldHVybiBmYWxzZVxuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbk5lc3RlZENvbW1lbnQoMSlcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKVxuICAgIH1cbiAgfSxcbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgY2xvc2VCcmFja2V0czoge2JyYWNrZXRzOiBbXCIoXCIsIFwiW1wiLCBcIntcIiwgXCInXCIsICdcIicsICdcIlwiXCInXX1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHRva2VuS290bGluU3RyaW5nKHRyaXBsZVN0cmluZyl7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQsIGVuZCA9IGZhbHNlO1xuICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICBpZiAoIXRyaXBsZVN0cmluZyAmJiAhZXNjYXBlZCAmJiBzdHJlYW0ubWF0Y2goJ1wiJykgKSB7ZW5kID0gdHJ1ZTsgYnJlYWs7fVxuICAgICAgaWYgKHRyaXBsZVN0cmluZyAmJiBzdHJlYW0ubWF0Y2goJ1wiXCJcIicpKSB7ZW5kID0gdHJ1ZTsgYnJlYWs7fVxuICAgICAgbmV4dCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgICBpZighZXNjYXBlZCAmJiBuZXh0ID09IFwiJFwiICYmIHN0cmVhbS5tYXRjaCgneycpKVxuICAgICAgICBzdHJlYW0uc2tpcFRvKFwifVwiKTtcbiAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiICYmICF0cmlwbGVTdHJpbmc7XG4gICAgfVxuICAgIGlmIChlbmQgfHwgIXRyaXBsZVN0cmluZylcbiAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qga290bGluID0gY2xpa2Uoe1xuICBrZXl3b3Jkczogd29yZHMoXG4gICAgLyprZXl3b3JkcyovXG4gICAgXCJwYWNrYWdlIGFzIHR5cGVhbGlhcyBjbGFzcyBpbnRlcmZhY2UgdGhpcyBzdXBlciB2YWwgb3BlcmF0b3IgXCIgK1xuICAgICAgXCJ2YXIgZnVuIGZvciBpcyBpbiBUaGlzIHRocm93IHJldHVybiBhbm5vdGF0aW9uIFwiICtcbiAgICAgIFwiYnJlYWsgY29udGludWUgb2JqZWN0IGlmIGVsc2Ugd2hpbGUgZG8gdHJ5IHdoZW4gIWluICFpcyBhcz8gXCIgK1xuXG4gICAgLypzb2Z0IGtleXdvcmRzKi9cbiAgICBcImZpbGUgaW1wb3J0IHdoZXJlIGJ5IGdldCBzZXQgYWJzdHJhY3QgZW51bSBvcGVuIGlubmVyIG92ZXJyaWRlIHByaXZhdGUgcHVibGljIGludGVybmFsIFwiICtcbiAgICAgIFwicHJvdGVjdGVkIGNhdGNoIGZpbmFsbHkgb3V0IGZpbmFsIHZhcmFyZyByZWlmaWVkIGR5bmFtaWMgY29tcGFuaW9uIGNvbnN0cnVjdG9yIGluaXQgXCIgK1xuICAgICAgXCJzZWFsZWQgZmllbGQgcHJvcGVydHkgcmVjZWl2ZXIgcGFyYW0gc3BhcmFtIGxhdGVpbml0IGRhdGEgaW5saW5lIG5vaW5saW5lIHRhaWxyZWMgXCIgK1xuICAgICAgXCJleHRlcm5hbCBhbm5vdGF0aW9uIGNyb3NzaW5saW5lIGNvbnN0IG9wZXJhdG9yIGluZml4IHN1c3BlbmQgYWN0dWFsIGV4cGVjdCBzZXRwYXJhbVwiXG4gICksXG4gIHR5cGVzOiB3b3JkcyhcbiAgICAvKiBwYWNrYWdlIGphdmEubGFuZyAqL1xuICAgIFwiQm9vbGVhbiBCeXRlIENoYXJhY3RlciBDaGFyU2VxdWVuY2UgQ2xhc3MgQ2xhc3NMb2FkZXIgQ2xvbmVhYmxlIENvbXBhcmFibGUgXCIgK1xuICAgICAgXCJDb21waWxlciBEb3VibGUgRXhjZXB0aW9uIEZsb2F0IEludGVnZXIgTG9uZyBNYXRoIE51bWJlciBPYmplY3QgUGFja2FnZSBQYWlyIFByb2Nlc3MgXCIgK1xuICAgICAgXCJSdW50aW1lIFJ1bm5hYmxlIFNlY3VyaXR5TWFuYWdlciBTaG9ydCBTdGFja1RyYWNlRWxlbWVudCBTdHJpY3RNYXRoIFN0cmluZyBcIiArXG4gICAgICBcIlN0cmluZ0J1ZmZlciBTeXN0ZW0gVGhyZWFkIFRocmVhZEdyb3VwIFRocmVhZExvY2FsIFRocm93YWJsZSBUcmlwbGUgVm9pZCBBbm5vdGF0aW9uIEFueSBCb29sZWFuQXJyYXkgXCIgK1xuICAgICAgXCJCeXRlQXJyYXkgQ2hhciBDaGFyQXJyYXkgRGVwcmVjYXRpb25MZXZlbCBEb3VibGVBcnJheSBFbnVtIEZsb2F0QXJyYXkgRnVuY3Rpb24gSW50IEludEFycmF5IExhenkgXCIgK1xuICAgICAgXCJMYXp5VGhyZWFkU2FmZXR5TW9kZSBMb25nQXJyYXkgTm90aGluZyBTaG9ydEFycmF5IFVuaXRcIlxuICApLFxuICBpbnRlbmRTd2l0Y2g6IGZhbHNlLFxuICBpbmRlbnRTdGF0ZW1lbnRzOiBmYWxzZSxcbiAgbXVsdGlMaW5lU3RyaW5nczogdHJ1ZSxcbiAgbnVtYmVyOiAvXig/OjB4W2EtZlxcZF9dK3wwYlswMV9dK3woPzpbXFxkX10rKFxcLlxcZCspP3xcXC5cXGQrKSg/OmVbLStdP1tcXGRfXSspPykodXxsbD98bHxmKT8vaSxcbiAgYmxvY2tLZXl3b3Jkczogd29yZHMoXCJjYXRjaCBjbGFzcyBkbyBlbHNlIGZpbmFsbHkgZm9yIGlmIHdoZXJlIHRyeSB3aGlsZSBlbnVtXCIpLFxuICBkZWZLZXl3b3Jkczogd29yZHMoXCJjbGFzcyB2YWwgdmFyIG9iamVjdCBpbnRlcmZhY2UgZnVuXCIpLFxuICBhdG9tczogd29yZHMoXCJ0cnVlIGZhbHNlIG51bGwgdGhpc1wiKSxcbiAgaG9va3M6IHtcbiAgICBcIkBcIjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXS8pO1xuICAgICAgcmV0dXJuIFwibWV0YVwiO1xuICAgIH0sXG4gICAgJyonOiBmdW5jdGlvbihfc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgcmV0dXJuIHN0YXRlLnByZXZUb2tlbiA9PSAnLicgPyAndmFyaWFibGUnIDogJ29wZXJhdG9yJztcbiAgICB9LFxuICAgICdcIic6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5Lb3RsaW5TdHJpbmcoc3RyZWFtLm1hdGNoKCdcIlwiJykpO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0sXG4gICAgXCIvXCI6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmICghc3RyZWFtLmVhdChcIipcIikpIHJldHVybiBmYWxzZTtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5OZXN0ZWRDb21tZW50KDEpO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpXG4gICAgfSxcbiAgICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCBjdHgsIHRleHRBZnRlciwgaW5kZW50VW5pdCkge1xuICAgICAgdmFyIGZpcnN0Q2hhciA9IHRleHRBZnRlciAmJiB0ZXh0QWZ0ZXIuY2hhckF0KDApO1xuICAgICAgaWYgKChzdGF0ZS5wcmV2VG9rZW4gPT0gXCJ9XCIgfHwgc3RhdGUucHJldlRva2VuID09IFwiKVwiKSAmJiB0ZXh0QWZ0ZXIgPT0gXCJcIilcbiAgICAgICAgcmV0dXJuIHN0YXRlLmluZGVudGVkO1xuICAgICAgaWYgKChzdGF0ZS5wcmV2VG9rZW4gPT0gXCJvcGVyYXRvclwiICYmIHRleHRBZnRlciAhPSBcIn1cIiAmJiBzdGF0ZS5jb250ZXh0LnR5cGUgIT0gXCJ9XCIpIHx8XG4gICAgICAgICAgc3RhdGUucHJldlRva2VuID09IFwidmFyaWFibGVcIiAmJiBmaXJzdENoYXIgPT0gXCIuXCIgfHxcbiAgICAgICAgICAoc3RhdGUucHJldlRva2VuID09IFwifVwiIHx8IHN0YXRlLnByZXZUb2tlbiA9PSBcIilcIikgJiYgZmlyc3RDaGFyID09IFwiLlwiKVxuICAgICAgICByZXR1cm4gaW5kZW50VW5pdCAqIDIgKyBjdHguaW5kZW50ZWQ7XG4gICAgICBpZiAoY3R4LmFsaWduICYmIGN0eC50eXBlID09IFwifVwiKVxuICAgICAgICByZXR1cm4gY3R4LmluZGVudGVkICsgKHN0YXRlLmNvbnRleHQudHlwZSA9PSAodGV4dEFmdGVyIHx8IFwiXCIpLmNoYXJBdCgwKSA/IDAgOiBpbmRlbnRVbml0KTtcbiAgICB9XG4gIH0sXG4gIGxhbmd1YWdlRGF0YToge1xuICAgIGNsb3NlQnJhY2tldHM6IHticmFja2V0czogW1wiKFwiLCBcIltcIiwgXCJ7XCIsIFwiJ1wiLCAnXCInLCAnXCJcIlwiJ119XG4gIH1cbn0pO1xuXG5leHBvcnQgY29uc3Qgc2hhZGVyID0gY2xpa2Uoe1xuICBrZXl3b3Jkczogd29yZHMoXCJzYW1wbGVyMUQgc2FtcGxlcjJEIHNhbXBsZXIzRCBzYW1wbGVyQ3ViZSBcIiArXG4gICAgICAgICAgICAgICAgICBcInNhbXBsZXIxRFNoYWRvdyBzYW1wbGVyMkRTaGFkb3cgXCIgK1xuICAgICAgICAgICAgICAgICAgXCJjb25zdCBhdHRyaWJ1dGUgdW5pZm9ybSB2YXJ5aW5nIFwiICtcbiAgICAgICAgICAgICAgICAgIFwiYnJlYWsgY29udGludWUgZGlzY2FyZCByZXR1cm4gXCIgK1xuICAgICAgICAgICAgICAgICAgXCJmb3Igd2hpbGUgZG8gaWYgZWxzZSBzdHJ1Y3QgXCIgK1xuICAgICAgICAgICAgICAgICAgXCJpbiBvdXQgaW5vdXRcIiksXG4gIHR5cGVzOiB3b3JkcyhcImZsb2F0IGludCBib29sIHZvaWQgXCIgK1xuICAgICAgICAgICAgICAgXCJ2ZWMyIHZlYzMgdmVjNCBpdmVjMiBpdmVjMyBpdmVjNCBidmVjMiBidmVjMyBidmVjNCBcIiArXG4gICAgICAgICAgICAgICBcIm1hdDIgbWF0MyBtYXQ0XCIpLFxuICBibG9ja0tleXdvcmRzOiB3b3JkcyhcImZvciB3aGlsZSBkbyBpZiBlbHNlIHN0cnVjdFwiKSxcbiAgYnVpbHRpbjogd29yZHMoXCJyYWRpYW5zIGRlZ3JlZXMgc2luIGNvcyB0YW4gYXNpbiBhY29zIGF0YW4gXCIgK1xuICAgICAgICAgICAgICAgICBcInBvdyBleHAgbG9nIGV4cDIgc3FydCBpbnZlcnNlc3FydCBcIiArXG4gICAgICAgICAgICAgICAgIFwiYWJzIHNpZ24gZmxvb3IgY2VpbCBmcmFjdCBtb2QgbWluIG1heCBjbGFtcCBtaXggc3RlcCBzbW9vdGhzdGVwIFwiICtcbiAgICAgICAgICAgICAgICAgXCJsZW5ndGggZGlzdGFuY2UgZG90IGNyb3NzIG5vcm1hbGl6ZSBmdHJhbnNmb3JtIGZhY2Vmb3J3YXJkIFwiICtcbiAgICAgICAgICAgICAgICAgXCJyZWZsZWN0IHJlZnJhY3QgbWF0cml4Q29tcE11bHQgXCIgK1xuICAgICAgICAgICAgICAgICBcImxlc3NUaGFuIGxlc3NUaGFuRXF1YWwgZ3JlYXRlclRoYW4gZ3JlYXRlclRoYW5FcXVhbCBcIiArXG4gICAgICAgICAgICAgICAgIFwiZXF1YWwgbm90RXF1YWwgYW55IGFsbCBub3QgXCIgK1xuICAgICAgICAgICAgICAgICBcInRleHR1cmUxRCB0ZXh0dXJlMURQcm9qIHRleHR1cmUxRExvZCB0ZXh0dXJlMURQcm9qTG9kIFwiICtcbiAgICAgICAgICAgICAgICAgXCJ0ZXh0dXJlMkQgdGV4dHVyZTJEUHJvaiB0ZXh0dXJlMkRMb2QgdGV4dHVyZTJEUHJvakxvZCBcIiArXG4gICAgICAgICAgICAgICAgIFwidGV4dHVyZTNEIHRleHR1cmUzRFByb2ogdGV4dHVyZTNETG9kIHRleHR1cmUzRFByb2pMb2QgXCIgK1xuICAgICAgICAgICAgICAgICBcInRleHR1cmVDdWJlIHRleHR1cmVDdWJlTG9kIFwiICtcbiAgICAgICAgICAgICAgICAgXCJzaGFkb3cxRCBzaGFkb3cyRCBzaGFkb3cxRFByb2ogc2hhZG93MkRQcm9qIFwiICtcbiAgICAgICAgICAgICAgICAgXCJzaGFkb3cxRExvZCBzaGFkb3cyRExvZCBzaGFkb3cxRFByb2pMb2Qgc2hhZG93MkRQcm9qTG9kIFwiICtcbiAgICAgICAgICAgICAgICAgXCJkRmR4IGRGZHkgZndpZHRoIFwiICtcbiAgICAgICAgICAgICAgICAgXCJub2lzZTEgbm9pc2UyIG5vaXNlMyBub2lzZTRcIiksXG4gIGF0b21zOiB3b3JkcyhcInRydWUgZmFsc2UgXCIgK1xuICAgICAgICAgICAgICAgXCJnbF9GcmFnQ29sb3IgZ2xfU2Vjb25kYXJ5Q29sb3IgZ2xfTm9ybWFsIGdsX1ZlcnRleCBcIiArXG4gICAgICAgICAgICAgICBcImdsX011bHRpVGV4Q29vcmQwIGdsX011bHRpVGV4Q29vcmQxIGdsX011bHRpVGV4Q29vcmQyIGdsX011bHRpVGV4Q29vcmQzIFwiICtcbiAgICAgICAgICAgICAgIFwiZ2xfTXVsdGlUZXhDb29yZDQgZ2xfTXVsdGlUZXhDb29yZDUgZ2xfTXVsdGlUZXhDb29yZDYgZ2xfTXVsdGlUZXhDb29yZDcgXCIgK1xuICAgICAgICAgICAgICAgXCJnbF9Gb2dDb29yZCBnbF9Qb2ludENvb3JkIFwiICtcbiAgICAgICAgICAgICAgIFwiZ2xfUG9zaXRpb24gZ2xfUG9pbnRTaXplIGdsX0NsaXBWZXJ0ZXggXCIgK1xuICAgICAgICAgICAgICAgXCJnbF9Gcm9udENvbG9yIGdsX0JhY2tDb2xvciBnbF9Gcm9udFNlY29uZGFyeUNvbG9yIGdsX0JhY2tTZWNvbmRhcnlDb2xvciBcIiArXG4gICAgICAgICAgICAgICBcImdsX1RleENvb3JkIGdsX0ZvZ0ZyYWdDb29yZCBcIiArXG4gICAgICAgICAgICAgICBcImdsX0ZyYWdDb29yZCBnbF9Gcm9udEZhY2luZyBcIiArXG4gICAgICAgICAgICAgICBcImdsX0ZyYWdEYXRhIGdsX0ZyYWdEZXB0aCBcIiArXG4gICAgICAgICAgICAgICBcImdsX01vZGVsVmlld01hdHJpeCBnbF9Qcm9qZWN0aW9uTWF0cml4IGdsX01vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggXCIgK1xuICAgICAgICAgICAgICAgXCJnbF9UZXh0dXJlTWF0cml4IGdsX05vcm1hbE1hdHJpeCBnbF9Nb2RlbFZpZXdNYXRyaXhJbnZlcnNlIFwiICtcbiAgICAgICAgICAgICAgIFwiZ2xfUHJvamVjdGlvbk1hdHJpeEludmVyc2UgZ2xfTW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeEludmVyc2UgXCIgK1xuICAgICAgICAgICAgICAgXCJnbF9UZXh0dXJlTWF0cml4VHJhbnNwb3NlIGdsX01vZGVsVmlld01hdHJpeEludmVyc2VUcmFuc3Bvc2UgXCIgK1xuICAgICAgICAgICAgICAgXCJnbF9Qcm9qZWN0aW9uTWF0cml4SW52ZXJzZVRyYW5zcG9zZSBcIiArXG4gICAgICAgICAgICAgICBcImdsX01vZGVsVmlld1Byb2plY3Rpb25NYXRyaXhJbnZlcnNlVHJhbnNwb3NlIFwiICtcbiAgICAgICAgICAgICAgIFwiZ2xfVGV4dHVyZU1hdHJpeEludmVyc2VUcmFuc3Bvc2UgXCIgK1xuICAgICAgICAgICAgICAgXCJnbF9Ob3JtYWxTY2FsZSBnbF9EZXB0aFJhbmdlIGdsX0NsaXBQbGFuZSBcIiArXG4gICAgICAgICAgICAgICBcImdsX1BvaW50IGdsX0Zyb250TWF0ZXJpYWwgZ2xfQmFja01hdGVyaWFsIGdsX0xpZ2h0U291cmNlIGdsX0xpZ2h0TW9kZWwgXCIgK1xuICAgICAgICAgICAgICAgXCJnbF9Gcm9udExpZ2h0TW9kZWxQcm9kdWN0IGdsX0JhY2tMaWdodE1vZGVsUHJvZHVjdCBcIiArXG4gICAgICAgICAgICAgICBcImdsX1RleHR1cmVDb2xvciBnbF9FeWVQbGFuZVMgZ2xfRXllUGxhbmVUIGdsX0V5ZVBsYW5lUiBnbF9FeWVQbGFuZVEgXCIgK1xuICAgICAgICAgICAgICAgXCJnbF9Gb2dQYXJhbWV0ZXJzIFwiICtcbiAgICAgICAgICAgICAgIFwiZ2xfTWF4TGlnaHRzIGdsX01heENsaXBQbGFuZXMgZ2xfTWF4VGV4dHVyZVVuaXRzIGdsX01heFRleHR1cmVDb29yZHMgXCIgK1xuICAgICAgICAgICAgICAgXCJnbF9NYXhWZXJ0ZXhBdHRyaWJzIGdsX01heFZlcnRleFVuaWZvcm1Db21wb25lbnRzIGdsX01heFZhcnlpbmdGbG9hdHMgXCIgK1xuICAgICAgICAgICAgICAgXCJnbF9NYXhWZXJ0ZXhUZXh0dXJlSW1hZ2VVbml0cyBnbF9NYXhUZXh0dXJlSW1hZ2VVbml0cyBcIiArXG4gICAgICAgICAgICAgICBcImdsX01heEZyYWdtZW50VW5pZm9ybUNvbXBvbmVudHMgZ2xfTWF4Q29tYmluZVRleHR1cmVJbWFnZVVuaXRzIFwiICtcbiAgICAgICAgICAgICAgIFwiZ2xfTWF4RHJhd0J1ZmZlcnNcIiksXG4gIGluZGVudFN3aXRjaDogZmFsc2UsXG4gIGhvb2tzOiB7XCIjXCI6IGNwcEhvb2t9XG59KVxuXG5leHBvcnQgY29uc3QgbmVzQyA9IGNsaWtlKHtcbiAga2V5d29yZHM6IHdvcmRzKGNLZXl3b3JkcyArIFwiIGFzIGF0b21pYyBhc3luYyBjYWxsIGNvbW1hbmQgY29tcG9uZW50IGNvbXBvbmVudHMgY29uZmlndXJhdGlvbiBldmVudCBnZW5lcmljIFwiICtcbiAgICAgICAgICAgICAgICAgIFwiaW1wbGVtZW50YXRpb24gaW5jbHVkZXMgaW50ZXJmYWNlIG1vZHVsZSBuZXcgbm9yYWNlIG54X3N0cnVjdCBueF91bmlvbiBwb3N0IHByb3ZpZGVzIFwiICtcbiAgICAgICAgICAgICAgICAgIFwic2lnbmFsIHRhc2sgdXNlcyBhYnN0cmFjdCBleHRlbmRzXCIpLFxuICB0eXBlczogY1R5cGVzLFxuICBibG9ja0tleXdvcmRzOiB3b3JkcyhjQmxvY2tLZXl3b3JkcyksXG4gIGF0b21zOiB3b3JkcyhcIm51bGwgdHJ1ZSBmYWxzZVwiKSxcbiAgaG9va3M6IHtcIiNcIjogY3BwSG9va31cbn0pXG5cbmV4cG9ydCBjb25zdCBvYmplY3RpdmVDID0gY2xpa2Uoe1xuICBrZXl3b3Jkczogd29yZHMoY0tleXdvcmRzICsgXCIgXCIgKyBvYmpDS2V5d29yZHMpLFxuICB0eXBlczogb2JqQ1R5cGVzLFxuICBidWlsdGluOiB3b3JkcyhvYmpDQnVpbHRpbnMpLFxuICBibG9ja0tleXdvcmRzOiB3b3JkcyhjQmxvY2tLZXl3b3JkcyArIFwiIEBzeW50aGVzaXplIEB0cnkgQGNhdGNoIEBmaW5hbGx5IEBhdXRvcmVsZWFzZXBvb2wgQHN5bmNocm9uaXplZFwiKSxcbiAgZGVmS2V5d29yZHM6IHdvcmRzKGNEZWZLZXl3b3JkcyArIFwiIEBpbnRlcmZhY2UgQGltcGxlbWVudGF0aW9uIEBwcm90b2NvbCBAY2xhc3NcIiksXG4gIGRvbnRJbmRlbnRTdGF0ZW1lbnRzOiAvXkAuKiQvLFxuICB0eXBlRmlyc3REZWZpbml0aW9uczogdHJ1ZSxcbiAgYXRvbXM6IHdvcmRzKFwiWUVTIE5PIE5VTEwgTmlsIG5pbCB0cnVlIGZhbHNlIG51bGxwdHJcIiksXG4gIGlzUmVzZXJ2ZWRJZGVudGlmaWVyOiBjSXNSZXNlcnZlZElkZW50aWZpZXIsXG4gIGhvb2tzOiB7XG4gICAgXCIjXCI6IGNwcEhvb2ssXG4gICAgXCIqXCI6IHBvaW50ZXJIb29rLFxuICB9XG59KVxuXG5leHBvcnQgY29uc3Qgb2JqZWN0aXZlQ3BwID0gY2xpa2Uoe1xuICBrZXl3b3Jkczogd29yZHMoY0tleXdvcmRzICsgXCIgXCIgKyBvYmpDS2V5d29yZHMgKyBcIiBcIiArIGNwcEtleXdvcmRzKSxcbiAgdHlwZXM6IG9iakNUeXBlcyxcbiAgYnVpbHRpbjogd29yZHMob2JqQ0J1aWx0aW5zKSxcbiAgYmxvY2tLZXl3b3Jkczogd29yZHMoY0Jsb2NrS2V5d29yZHMgKyBcIiBAc3ludGhlc2l6ZSBAdHJ5IEBjYXRjaCBAZmluYWxseSBAYXV0b3JlbGVhc2Vwb29sIEBzeW5jaHJvbml6ZWQgY2xhc3MgdHJ5IGNhdGNoXCIpLFxuICBkZWZLZXl3b3Jkczogd29yZHMoY0RlZktleXdvcmRzICsgXCIgQGludGVyZmFjZSBAaW1wbGVtZW50YXRpb24gQHByb3RvY29sIEBjbGFzcyBjbGFzcyBuYW1lc3BhY2VcIiksXG4gIGRvbnRJbmRlbnRTdGF0ZW1lbnRzOiAvXkAuKiR8XnRlbXBsYXRlJC8sXG4gIHR5cGVGaXJzdERlZmluaXRpb25zOiB0cnVlLFxuICBhdG9tczogd29yZHMoXCJZRVMgTk8gTlVMTCBOaWwgbmlsIHRydWUgZmFsc2UgbnVsbHB0clwiKSxcbiAgaXNSZXNlcnZlZElkZW50aWZpZXI6IGNJc1Jlc2VydmVkSWRlbnRpZmllcixcbiAgaG9va3M6IHtcbiAgICBcIiNcIjogY3BwSG9vayxcbiAgICBcIipcIjogcG9pbnRlckhvb2ssXG4gICAgXCJ1XCI6IGNwcDExU3RyaW5nSG9vayxcbiAgICBcIlVcIjogY3BwMTFTdHJpbmdIb29rLFxuICAgIFwiTFwiOiBjcHAxMVN0cmluZ0hvb2ssXG4gICAgXCJSXCI6IGNwcDExU3RyaW5nSG9vayxcbiAgICBcIjBcIjogY3BwMTRMaXRlcmFsLFxuICAgIFwiMVwiOiBjcHAxNExpdGVyYWwsXG4gICAgXCIyXCI6IGNwcDE0TGl0ZXJhbCxcbiAgICBcIjNcIjogY3BwMTRMaXRlcmFsLFxuICAgIFwiNFwiOiBjcHAxNExpdGVyYWwsXG4gICAgXCI1XCI6IGNwcDE0TGl0ZXJhbCxcbiAgICBcIjZcIjogY3BwMTRMaXRlcmFsLFxuICAgIFwiN1wiOiBjcHAxNExpdGVyYWwsXG4gICAgXCI4XCI6IGNwcDE0TGl0ZXJhbCxcbiAgICBcIjlcIjogY3BwMTRMaXRlcmFsLFxuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlLCBzdHlsZSkge1xuICAgICAgaWYgKHN0eWxlID09IFwidmFyaWFibGVcIiAmJiBzdHJlYW0ucGVlaygpID09IFwiKFwiICYmXG4gICAgICAgICAgKHN0YXRlLnByZXZUb2tlbiA9PSBcIjtcIiB8fCBzdGF0ZS5wcmV2VG9rZW4gPT0gbnVsbCB8fFxuICAgICAgICAgICBzdGF0ZS5wcmV2VG9rZW4gPT0gXCJ9XCIpICYmXG4gICAgICAgICAgY3BwTG9va3NMaWtlQ29uc3RydWN0b3Ioc3RyZWFtLmN1cnJlbnQoKSkpXG4gICAgICAgIHJldHVybiBcImRlZlwiO1xuICAgIH1cbiAgfSxcbiAgbmFtZXNwYWNlU2VwYXJhdG9yOiBcIjo6XCJcbn0pXG5cbmV4cG9ydCBjb25zdCBzcXVpcnJlbCA9IGNsaWtlKHtcbiAga2V5d29yZHM6IHdvcmRzKFwiYmFzZSBicmVhayBjbG9uZSBjb250aW51ZSBjb25zdCBkZWZhdWx0IGRlbGV0ZSBlbnVtIGV4dGVuZHMgZnVuY3Rpb24gaW4gY2xhc3NcIiArXG4gICAgICAgICAgICAgICAgICBcIiBmb3JlYWNoIGxvY2FsIHJlc3VtZSByZXR1cm4gdGhpcyB0aHJvdyB0eXBlb2YgeWllbGQgY29uc3RydWN0b3IgaW5zdGFuY2VvZiBzdGF0aWNcIiksXG4gIHR5cGVzOiBjVHlwZXMsXG4gIGJsb2NrS2V5d29yZHM6IHdvcmRzKFwiY2FzZSBjYXRjaCBjbGFzcyBlbHNlIGZvciBmb3JlYWNoIGlmIHN3aXRjaCB0cnkgd2hpbGVcIiksXG4gIGRlZktleXdvcmRzOiB3b3JkcyhcImZ1bmN0aW9uIGxvY2FsIGNsYXNzXCIpLFxuICB0eXBlRmlyc3REZWZpbml0aW9uczogdHJ1ZSxcbiAgYXRvbXM6IHdvcmRzKFwidHJ1ZSBmYWxzZSBudWxsXCIpLFxuICBob29rczoge1wiI1wiOiBjcHBIb29rfVxufSlcblxuLy8gQ2V5bG9uIFN0cmluZ3MgbmVlZCB0byBkZWFsIHdpdGggaW50ZXJwb2xhdGlvblxudmFyIHN0cmluZ1Rva2VuaXplciA9IG51bGw7XG5mdW5jdGlvbiB0b2tlbkNleWxvblN0cmluZyh0eXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgbmV4dCwgZW5kID0gZmFsc2U7XG4gICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgIGlmICghZXNjYXBlZCAmJiBzdHJlYW0ubWF0Y2goJ1wiJykgJiZcbiAgICAgICAgICAodHlwZSA9PSBcInNpbmdsZVwiIHx8IHN0cmVhbS5tYXRjaCgnXCJcIicpKSkge1xuICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICghZXNjYXBlZCAmJiBzdHJlYW0ubWF0Y2goJ2BgJykpIHtcbiAgICAgICAgc3RyaW5nVG9rZW5pemVyID0gdG9rZW5DZXlsb25TdHJpbmcodHlwZSk7XG4gICAgICAgIGVuZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbmV4dCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgICBlc2NhcGVkID0gdHlwZSA9PSBcInNpbmdsZVwiICYmICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gICAgfVxuICAgIGlmIChlbmQpXG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNleWxvbiA9IGNsaWtlKHtcbiAga2V5d29yZHM6IHdvcmRzKFwiYWJzdHJhY3RzIGFsaWFzIGFzc2VtYmx5IGFzc2VydCBhc3NpZ24gYnJlYWsgY2FzZSBjYXRjaCBjbGFzcyBjb250aW51ZSBkeW5hbWljIGVsc2VcIiArXG4gICAgICAgICAgICAgICAgICBcIiBleGlzdHMgZXh0ZW5kcyBmaW5hbGx5IGZvciBmdW5jdGlvbiBnaXZlbiBpZiBpbXBvcnQgaW4gaW50ZXJmYWNlIGlzIGxldCBtb2R1bGUgbmV3XCIgK1xuICAgICAgICAgICAgICAgICAgXCIgbm9uZW1wdHkgb2JqZWN0IG9mIG91dCBvdXRlciBwYWNrYWdlIHJldHVybiBzYXRpc2ZpZXMgc3VwZXIgc3dpdGNoIHRoZW4gdGhpcyB0aHJvd1wiICtcbiAgICAgICAgICAgICAgICAgIFwiIHRyeSB2YWx1ZSB2b2lkIHdoaWxlXCIpLFxuICB0eXBlczogZnVuY3Rpb24od29yZCkge1xuICAgIC8vIEluIENleWxvbiBhbGwgaWRlbnRpZmllcnMgdGhhdCBzdGFydCB3aXRoIGFuIHVwcGVyY2FzZSBhcmUgdHlwZXNcbiAgICB2YXIgZmlyc3QgPSB3b3JkLmNoYXJBdCgwKTtcbiAgICByZXR1cm4gKGZpcnN0ID09PSBmaXJzdC50b1VwcGVyQ2FzZSgpICYmIGZpcnN0ICE9PSBmaXJzdC50b0xvd2VyQ2FzZSgpKTtcbiAgfSxcbiAgYmxvY2tLZXl3b3Jkczogd29yZHMoXCJjYXNlIGNhdGNoIGNsYXNzIGR5bmFtaWMgZWxzZSBmaW5hbGx5IGZvciBmdW5jdGlvbiBpZiBpbnRlcmZhY2UgbW9kdWxlIG5ldyBvYmplY3Qgc3dpdGNoIHRyeSB3aGlsZVwiKSxcbiAgZGVmS2V5d29yZHM6IHdvcmRzKFwiY2xhc3MgZHluYW1pYyBmdW5jdGlvbiBpbnRlcmZhY2UgbW9kdWxlIG9iamVjdCBwYWNrYWdlIHZhbHVlXCIpLFxuICBidWlsdGluOiB3b3JkcyhcImFic3RyYWN0IGFjdHVhbCBhbGlhc2VkIGFubm90YXRpb24gYnkgZGVmYXVsdCBkZXByZWNhdGVkIGRvYyBmaW5hbCBmb3JtYWwgbGF0ZSBsaWNlbnNlXCIgK1xuICAgICAgICAgICAgICAgICBcIiBuYXRpdmUgb3B0aW9uYWwgc2VhbGVkIHNlZSBzZXJpYWxpemFibGUgc2hhcmVkIHN1cHByZXNzV2FybmluZ3MgdGFnZ2VkIHRocm93cyB2YXJpYWJsZVwiKSxcbiAgaXNQdW5jdHVhdGlvbkNoYXI6IC9bXFxbXFxde31cXChcXCksO1xcOlxcLmBdLyxcbiAgaXNPcGVyYXRvckNoYXI6IC9bK1xcLSomJT08PiE/fF5+OlxcL10vLFxuICBudW1iZXJTdGFydDogL1tcXGQjJF0vLFxuICBudW1iZXI6IC9eKD86I1tcXGRhLWZBLUZfXSt8XFwkWzAxX10rfFtcXGRfXStba01HVFBtdW5wZl0/fFtcXGRfXStcXC5bXFxkX10rKD86W2VFXVstK10/XFxkK3xba01HVFBtdW5wZl18KXwpL2ksXG4gIG11bHRpTGluZVN0cmluZ3M6IHRydWUsXG4gIHR5cGVGaXJzdERlZmluaXRpb25zOiB0cnVlLFxuICBhdG9tczogd29yZHMoXCJ0cnVlIGZhbHNlIG51bGwgbGFyZ2VyIHNtYWxsZXIgZXF1YWwgZW1wdHkgZmluaXNoZWRcIiksXG4gIGluZGVudFN3aXRjaDogZmFsc2UsXG4gIHN0eWxlRGVmczogZmFsc2UsXG4gIGhvb2tzOiB7XG4gICAgXCJAXCI6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX10vKTtcbiAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgICB9LFxuICAgICdcIic6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5DZXlsb25TdHJpbmcoc3RyZWFtLm1hdGNoKCdcIlwiJykgPyBcInRyaXBsZVwiIDogXCJzaW5nbGVcIik7XG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSxcbiAgICAnYCc6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmICghc3RyaW5nVG9rZW5pemVyIHx8ICFzdHJlYW0ubWF0Y2goJ2AnKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgc3RhdGUudG9rZW5pemUgPSBzdHJpbmdUb2tlbml6ZXI7XG4gICAgICBzdHJpbmdUb2tlbml6ZXIgPSBudWxsO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0sXG4gICAgXCInXCI6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX1xceGExLVxcdWZmZmZdLyk7XG4gICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgfSxcbiAgICB0b2tlbjogZnVuY3Rpb24oX3N0cmVhbSwgc3RhdGUsIHN0eWxlKSB7XG4gICAgICBpZiAoKHN0eWxlID09IFwidmFyaWFibGVcIiB8fCBzdHlsZSA9PSBcInR5cGVcIikgJiZcbiAgICAgICAgICBzdGF0ZS5wcmV2VG9rZW4gPT0gXCIuXCIpIHtcbiAgICAgICAgcmV0dXJuIFwidmFyaWFibGVOYW1lLnNwZWNpYWxcIjtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGxhbmd1YWdlRGF0YToge1xuICAgIGNsb3NlQnJhY2tldHM6IHticmFja2V0czogW1wiKFwiLCBcIltcIiwgXCJ7XCIsIFwiJ1wiLCAnXCInLCAnXCJcIlwiJ119XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIHB1c2hJbnRlcnBvbGF0aW9uU3RhY2soc3RhdGUpIHtcbiAgKHN0YXRlLmludGVycG9sYXRpb25TdGFjayB8fCAoc3RhdGUuaW50ZXJwb2xhdGlvblN0YWNrID0gW10pKS5wdXNoKHN0YXRlLnRva2VuaXplKTtcbn1cblxuZnVuY3Rpb24gcG9wSW50ZXJwb2xhdGlvblN0YWNrKHN0YXRlKSB7XG4gIHJldHVybiAoc3RhdGUuaW50ZXJwb2xhdGlvblN0YWNrIHx8IChzdGF0ZS5pbnRlcnBvbGF0aW9uU3RhY2sgPSBbXSkpLnBvcCgpO1xufVxuXG5mdW5jdGlvbiBzaXplSW50ZXJwb2xhdGlvblN0YWNrKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5pbnRlcnBvbGF0aW9uU3RhY2sgPyBzdGF0ZS5pbnRlcnBvbGF0aW9uU3RhY2subGVuZ3RoIDogMDtcbn1cblxuZnVuY3Rpb24gdG9rZW5EYXJ0U3RyaW5nKHF1b3RlLCBzdHJlYW0sIHN0YXRlLCByYXcpIHtcbiAgdmFyIHRyaXBsZVF1b3RlZCA9IGZhbHNlO1xuICBpZiAoc3RyZWFtLmVhdChxdW90ZSkpIHtcbiAgICBpZiAoc3RyZWFtLmVhdChxdW90ZSkpIHRyaXBsZVF1b3RlZCA9IHRydWU7XG4gICAgZWxzZSByZXR1cm4gXCJzdHJpbmdcIjsgLy9lbXB0eSBzdHJpbmdcbiAgfVxuICBmdW5jdGlvbiB0b2tlblN0cmluZ0hlbHBlcihzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGVzY2FwZWQgPSBmYWxzZTtcbiAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgaWYgKCFyYXcgJiYgIWVzY2FwZWQgJiYgc3RyZWFtLnBlZWsoKSA9PSBcIiRcIikge1xuICAgICAgICBwdXNoSW50ZXJwb2xhdGlvblN0YWNrKHN0YXRlKTtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkludGVycG9sYXRpb247XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgfVxuICAgICAgdmFyIG5leHQgPSBzdHJlYW0ubmV4dCgpO1xuICAgICAgaWYgKG5leHQgPT0gcXVvdGUgJiYgIWVzY2FwZWQgJiYgKCF0cmlwbGVRdW90ZWQgfHwgc3RyZWFtLm1hdGNoKHF1b3RlICsgcXVvdGUpKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZXNjYXBlZCA9ICFyYXcgJiYgIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gIH1cbiAgc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZ0hlbHBlcjtcbiAgcmV0dXJuIHRva2VuU3RyaW5nSGVscGVyKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiB0b2tlbkludGVycG9sYXRpb24oc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uZWF0KFwiJFwiKTtcbiAgaWYgKHN0cmVhbS5lYXQoXCJ7XCIpKSB7XG4gICAgLy8gbGV0IGNsaWtlIGhhbmRsZSB0aGUgY29udGVudCBvZiAkey4uLn0sXG4gICAgLy8gd2UgdGFrZSBvdmVyIGFnYWluIHdoZW4gXCJ9XCIgYXBwZWFycyAoc2VlIGhvb2tzKS5cbiAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkludGVycG9sYXRpb25JZGVudGlmaWVyO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB0b2tlbkludGVycG9sYXRpb25JZGVudGlmaWVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3X10vKTtcbiAgc3RhdGUudG9rZW5pemUgPSBwb3BJbnRlcnBvbGF0aW9uU3RhY2soc3RhdGUpO1xuICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xufVxuXG5leHBvcnQgY29uc3QgZGFydCA9IGNsaWtlKHtcbiAga2V5d29yZHM6IHdvcmRzKFwidGhpcyBzdXBlciBzdGF0aWMgZmluYWwgY29uc3QgYWJzdHJhY3QgY2xhc3MgZXh0ZW5kcyBleHRlcm5hbCBmYWN0b3J5IFwiICtcbiAgICAgICAgICAgICAgICAgIFwiaW1wbGVtZW50cyBtaXhpbiBnZXQgbmF0aXZlIHNldCB0eXBlZGVmIHdpdGggZW51bSB0aHJvdyByZXRocm93IFwiICtcbiAgICAgICAgICAgICAgICAgIFwiYXNzZXJ0IGJyZWFrIGNhc2UgY29udGludWUgZGVmYXVsdCBpbiByZXR1cm4gbmV3IGRlZmVycmVkIGFzeW5jIGF3YWl0IGNvdmFyaWFudCBcIiArXG4gICAgICAgICAgICAgICAgICBcInRyeSBjYXRjaCBmaW5hbGx5IGRvIGVsc2UgZm9yIGlmIHN3aXRjaCB3aGlsZSBpbXBvcnQgbGlicmFyeSBleHBvcnQgXCIgK1xuICAgICAgICAgICAgICAgICAgXCJwYXJ0IG9mIHNob3cgaGlkZSBpcyBhcyBleHRlbnNpb24gb24geWllbGQgbGF0ZSByZXF1aXJlZFwiKSxcbiAgYmxvY2tLZXl3b3Jkczogd29yZHMoXCJ0cnkgY2F0Y2ggZmluYWxseSBkbyBlbHNlIGZvciBpZiBzd2l0Y2ggd2hpbGVcIiksXG4gIGJ1aWx0aW46IHdvcmRzKFwidm9pZCBib29sIG51bSBpbnQgZG91YmxlIGR5bmFtaWMgdmFyIFN0cmluZyBOdWxsIE5ldmVyXCIpLFxuICBhdG9tczogd29yZHMoXCJ0cnVlIGZhbHNlIG51bGxcIiksXG4gIGhvb2tzOiB7XG4gICAgXCJAXCI6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX1xcLl0vKTtcbiAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgICB9LFxuXG4gICAgLy8gY3VzdG9tIHN0cmluZyBoYW5kbGluZyB0byBkZWFsIHdpdGggdHJpcGxlLXF1b3RlZCBzdHJpbmdzIGFuZCBzdHJpbmcgaW50ZXJwb2xhdGlvblxuICAgIFwiJ1wiOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICByZXR1cm4gdG9rZW5EYXJ0U3RyaW5nKFwiJ1wiLCBzdHJlYW0sIHN0YXRlLCBmYWxzZSk7XG4gICAgfSxcbiAgICBcIlxcXCJcIjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgcmV0dXJuIHRva2VuRGFydFN0cmluZyhcIlxcXCJcIiwgc3RyZWFtLCBzdGF0ZSwgZmFsc2UpO1xuICAgIH0sXG4gICAgXCJyXCI6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBwZWVrID0gc3RyZWFtLnBlZWsoKTtcbiAgICAgIGlmIChwZWVrID09IFwiJ1wiIHx8IHBlZWsgPT0gXCJcXFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIHRva2VuRGFydFN0cmluZyhzdHJlYW0ubmV4dCgpLCBzdHJlYW0sIHN0YXRlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgXCJ9XCI6IGZ1bmN0aW9uKF9zdHJlYW0sIHN0YXRlKSB7XG4gICAgICAvLyBcIn1cIiBpcyBlbmQgb2YgaW50ZXJwb2xhdGlvbiwgaWYgaW50ZXJwb2xhdGlvbiBzdGFjayBpcyBub24tZW1wdHlcbiAgICAgIGlmIChzaXplSW50ZXJwb2xhdGlvblN0YWNrKHN0YXRlKSA+IDApIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBwb3BJbnRlcnBvbGF0aW9uU3RhY2soc3RhdGUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgXCIvXCI6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmICghc3RyZWFtLmVhdChcIipcIikpIHJldHVybiBmYWxzZVxuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbk5lc3RlZENvbW1lbnQoMSlcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKVxuICAgIH0sXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgXywgc3R5bGUpIHtcbiAgICAgIGlmIChzdHlsZSA9PSBcInZhcmlhYmxlXCIpIHtcbiAgICAgICAgLy8gQXNzdW1lIHVwcGVyY2FzZSBzeW1ib2xzIGFyZSBjbGFzc2VzXG4gICAgICAgIHZhciBpc1VwcGVyID0gUmVnRXhwKCdeW18kXSpbQS1aXVthLXpBLVowLTlfJF0qJCcsJ2cnKTtcbiAgICAgICAgaWYgKGlzVXBwZXIudGVzdChzdHJlYW0uY3VycmVudCgpKSkge1xuICAgICAgICAgIHJldHVybiAndHlwZSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///69\n')}}]);